(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE OOPV; (** non-portable / source: Win32.OOPV.Mod *)	(* NM 12.12.93 / MH 26.1.94 *)
(*
	code generator for Intel i386, i387/ i486 - Diplomarbeit ETH-Zürich WS 92/93
	by Niklaus Mannhart, 87-913-117I
	author's address: 	Himmelrich 22
		6340 Baar, Switzerland
		e-mail: mannhart@inf.ethz.ch	phone: +41 (0)42 31 40 33

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

	March the 2nd 1993
	Release 12.12.93 / Release 1.0 
	Release 12.1.94 / Release 1.1 (fixed bugs in OOPL.LoadProc and floating point compare (OOPL.FloadCmp))
	Release 30.3.94 fixed bug in OOPV.Dim
	Release 23.6.94  / Release 1.3 (fixed: bug in OOPL.Load, OOPC.SYSgetputReg, floating point problem in OOPL.PushRegs);
*)

	IMPORT
		OPS := OOPS, OPT := OOPT, OPL := OOPL, OPO := OOPO, OPC := OOPC, OPM := OOPM, S := SYSTEM;
	
	CONST
		(* object modes *)
		Var = 1; VarPar = 2; Con = 3; Fld = 4; Typ = 5; LProc = 6; XProc = 7;
		CProc = 9; TProc = 13;
		
		(* item mode *)
		Abs = OPO.Abs;

		(* symbol values and ops *)
		times = 1; slash = 2; div = 3; mod = 4;
		and = 5; plus = 6; minus = 7; or = 8; eql = 9;
		geq = 14;
		in = 15; is = 16; ash = 17; msk = 18; len = 19;
		conv = 20; abs = 21; cap = 22; odd = 23; not = 33;
		(*SYSTEM*)
		adr = 24; cc = 25; bit = 26; lsh = 27; rot = 28; val = 29;

		(* structure forms *)
		Byte = 1; LInt = 6;
		Real = 7; LReal = 8; Set = 9; String = 10; NilTyp = 11;
		Pointer = 13; ProcTyp = 14; Comp = 15;

		(* composite structure forms *)
		Array = 2; DynArr = 3; Record = 4;

		(* nodes classes *)
		Nvar = 0; Nvarpar = 1; Nfield = 2; Nderef = 3; Nindex = 4; Nguard = 5; Neguard = 6;
		Nconst = 7; Nproc = 9; Nupto = 10; Nmop = 11; Ndop = 12; Ncall = 13;
		Ninittd = 14; Nenter = 18; Nassign = 19;
		Nifelse =20; Ncase = 21; Nwhile = 22; Nrepeat = 23; Nloop = 24; Nexit = 25;
		Nreturn = 26; Nwith = 27; Ntrap = 28;

		(* node classes for inline instructions*)
		Nassembler = 29;
		Ncode = 30;
		Nfixup = 31;

		(*function number*)
		assign = 0; newfn = 1; incfn = 13; decfn = 14;
		inclfn = 15; exclfn = 16; copyfn = 18; assertfn = 32;

		(*SYSTEM function number*)
		getfn = 24; putfn = 25; getrfn = 26; putrfn = 27; sysnewfn = 30; movefn = 31;

		(* module visibility of objects *)
		internal = 0; external = 1;

		(* procedure flags (conval^.setval) *)
		hasBody = 1; isRedef = 2; slNeeded = 3; asmProc = 7;

		(* sysflag or proc^.conval^.realval *) (* ejz *)
		notag = 1; stdcall = 2; cdecl = 3;

	MaxAdr 	= OPM.MaxLInt;
	MinAdr 	= OPM.MinLInt;
	VarParSize 	= OPM.PointerSize;
	RecVarParSize 	= 8; 	(* push ADR (rec); push TAG (reg) *)
	LProcOffSL 	= 12; 	(* parameter offset with static link *)
	LProcOff 	= 8; 	(* parameter offset without static link *)
	ExtProcOff 	= 8; 	(* parameter offset of external procedures *)

	VAR
		ProcName*: OPS.Name; (* accessed by OOPI (read only) *)
		EntryNr*: INTEGER; (* accessed by OOPI (read only) *)
		ExitChain: OPC.Label;
		allocTd, assert, findpc: BOOLEAN; 
	
	PROCEDURE Init* (opt: SET; bpc: LONGINT);
		CONST ass = 6; fpc = 7;
	BEGIN
		assert := ass IN opt; findpc := fpc IN opt; allocTd := TRUE;
		IF findpc THEN OPM.breakpc := bpc ELSE OPM.breakpc := MAX(LONGINT) END
	END Init;

	PROCEDURE IncAdr(VAR adr: LONGINT; s: LONGINT);
	BEGIN
		IF (s >= 0) & (adr <= MaxAdr - s) OR (s < 0) & (adr >= MinAdr - s) THEN INC(adr, s)
		ELSE OPM.err(242)
		END
	END IncAdr;
	
	PROCEDURE AlignFld(VAR offset: LONGINT; elemsize: LONGINT);
	(* offset is initialized to base type size, 0 if none *)
	BEGIN
		IF elemsize >= 4 THEN IncAdr(offset, (-offset) MOD 4)
		ELSIF elemsize = 2 THEN IncAdr(offset, offset MOD 2)
		END
	END AlignFld;
	
	PROCEDURE AllocFld(VAR offset, this: LONGINT; elemsize: LONGINT);
	BEGIN
		this := offset; IncAdr(offset, elemsize)
	END AllocFld;
	
	PROCEDURE AlignRec(VAR size: LONGINT);
	BEGIN 
		IncAdr(size, (-size) MOD 4)
	END AlignRec;
	
	PROCEDURE AlignPar(VAR elemsize: LONGINT);
	BEGIN 
		IncAdr(elemsize, (-elemsize) MOD 4)
	END AlignPar;
	
	PROCEDURE AllocPar (VAR adr, this: LONGINT; elemsize: LONGINT);
	BEGIN
		IncAdr(adr, elemsize); this := adr
	END AllocPar;

	PROCEDURE AlignVar(VAR adr: LONGINT; elemsize: LONGINT);
	BEGIN
		IF elemsize >= 4 THEN IncAdr(adr, - (adr MOD 4))
		ELSIF elemsize = 2 THEN IncAdr(adr, - (adr MOD 2))
		END
	END AlignVar;
	
	PROCEDURE AllocVar(VAR adr, this: LONGINT; elemsize: LONGINT);
	BEGIN
		IncAdr(adr, -elemsize); this := adr
	END AllocVar;
	
	PROCEDURE AlignBlock(adr: LONGINT; VAR dsize: LONGINT);
	BEGIN 
		IncAdr(adr, - (adr MOD 4)); dsize := -adr
	END AlignBlock;

	PROCEDURE ^ParamAdr(VAR firstPar: OPT.Object; VAR psize, dsize: LONGINT; allocDesc: BOOLEAN);

	PROCEDURE ^Traverse(obj: OPT.Object; exported: BOOLEAN);

	PROCEDURE ^VisitTProcs(obj: OPT.Object);

	PROCEDURE TypSize* (typ: OPT.Struct; allocDesc: BOOLEAN);
		VAR f, c: INTEGER; offset, size, dummy: LONGINT;
			fld: OPT.Object; btyp, ftyp: OPT.Struct; sizeUndef, doAlloc: BOOLEAN;
	BEGIN
		IF (typ = OPT.undftyp) OR (typ = NIL) THEN OPM.err(58)		(* MH 26.1.94; bug fix RC 17.6.93 *)
		ELSE
			sizeUndef := typ^.size = -1;
			doAlloc := allocDesc & (typ^.tdadr = OPM.TDAdrUndef) & (typ^.offset = OPM.TDAdrUndef);
			IF sizeUndef OR doAlloc THEN
				IF doAlloc THEN typ^.tdadr := -2 (* avoid cycles *) END ;
				f := typ^.form; c := typ^.comp; btyp := typ^.BaseTyp;
				IF c = Record THEN
					IF btyp = NIL THEN offset := 0
					ELSE TypSize(btyp, allocDesc); offset := btyp^.size
					END ;
					fld := typ^.link;
					WHILE (fld # NIL) & (fld^.mode = Fld) DO
						ftyp := fld^.typ; TypSize(ftyp, allocDesc);
						IF sizeUndef THEN size := ftyp^.size;
							WHILE ftyp^.comp = Array DO ftyp := ftyp^.BaseTyp END ;
							AlignFld(offset, ftyp^.size);
							AllocFld(offset, fld^.adr, size)
						END ;
						fld := fld^.link
					END ;
					IF sizeUndef THEN AlignRec(offset); typ^.size := offset END ;
					IF (doAlloc) & (typ.mno <= 0) THEN
						IF allocTd THEN OPL.AllocTypDesc (typ) END; (* typ.tdadr = Entry number *)
						Traverse(typ^.link, TRUE)
					END;
					IF btyp = NIL THEN typ^.n := 0 ELSE typ^.n := btyp^.n END ;
					VisitTProcs(typ^.link);
				ELSIF c = Array THEN
					TypSize(btyp, allocDesc);
					IF sizeUndef THEN typ^.size := typ^.n * btyp^.size END ;
				ELSIF f = Pointer THEN
					typ^.size := OPM.PointerSize;
					IF doAlloc THEN TypSize(btyp, allocDesc) END
				ELSIF f = ProcTyp THEN
					typ^.size := OPM.ProcSize;
					IF doAlloc THEN TypSize(btyp, TRUE); size := ExtProcOff END;
					ParamAdr(typ^.link, size, dummy, allocDesc)
				ELSE (* (c = DynArr) & doAlloc *)
					TypSize(btyp, allocDesc);
					IF btyp^.comp = DynArr THEN typ^.size := btyp^.size + 4; typ^.offset := btyp^.offset + 4
					ELSE typ^.size := 8; typ^.offset := 4
					END
				END
			END
		END
	END TypSize;

	PROCEDURE ParamAdr (VAR firstPar: OPT.Object; VAR psize, dsize: LONGINT; allocDesc: BOOLEAN); (* ejz *)
		VAR par, parOld: OPT.Object; typ: OPT.Struct; adr, s: LONGINT; stop: BOOLEAN;
	BEGIN 
		adr := 0; 
		par := firstPar;
		IF par # NIL THEN
			stop := FALSE;
			WHILE par.link # NIL DO par := par.link END;
			WHILE ~stop DO
				stop := par = firstPar;
				typ := par^.typ; TypSize(typ, allocDesc (* TRUE *));
				IF typ.comp = DynArr THEN s:= typ.size;
				IF typ.sysflag = notag THEN DEC(s, 4) END;
				ELSIF (par.mode = VarPar) OR ((typ.size > 4) & (typ.form # LReal)) THEN 
						(* ValPar (RECORD), size > 4 are equal to VarPar *)
					IF (typ.comp = Record) & (par.mode = VarPar) THEN s:= RecVarParSize;
					IF typ.sysflag = notag THEN DEC(s, 4) END;
					ELSE s:= VarParSize
					END
				ELSE s:= typ.size
				END;
				AlignPar(s);
				AllocPar(adr, par^.adr, s); 
				parOld := par;
				par := firstPar;
				WHILE ~stop & (par.link # parOld) DO par := par.link END
			END
		END ;
		psize := psize + adr;
		par := firstPar;
		IF par # NIL THEN
			stop := FALSE;
			WHILE par.link # NIL DO par := par.link END;
			WHILE ~stop DO
				stop := par = firstPar;
				par^.adr := psize - par^.adr;
				IF (par^.mode = Var) & (par^.typ.comp IN {Array, Record}) THEN
					(* Value parameter of type ARRAY or RECORD will be copied by the callee *)
					dsize:= dsize + par^.typ^.size;
					par^.linkadr:= -dsize
				ELSE par^.linkadr:= par.adr
				END;
				parOld := par;
				par := firstPar;
				WHILE ~stop & (par.link # parOld) DO par := par.link END
			END
		END
	END ParamAdr;
	
	PROCEDURE VarAdr(var: OPT.Object; VAR dsize: LONGINT);
		VAR adr, s: LONGINT;
	BEGIN 
		adr := -dsize;
		WHILE var # NIL DO
			IF var.vis = internal THEN
				TypSize(var^.typ, TRUE); s := var^.typ^.size;
				AlignVar(adr, s);
				AllocVar(adr, var.linkadr, s);
				var.adr := 0
			END;
			var := var^.link
		END;
		AlignBlock(adr, dsize)
	END VarAdr;
	
	PROCEDURE ProcSize(obj: OPT.Object; firstpass: BOOLEAN);
		VAR psize, oldPos, entryNr: LONGINT;
	BEGIN
		oldPos := OPM.errpos; OPM.errpos := obj^.scope^.adr;
		TypSize(obj.typ, TRUE);
		IF ((obj^.vis # internal) = firstpass) OR (obj^.mode = TProc) THEN
			IF obj^.mode = LProc THEN
				IF slNeeded IN obj^.conval^.setval THEN psize := LProcOffSL ELSE psize := LProcOff END ;
				obj^.adr := 0
			ELSE psize := ExtProcOff
			END ;
			IF ~(obj^.mode IN {LProc, CProc, TProc}) THEN 
				OPL.NewEntry(entryNr); INC (obj.adr, entryNr)
			END;
			TypSize(obj^.typ, TRUE);
			ParamAdr(obj^.link, psize, obj^.conval^.intval2, TRUE); obj^.conval^.intval := psize;
			obj^.linkadr := OPM.LANotAlloc;
		END ;
		IF ~firstpass & (obj^.mode # TProc) THEN	(* mfix *)
			IF ~(hasBody IN obj^.conval^.setval) THEN OPM.err(129) END ;
			VarAdr(obj^.scope^.scope, obj^.conval^.intval2);	(* local variables *)
			Traverse(obj^.scope^.right, FALSE)
		END;
		OPM.errpos := oldPos
	END ProcSize;

	PROCEDURE VisitTProcs(obj: OPT.Object);	(* TProcs of base type already visited *)
		VAR typ: OPT.Struct; redef: OPT.Object;
	BEGIN
		IF obj # NIL THEN
			VisitTProcs(obj^.left);
			IF obj^.mode = TProc THEN
				typ := obj^.link^.typ;
				IF typ^.form = Pointer THEN typ := typ^.BaseTyp END ;
				OPT.FindField(obj^.name, typ^.BaseTyp, redef, FALSE);
				IF redef # NIL THEN
					obj^.adr := 10000H*(redef^.adr DIV 10000H) (*mthno*) + (obj^.adr MOD 10000H) (*entno*);
					IF ~(isRedef IN obj^.conval^.setval) THEN OPM.err(119) END
				ELSE 
					obj.adr := (obj.adr MOD 10000H) + 10000H*typ.n; INC(typ^.n);
				END;
			END;
			VisitTProcs(obj^.right)
		END
	END VisitTProcs;

	PROCEDURE Traverse(obj: OPT.Object; exported: BOOLEAN);
	BEGIN
		IF obj # NIL THEN
			Traverse(obj^.left, exported);
			IF (obj^.mode = Typ) & ((obj^.vis # internal) = exported) THEN TypSize(obj^.typ, TRUE);
				IF (obj.typ.comp = Record) & (obj.typ.tdadr <= -1) THEN OPL.AllocTypDesc(obj.typ) END;	(* mfix *)
			ELSIF obj.mode IN {LProc, XProc, TProc, CProc} THEN ProcSize(obj, exported)
			END ;
			Traverse(obj^.right, exported);
		END
	END Traverse;

	PROCEDURE AssignTent (obj: OPT.Object);	(* mfix *)
		VAR typ: OPT.Struct;	
		
		PROCEDURE EnumTprocs(fld: OPT.Object);
			VAR entryNr: LONGINT;
		BEGIN
			IF fld # NIL THEN
				EnumTprocs(fld.left);
				IF (fld.mode = TProc) THEN
					IF fld.adr MOD 10000H = 0 THEN 
						IF ~(hasBody IN fld^.conval^.setval) THEN OPM.err(129) END;
						VarAdr(fld^.scope^.scope, fld^.conval^.intval2);	(* local variables *)
						Traverse(fld^.scope^.right, FALSE);
						OPL.NewEntry(entryNr); INC(fld.adr, entryNr)
					END;
				END;
				EnumTprocs(fld.right);
			END
		END EnumTprocs;

	BEGIN
		IF obj # NIL THEN
			AssignTent (obj.left);
			IF obj.mode = Typ THEN
				typ := obj.typ;
				IF typ.form = Pointer THEN EnumTprocs(typ.BaseTyp.link)
				ELSIF (typ.form = Comp) & (typ.comp = Record) THEN EnumTprocs(typ.link)
				END
			END;
			AssignTent (obj.right);
		END
	END AssignTent;

	PROCEDURE AssignEntries*(obj: OPT.Object; browse: BOOLEAN);	(* ejz *)	(*assign entry numbers of imported objects*)
		VAR adr, nofEntries, nofRecs: LONGINT; typ: OPT.Struct; 
	BEGIN
		allocTd := FALSE;
		adr := 0; nofEntries := 1;  nofRecs := -4;
		WHILE obj # NIL DO
			IF obj.mode = Var THEN
				typ := obj.typ;
				TypSize(typ, TRUE);
				IF browse THEN AlignVar(adr, typ.size); AllocVar(adr, obj.linkadr, typ.size); obj.adr := adr END;
			ELSIF obj.mode=XProc THEN
						obj.adr:=nofEntries; INC(nofEntries);
				IF obj.conval = NIL THEN obj.conval := OPT.NewConst() END;
				obj.linkadr:=OPM.LANotAlloc;
				obj.conval.intval:=-1;
				ParamAdr(obj^.link, obj.conval.intval, obj.conval.intval2, TRUE);
			ELSIF obj.mode = Typ THEN
				typ := obj.typ;
				obj.linkadr:=OPM.LANotAlloc;
				TypSize(typ, TRUE);
				IF typ.comp=Record THEN typ.tdadr:=OPM.TDAdrUndef;
					IF browse THEN typ.tdadr:=nofRecs; DEC(nofRecs, 4) END 
				END
			END;
			obj:=obj.nxtobj;
		END;
		allocTd := TRUE
	END AssignEntries;
	
	PROCEDURE AssignOwnEntries(obj: OPT.Object);
	VAR size: LONGINT;
	BEGIN
		allocTd := FALSE;
		WHILE obj # NIL DO
			IF (obj.mode = Var) THEN
				TypSize(obj.typ, TRUE); size := obj.typ.size;
				AlignVar(OPO.dsize, size);
				AllocVar(OPO.dsize, obj.linkadr, size);
				obj.adr := 0
			ELSIF obj.mode = XProc THEN ProcSize(obj, TRUE)
			ELSIF (obj.mode = Typ) & (obj.typ.comp = Record) THEN
				IF (obj.typ.tdadr <= 0) THEN
					TypSize(obj.typ, TRUE);
					OPL.AllocTypDesc(obj.typ)
				END;
			END;
			obj:=obj.nxtobj
		END;
		allocTd := TRUE
	END AssignOwnEntries;
	
	PROCEDURE AllocAddEntries(obj: OPT.Object);
	VAR typ: OPT.Struct; 
	BEGIN
		WHILE obj # NIL DO
			typ := obj.typ;
			IF (obj.mode = Typ) & obj.used THEN
				IF (typ.comp = Record) & (typ.tdadr <= 0) THEN
					OPL.AllocTypDesc(obj.typ)
				ELSIF (obj.typ.form = Pointer) & (typ.BaseTyp.tdadr <= 0) THEN
					OPL.AllocTypDesc(obj.typ.BaseTyp)
				END
			END;
			obj := obj.nxtobj
		END
	END AllocAddEntries;

	PROCEDURE AdrAndSize* (topScope: OPT.Object);
	VAR i: INTEGER; dsize: LONGINT;
	BEGIN
		OPM.errpos := topScope^.adr;	(* text position of scope used if error *)
		OPO.dsize := 0;
		i := 1;
		WHILE i < OPT.nofmod DO
			AssignEntries(OPT.modules[i].publics, FALSE);
			INC(i)
		END;
		AssignOwnEntries(OPT.objects);
		Traverse(topScope^.right, FALSE);	(* second pass *)
		AssignTent(topScope^.right);	(* mfix *)

		dsize := -OPO.dsize;
		VarAdr(topScope^.scope, dsize);	(* global variables *)
		OPO.dsize := dsize;
		i := 1; WHILE i < OPT.nofmod DO AllocAddEntries(OPT.modules[i].publics); INC(i) END
	END AdrAndSize;

	PROCEDURE^ Expression(n: OPT.Node; VAR z: OPC.Item);

	PROCEDURE Designator (n: OPT.Node; VAR x: OPC.Item); (* ejz *)
		VAR
			obj: OPT.Object; 
			y: OPC.Item;
			index: LONGINT;
			varRec: BOOLEAN;
	BEGIN
		CASE n.class OF
			Nvar, Nvarpar:
				obj := n.obj; 
				x.node := n; x.mnolev := obj.mnolev; x.scale := OPO.noScale; x.inx := OPL.none;
				IF obj.mnolev <= 0 THEN (* global or imported variable *)
					x.mode := Abs;
					IF obj.mnolev < 0 THEN
						IF obj.adr DIV 10000H = 0 THEN (* no link entry yet *)
							OPL.NewVarCons (-obj.mnolev, SHORT (obj.adr), index);
							obj.adr := index * 10000H + obj.adr	(* index entry *)
						END;
						x.adr := 0
					ELSE x.adr := obj.linkadr
					END
				ELSE (* Var, VarPar *)
					x.mode := obj.mode; x.adr := obj.linkadr
				END;
				x.offs := 0;
				IF (obj.typ.comp IN {DynArr, Array}) & (x.mode  IN {Var, VarPar}) THEN
					x.descReg := OPL.RiscFP; x.descOffs := x.adr
				END;
		  | Nfield:
				Designator (n.left, x);
				OPC.Field (x, n.obj.adr)
		  | Nderef:
				Designator (n.left, x); 
				OPC.DeRef (x);
				IF n.typ.comp = DynArr THEN
					x.descReg := x.adr; x.descOffs := OPC.PtrToArrOffs; 
					(* x.offs := OPC.PtrToArrOffs +  4 + (n.typ.n + 1) * 4 *)
					x.offs := OPC.PtrToArrOffs + 8 + 8*((n.typ.n+1) DIV 2)	(* dVdW *)					
					(* x.descOffs = length descriptor start - 4 => same descriptor layout as for open array params *)
				END
		  | Nindex:
				Expression (n.right, y); Designator (n.left, x); OPC.Index (x, y)
		  | Nguard:
				varRec := (n.left.class = Nvarpar) & (n.left.typ.comp = Record);
				Designator (n.left, x);
				OPC.TypeTest (x, n.typ, TRUE, FALSE, varRec)
		  | Neguard:
				varRec := (n.left.class = Nvarpar) & (n.left.typ.comp = Record);
				Designator (n.left, x);
				OPC.TypeTest (x, n.typ, TRUE, TRUE, varRec)
		  | Nproc:
				IF (n.obj.mode IN {XProc, TProc}) & (n.obj.conval.intval = -1) THEN
					n.obj.conval.intval := OPC.ArgSize(n.obj.link) + 8
				END;
				OPC.Procedure (x, n)
		END;
		x.typ := n.typ
	END Designator;

	PROCEDURE ActualPar (n: OPT.Node; fp: OPT.Object; VAR proc: OPC.Item); (* ejz *)
		VAR ap: OPC.Item; p, q: OPT.Node; formPar: OPT.Object;
	BEGIN
		IF n # NIL THEN
			p := n; formPar := fp;
			WHILE p.link # NIL DO 
				p := p.link; formPar := formPar.link
			END;
			WHILE p # n DO
				Expression (p, ap);
				OPC.Parameter (ap, formPar, p^.class = Nderef); (* mh 16.2.94 *)
				q := n; formPar := fp;
				WHILE q.link # p DO 
					q := q.link; formPar := formPar.link
				END;
				p := q
			END;
			Expression (n, ap);
			OPC.Parameter (ap, fp, n^.class = Nderef); (* mh 16.2.94 *)
		END
	END ActualPar;

	PROCEDURE Expression (n: OPT.Node; VAR z: OPC.Item);
		VAR x, y: OPC.Item; f: INTEGER; real: REAL; con: OPT.Const;
		
		PROCEDURE AllocConst (VAR bytes: ARRAY OF S.BYTE; len, align: LONGINT);
			VAR con1, con2: OPT.Const;
		BEGIN
			con1 := con;
			IF n.obj = NIL THEN OPL.AllocConst (bytes, len, align, con1.intval)
			ELSE
				con2 := n.obj.conval;
				IF con2.intval = OPM.ConstNotAlloc THEN OPL.AllocConst (bytes, len, align, con2.intval) END;
				con1.intval := con2.intval
			END
		END AllocConst;
		
	BEGIN
		z.node := NIL;
		CASE n.class OF
			Nconst:
				z.typ := n.typ; z.mnolev := 0; z.node := NIL; (* constants have no node *)
				con := n.conval;
				CASE z.typ.form OF
					Byte..LInt, NilTyp, Pointer:
						z.mode := Con; z.adr := con.intval
				  | Set:
						z.mode := Con; z.adr := S.VAL (LONGINT, con.setval)
				  | String:
						AllocConst (con.ext^, con.intval2, 4); 
						z.mode := Abs; z.adr := con.intval; z.offs := con.intval2 (* length *); z.inx := OPL.none
				  | Real:
						real := SHORT (con.realval);
						AllocConst (real, 4, 4); 
						z.mode := Abs; z.adr := con.intval; z.inx := OPL.none
				  | LReal:
						AllocConst (con.realval, 8, 4);
						z.mode := Abs; z.adr := con.intval; z.inx := OPL.none
				END
		  | Nupto:
				Expression (n.left, x); Expression (n.right, y); OPC.SetRange (z, x, y)
		  | Nmop:
				IF n.subcl # is THEN Expression (n.left, x) END;
				z := x;
				CASE n.subcl OF
					not:
						OPC.Not (z, x)
				  | minus:
						OPC.Neg (z, x)
				  | is:
						Designator (n.left, z);
						IF n.obj.typ.form = Pointer THEN OPC.TypeTest (z, n.obj.typ, FALSE, FALSE, FALSE)
						ELSE OPC.TypeTest (z, n.obj.typ, FALSE, FALSE, TRUE)
						END
				  | conv:
						IF n.typ.form = Set THEN OPC.SetElem (z, x)
						ELSE
							z := x; OPC.Convert (z, n.typ.form)
						END
				  | abs:
						OPC.AbsVal (z, x)
				  | cap:
						OPC.Cap (z, x)
				  | odd:
						OPC.Odd (z, x)
				  | adr, cc, val: (* Module SYSTEM *)
						OPC.SYSmop (z, x, n.subcl, n.typ)
				END;
		  | Ndop:
				Expression (n.left, x); f := x.typ.form; 
				IF n.subcl = and THEN OPC.CondAnd (x)
				ELSIF n.subcl = or THEN OPC.CondOr (x)
				ELSIF (n.subcl >= eql) & (n.subcl <= geq) THEN OPC.Relation (x)
				END;
				Expression (n.right, y);
				CASE n.subcl OF
					times:
						OPC.Mul (z, x, y, f)
				  | slash, div:
						OPC.Div (z, x, y, f)
				  | mod:
						OPC.Mod (z, x, y)
				  | and:
						OPC.And (z, x, y)
 				 | plus:
						OPC.Add (z, x, y, f)
				  | minus:
						OPC.Sub (z, x, y, f)
				  | or:
						OPC.Or (z, x, y)
				  | eql..geq:
						OPC.Cmp (z, x, y, n.subcl)
				  | in:
						OPC.In (z, x, y)
				  | ash:
						OPC.Ash (z, x, y)
				  | msk:
						OPC.Msk (z,  x, y)
				  | len:
						OPC.Len (z, x, y)
				  | (* SYSTEM *) bit, lsh, rot:
						OPC.SYSdop (z, x, y, n.subcl)
				END
		  | Ncall:
				OPC.PushRegs;
				ActualPar (n.right, n.obj, z);
				Designator (n.left, z);
				IF n.left.class = Nproc THEN OPC.Call (z, n.left.obj, n)
				ELSE OPC.Call (z, NIL, n)
				END;
				OPC.PopResult (n, z); (* pop register and put result into z *)
		ELSE
			Designator (n, z)
		END;
		z.typ := n.typ;
	END Expression;
	
	PROCEDURE^ Statement (n: OPT.Node);

	PROCEDURE IfStat (n: OPT.Node; VAR Lfix, Lcfix: OPC.Label; else: BOOLEAN);
		VAR x: OPC.Item;
	BEGIN
		LOOP
			OPM.errpos := n.conval.intval;
			Expression (n.left, x);  OPC.Jncc (x, Lcfix, n); Statement (n.right);
			IF n.link = NIL THEN EXIT END;
			OPC.Jmp (Lfix, n); OPC.FixLink (Lcfix);
			n := n.link
		END;
		IF else THEN OPC.Jmp (Lfix, n) END
	END IfStat;
	
	PROCEDURE CaseStat (n: OPT.Node);
		VAR 
			case, interval: OPT.Node;
			x: OPC.Item;
			L, elseLabel, dummy: OPC.Label;
			low, high, tab: LONGINT;
	BEGIN
		Expression (n.left, x); low := n.right.conval.intval; high := n.right.conval.intval2;
		L := OPC.Nil;
		OPC.Case (x, low, high, tab, elseLabel, n);
		case := n.right.left;
		WHILE case # NIL DO
			OPC.DefLabel (dummy); (* label entry: used for common subexpression elimination *)
			interval := case.left;
			WHILE interval # NIL DO
				OPL.CaseJump (OPC.pc, tab, interval.conval.intval - low, interval.conval.intval2 - low);
				interval := interval.link
			END;
			Statement (case.right); OPC.Jmp (L, n);
			case := case.link;
		END;
		OPC.FixLink (elseLabel); elseLabel := OPC.pc;
		IF n.right.conval.setval # {} THEN Statement (n.right.right) (* ELSE part *)
		ELSE OPC.Trap (OPL.CaseTrap, n)
		END;
		OPC.CaseFixup (tab, elseLabel, high - low + 1);
		OPC.FixLink (L) 
	END CaseStat;

	PROCEDURE Dim (VAR z, nofelem: OPC.Item; n: OPT.Node; typ: OPT.Struct; nofdim: LONGINT);
		VAR
			nofArrElems: LONGINT;
			len, cons: OPC.Item;
			btyp: OPT.Struct;
	BEGIN
		Expression (n, len);
		OPC.PushLen (len);
		IF len.mode # Con THEN OPC.GenDimTrap (len) END;
		IF nofdim = 1 THEN 
			nofelem := len; nofelem.typ := OPT.linttyp
		ELSE OPC.MulDim (nofelem, len)
		END;
		IF n.link # NIL THEN Dim (z, nofelem, n.link, typ.BaseTyp, nofdim + 1)
		ELSE
			btyp := typ.BaseTyp; nofArrElems := 1 (*0*) ;	(* <<< mh 30.3.1994 *)
			WHILE btyp.comp = Array DO
				nofArrElems := nofArrElems * btyp.n;
				btyp := btyp.BaseTyp
			END;
			IF nofArrElems # 1 (*0*) THEN	(* <<< mh 30.3.1994 *)
				cons.mode := Con; cons.typ := OPT.linttyp; cons.adr := nofArrElems; cons.node := NIL;
				OPC.MulDim (nofelem, cons)
			END;
			OPC.NewArray (z, nofelem, nofdim, btyp, TRUE);
			INC (z.offs, 4) (* z -> first len element *)
		END;
		OPC.PopLen (z); (* fill in each dimension size *)
		INC (z.offs, 4)
	END Dim;

	PROCEDURE Statement (n: OPT.Node); (* ejz *)
		VAR 
			x, z, times: OPC.Item; 
			L, Lc, prevExitChain: OPC.Label;
			proc, par: OPT.Object;
			name: ARRAY 64 OF CHAR;
			i, j: LONGINT;
			ch: CHAR;
	BEGIN 
		WHILE ~OPO.CodeErr & (n # NIL) DO 
			OPC.NewStat (n.conval.intval); 
			CASE n.class OF
				Nenter:
					IF n.obj = NIL THEN (* enter module *)
						OPC.pc := 0; OPC.RiscCodeErr := FALSE;
						OPC.Enter (NIL, 0, NIL);
						Statement (n.right);
						OPC.Exit (NIL);
						IF ~OPC.RiscCodeErr THEN
							OPL.GenCode (OPC.pc);
							OPL.OutRefPoint (NIL); OPL.OutRefName ("$$");
							OPL.OutRefs (OPT.topScope)
						END;
						INC (OPC.level); Statement (n.left); DEC (OPC.level)
					ELSE (* procedure *)
						proc := n.obj; par := proc.link;
						INC (OPC.level); Statement (n.left); DEC(OPC.level);
						OPC.pc := 0; OPC.RiscCodeErr := FALSE;
						OPC.Enter (proc, proc.conval.intval2, n);
						Statement (n.right);
						IF (proc.typ # OPT.notyp) & ~(asmProc IN proc.conval.setval) THEN OPC.Trap (OPL.FuncTrap, n)
						ELSE OPC.Exit (proc)
						END;
						OPL.OutRefPoint (proc);
						IF proc.mode = TProc THEN
							par := proc.link.typ.strobj;
							name[0] := "(";
							i := 1;
							ch := par.name[0];
							WHILE ch # 0X DO
								name[i] := ch; ch := par.name[i];
								INC (i)
							END;
							name[i] := ")"; INC (i);
							j := 0;
							ch := proc.name [0];
							WHILE (ch # 0X) & (i < 63) DO
								name[i] := ch; INC (i);
								INC (j); ch := proc.name[j]
							END;
							name[i] := 0X
						ELSE COPY (proc.name, name)
						END;
						OPL.OutRefName (name); OPL.OutRefs (proc.scope.right);
						IF ~OPC.RiscCodeErr THEN OPL.GenCode (OPC.pc) END
					END
			  | Ninittd: (* done by the loader *)
			  | Nassign:
					(*Expression (n.left, z);*)
					IF n.subcl # newfn THEN Expression (n.right, x); OPC.Relation(x) END; 
					Expression (n.left, z);
					IF n.subcl = movefn (* SYSTEM.Move *) THEN
						Expression (n.right.link, times);
						IF (z.typ.form = LInt) & (x.typ.form = LInt) THEN OPC.SYSmove (z, x, times)
						ELSE OPM.err(111)
						END
					ELSE
						CASE n.subcl OF
							assign: OPC.Assign (z, x)
						  | incfn, decfn: OPC.IncDec (z, x, n.subcl = incfn)
						  | inclfn, exclfn: OPC.Include (z, x, n.subcl = inclfn)
					 	 | getfn, putfn: OPC.SYSgetput (z, x, n.subcl = getfn)
					  	| getrfn, putrfn: OPC.SYSgetputReg (z, x, n.subcl = getrfn)
					  	| copyfn: OPC.Copy (z, x)
					  	| sysnewfn: OPC.NewSys (z, x)
					  	| newfn:
								IF n.right = NIL THEN OPC.NewRec (z, z.typ.BaseTyp)
								ELSE (* pointer to array *)
									Dim (z, x, n.right, z.typ.BaseTyp, 1)
								END
						END
					END
			  | Ncall:
					OPC.PushRegs;
					ActualPar (n.right, n.obj, x);
					Designator (n.left, x);
					IF n.left.class = Nproc THEN OPC.Call (x, n.left.obj, n)
					ELSE OPC.Call (x, NIL, n)
					END;
					OPC.PopResult (NIL, x) (* only pop register *)
			  | Nifelse:
					IF (n.subcl # assertfn) OR assert THEN
						L := OPC.Nil; Lc := OPC.Nil;
						IfStat (n.left, L, Lc, n.right # NIL); (* L label for jump to END of if statment, Lc for the ELSE statement *)
						OPC.FixLink (Lc);
						IF n.right # NIL THEN Statement (n.right) END;
						OPC.FixLink (L)
					END
			  | Ncase:
					CaseStat (n)
			  | Nwhile:
					L := OPC.Nil; OPC.Jmp (L, n);
					OPC.DefLabel (Lc); Statement (n.right);
					OPC.FixLink (L); Expression (n.left, x);
					OPC.Jcc (x, Lc, n)
			  | Nrepeat:
					OPC.DefLabel (L); Statement (n.left);
					Expression (n.right, x);
					OPC.Jncc (x, L, n)
			  | Nloop:
					prevExitChain := ExitChain; ExitChain := OPC.Nil;
					OPC.DefLabel (L); Statement (n.left); OPC.Jmp (L, n);
					OPC.FixLink (ExitChain); ExitChain := prevExitChain
			  | Nexit:
					OPC.Jmp (ExitChain, n)
			  | Nreturn:
					IF n.left # NIL THEN (* function *)
						Expression (n.left, x);
						OPC.Return (x, n.obj.typ.form)
					END;
					OPC.Exit (n.obj)
			  | Nwith:
					L := OPC.Nil; Lc := OPC.Nil;
					IfStat (n.left, L, Lc, TRUE); (* L label for jump to END of if statement, Lc for the ELSE statement *)
					OPC.FixLink (Lc);
					IF n.subcl = 1 (*  # NIL *) THEN Statement (n.right)
					ELSE OPC.Trap (OPL.WithTrap, n)
					END;
					OPC.FixLink (L)
			  | Ntrap:
					OPC.Trap (n.right.conval.intval, n)
			  | Nassembler:
			  	 OPC.GenAsm(n)
			END;
			n := n.link
		END; 
	END Statement;

	PROCEDURE Module* (prog: OPT.Node); (* ejz *)
	BEGIN
		Statement (prog);
		IF findpc & OPM.noerr THEN OPM.err (254) END
	END Module;

BEGIN OPT.typSize := TypSize
END OOPV.
