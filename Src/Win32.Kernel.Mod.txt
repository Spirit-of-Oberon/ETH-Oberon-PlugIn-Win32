(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Kernel; (** non-portable / source: Win32.Kernel.Mod *)	(* RC 23.7.92 / MH 3.2.1994 / 5.5.94 / tk 4.1.96 / ejz  *)

(**
Module Kernel is responsible for memory allocation, garbage collection, object finalization, module termination, interfacing to the underlying operating system, and clock functions. Using features exported from module Kernel may result in an unportable module, as not all Oberon Kernels are the same. This module is of little importance to most Oberon programmers.
*)

(* WARNING: do not use NEW nor SYSTEM.NEW in this module !! use NewRec, NewArr or NewSys instead *)
(* Finalization due to J. Templ *)
(* in blue: changes for non-contiguous heap allocation, jm *)

(*
	tk 21.8.95 - Fixed GC during type descriptor allocation.
	31.1.96 - adapted for Windows 95/NT Threads (ejz)
	13.6.98 - FreeBit (ejz)
*)

IMPORT S := SYSTEM, Kernel32;

CONST
	MarkBit = 0; ArrayBit = 1; FreeBit = 2; SubObjBit = 3;
	B = 32;	(* must be a mutiple of 32 *)
	N = 9;
	nil = 0;
	mark = {MarkBit}; array = {ArrayBit}; free = {FreeBit}; subobj = {SubObjBit};
	SuperBlockSize = 256 * 1024;
	ReserveBlockSize = 128*1024;	(* 128k *)

TYPE
	Name = ARRAY 32 OF CHAR;
	Tag* = POINTER TO TypeDesc;

	Handler* = PROCEDURE;

	Queue* = POINTER TO QElem;
	QElem = RECORD 
		link: Queue;
		handle: Handler
	END;
	TypeDesc = RECORD
		size: LONGINT;
		ptroff: LONGINT
	END;

	FreeBlockPtr = POINTER TO FreeBlock;
	FreeBlock = RECORD
		(* off-4 *) tag: Tag;
		(* off0 *) size: LONGINT;	(* field size aligned to 8-byte boundary, size MOD B = B-4 *)
		(* off4 *) next: Kernel32.ADDRESS
	END;

	BlockPtr* = POINTER TO Block;
	Block = RECORD
		lastElemToMark, currElem, firstElem: BlockPtr;
	END;

	Blockm4Ptr = POINTER TO Blockm4;
	Blockm4 = RECORD
		tag: Tag;
		lastElemToMark, currElem, firstElem: LONGINT;
	END;

	InitPtr = POINTER TO RECORD tag: Tag; z0, z1, z2, z3, z4, z5, z6, z7: LONGINT END;

	Cmd = RECORD name: Name; adr: LONGINT END;
	Module = POINTER TO RECORD 
		link: Module; 
		name: Name;
		init: BOOLEAN;
		refcnt, sb: LONGINT;
		dataSize, conSize, codeSize, refSize: LONGINT;
		nofEntries, nofCmds, nofImps, nofTds, nofPtrs: LONGINT;
		entries: POINTER TO ARRAY OF Kernel32.ADDRESS;
		cmds: POINTER TO ARRAY OF Cmd;
		ptrTab: POINTER TO ARRAY OF Kernel32.ADDRESS;
		tdescs: POINTER TO ARRAY OF (* Tag *) Kernel32.ADDRESS;
		imports: POINTER TO ARRAY OF (* Module *) Kernel32.ADDRESS;
		data, code: POINTER TO ARRAY OF CHAR
	END;

	PtrElemDesc = RECORD a: PTR END;	(* has same type descriptor as element of ARRAY OF POINTER *)

	Finalizer* = PROCEDURE (obj: PTR);
	FinObj = POINTER TO FinObjNode;
	FinObjNode = RECORD
		next: FinObj;
		obj: LONGINT;
		marked, basic: BOOLEAN;
		fin: Finalizer
	END;
	SuperBlockPtr = POINTER TO SuperBlock;
	SuperBlock = RECORD
		next: Kernel32.ADDRESS;
		size: LONGINT;
		firstblock: Kernel32.ADDRESS;
		endblock: Kernel32.ADDRESS
	END;

VAR
	modules-, hInstance-: LONGINT;	(** Anchor of all modules loaded in system *)
	heapAdr-, heapSize-: LONGINT;	(** Starting address and size of the Oberon heap *)
	GCenabled*: LONGINT;
	stackBottom*: LONGINT;	(** Stack pointer is reset to this value during a trap *)
													(* pointer to dynamic link of (the thread executing) Oberon.Loop *)
	EnableGC*, DisableGC*: Handler;
	firstBlock, endBlock: (*FreeBlockPtr*) Kernel32.ADDRESS;	(* free blocks must be collected !! *)
	A: ARRAY N+1 OF (*FreeBlockPtr*) Kernel32.ADDRESS;
	PointerTD, queueTD, finObjTD: LONGINT;
	firstTry: BOOLEAN;
	candidates: ARRAY 1024 OF LONGINT;
	nofcand: LONGINT;
	FinObjs: FinObj;
	getCodeSize*: PROCEDURE (VAR code, data: LONGINT);
	mkQ-, quitQ-: Queue;
	BeginAtomic*: PROCEDURE (): BOOLEAN;
	EndAtomic*: Handler;
	CheckStacks*: Handler;
	superblocks*: Kernel32.ADDRESS;	(* list of all super blocks *)
	oberonsuperblock: SuperBlock;	(* the Oberon super block *)
	supermin, supermax, reserve: Kernel32.ADDRESS;	(* boundaries between which all pointers should lie *)
	moduleCS: Kernel32.CriticalSection;
	version-: ARRAY 32 OF CHAR;

(* --- handler queues --- *)

PROCEDURE ^ NewRec* (tag: Tag; VAR p: Kernel32.ADDRESS);
(** Init a new handler queue *)
PROCEDURE InitQ*(VAR q: Queue);
	VAR l: LONGINT;
BEGIN Kernel32.EnterCriticalSection(S.ADR(moduleCS)); NewRec(S.VAL(Tag, queueTD), l); q:=S.VAL(Queue, l); q.link:=q; Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
END InitQ;

(** Install a queue-handler *)
PROCEDURE InstallQ*(q: Queue; p: Handler);
	VAR el: Queue; l: LONGINT;
BEGIN Kernel32.EnterCriticalSection(S.ADR(moduleCS)); NewRec(S.VAL(Tag, queueTD), l); el:=S.VAL(Queue, l); el.handle:=p; el.link:=q.link; q.link:=el; Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
END InstallQ;

(** Remove a queue-handler *)
PROCEDURE RemoveQ*(q: Queue; p: Handler; all: BOOLEAN);
	VAR el: Queue;
BEGIN Kernel32.EnterCriticalSection(S.ADR(moduleCS)); el:=q;
	LOOP
		IF el.link=q THEN Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN
		ELSIF el.link.handle=p THEN
			el.link:=el.link.link;
			IF ~all THEN Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN END
		ELSE el:=el.link END
	END;
	(*Kernel32.LeaveCriticalSection(S.ADR(moduleCS))*)
END RemoveQ;

(** Call all handlers installed in a queue *)
PROCEDURE HandleQ*(q: Queue);
	VAR el: Queue;
BEGIN Kernel32.EnterCriticalSection(S.ADR(moduleCS)); el:=q.link; WHILE el#q DO el.handle; el:=el.link END;
	Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
END HandleQ;

(** DisableTracing - Disable the GC tracing of a record field of the specified type.  For internal use only. *)

PROCEDURE DisableTracing*(recadr, fldadr: Kernel32.ADDRESS);
VAR t, i, j, ofs: Kernel32.ADDRESS;  n: LONGINT;
BEGIN
	S.GET(recadr-4, t);
	n := 0;  i := t+4;  S.GET(i, ofs);  j := 0;
	WHILE ofs >= 0 DO
		IF ofs = fldadr-recadr THEN j := i END;
		INC(n);  INC(i, 4);  S.GET(i, ofs)
	END;
	ASSERT((ofs = -4*(n+1)) & (j # 0), 32);
	S.GET(j+4, ofs);
	WHILE ofs >= 0 DO
		S.PUT(j, ofs);  INC(j, 4);  S.GET(j+4, ofs)
	END;
	S.PUT(j, -4*n)
END DisableTracing;

(** RegisterObject - Register a record for finalization. *)
PROCEDURE RegisterObject* (obj: PTR; fin: Finalizer; basic: BOOLEAN);
	VAR n: FinObj; l: LONGINT;
BEGIN
	Kernel32.EnterCriticalSection(S.ADR(moduleCS));
	NewRec(S.VAL(Tag, finObjTD), l); n := S.VAL(FinObj, l);
	n.next := FinObjs; n.obj := S.VAL(LONGINT, obj);
	n.fin := fin; n.basic := basic; n.marked := FALSE; FinObjs := n;
	Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
END RegisterObject;

(** Available - Return the size in bytes of the remaining free heap space *)
PROCEDURE Available*(): LONGINT;
	VAR i, avail: LONGINT; ptr: FreeBlockPtr;
BEGIN Kernel32.EnterCriticalSection(S.ADR(moduleCS)); avail := 0; i := 0;
	WHILE i <= N DO
		ptr := S.VAL(FreeBlockPtr, A[i]);
		WHILE ptr # NIL DO
			INC(avail, ptr^.size); ptr := S.VAL(FreeBlockPtr, ptr^.next)
		END;
		INC(i)
	END;
	IF reserve # 0 THEN avail := avail + ReserveBlockSize END;
	Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
	RETURN avail
END Available;

(** LargestAvailable - Return the size in bytes of the largest free available memory block. 
Allocating objects with a size greater than this size will cause the memory allocation to fail. *) 
PROCEDURE LargestAvailable*(): LONGINT;
BEGIN
	RETURN MAX(LONGINT)
END LargestAvailable;

	(* ------------------------- garbage collector ----------------------- *)

PROCEDURE Mark* (block: BlockPtr);
	TYPE Tag = POINTER TO RECORD (*size,*) ptroff: LONGINT  END;
		(* size skipped, because accessed via tag = actual tag + 4 *)
	VAR father, field, currElem: BlockPtr; offset: LONGINT; tag, downtag, marked: Tag; arraybit: SET;
BEGIN
	S.GET(S.VAL(Kernel32.ADDRESS, block)-4, tag);
	IF FreeBit IN S.VAL(SET, tag) THEN RETURN END;
	IF ~(SubObjBit IN S.VAL(SET, block)) THEN	(* not a subobject *)
		marked := S.VAL(Tag, S.VAL(SET, tag) + mark);
		IF tag # marked THEN
			S.PUT(S.VAL(Kernel32.ADDRESS, block)-4, marked);
			S.GET(S.VAL(Kernel32.ADDRESS, S.VAL(SET, tag) - array)-4, marked);
			(* (* unnecessary to mask mark bit *) *)
			EXCL(S.VAL(SET, marked), MarkBit); (* necessary to mask mark bit *)
			S.GET(S.VAL(Kernel32.ADDRESS, marked)-4, arraybit);
			INCL(arraybit, MarkBit);
			S.PUT(S.VAL(Kernel32.ADDRESS, marked)-4, arraybit);
			arraybit := S.VAL(SET, tag) * array;
			IF arraybit # {} THEN currElem := block^.firstElem;
				tag := S.VAL(Tag, S.VAL(SET, tag) - arraybit)
			ELSE currElem := block
			END;
			father := NIL;
			LOOP
				INC(S.VAL(Kernel32.ADDRESS, tag), 4);
				offset := tag^.ptroff;
				IF offset < 0 THEN
					INC(S.VAL(Kernel32.ADDRESS, tag), offset);
					IF (arraybit # {}) & (currElem # block^.lastElemToMark) THEN
						INC(S.VAL(Kernel32.ADDRESS, currElem), tag^.ptroff)
					ELSE (* up *)
						S.PUT(S.VAL(Kernel32.ADDRESS, block)-4, S.VAL(SET, tag) + arraybit + mark);
						IF father = NIL THEN EXIT END;
						S.GET(S.VAL(Kernel32.ADDRESS, father)-4, tag);
						arraybit := S.VAL(SET, tag) * array;
						tag := S.VAL(Tag, S.VAL(SET, tag) - (array + mark));
						IF arraybit # {} THEN currElem := father^.currElem
						ELSE currElem := father
						END;
						offset (*field address*) := S.VAL(Kernel32.ADDRESS, currElem) + tag^.ptroff;
						S.GET(offset, field); S.PUT(offset, block);
						block := father; father := field
					END
				ELSE
					offset (*field address*) := S.VAL(Kernel32.ADDRESS, currElem) + offset;
					S.GET(offset, field);
					IF field # NIL THEN
						S.GET(S.VAL(Kernel32.ADDRESS, field)-4, downtag);
						IF subobj * S.VAL(SET, field) = {} THEN	(* not a subobject *)
							marked := S.VAL(Tag, S.VAL(SET, downtag) + mark);
							IF downtag # marked THEN (* down *)
								S.PUT(S.VAL(Kernel32.ADDRESS, field)-4, marked);
								S.PUT(S.VAL(Kernel32.ADDRESS, block)-4, S.VAL(SET, tag) + arraybit + mark);
								IF arraybit # {} THEN block^.currElem:= currElem END;
								S.GET(S.VAL(Kernel32.ADDRESS, S.VAL(SET, downtag) - array)-4, marked);
								(* unnecessary to mask mark bit *)
								S.GET(S.VAL(Kernel32.ADDRESS, marked)-4, arraybit);
								INCL(arraybit, MarkBit);
								S.PUT(S.VAL(Kernel32.ADDRESS, marked)-4, arraybit);
								arraybit := S.VAL(SET, downtag) * array;
								IF arraybit # {} THEN currElem := field^.firstElem ELSE currElem := field END;
								S.PUT(offset, father);
								father := block; block := field;
								tag := S.VAL(Tag, S.VAL(SET, downtag) - arraybit)
							END
						ELSE	(* do not mark subobject *)
							S.GET(S.VAL(Kernel32.ADDRESS, S.VAL(SET, downtag) - array)-4, marked);
							EXCL(S.VAL(SET, marked), MarkBit);
							S.GET(S.VAL(Kernel32.ADDRESS, marked)-4, downtag);
							INCL(S.VAL(SET, downtag), MarkBit);
							S.PUT(S.VAL(Kernel32.ADDRESS, marked)-4, downtag)
						END
					END
				END
			END
		END
	ELSE (* do not mark subobject, subobjects are not traced *)
		S.GET(S.VAL(Kernel32.ADDRESS, S.VAL(SET, tag) - array)-4, tag);
		EXCL(S.VAL(SET, tag), MarkBit);
		S.GET(S.VAL(Kernel32.ADDRESS, tag)-4, arraybit);
		INCL(arraybit, MarkBit);
		S.PUT(S.VAL(Kernel32.ADDRESS, tag)-4, arraybit)
	END
END Mark;

PROCEDURE CheckFinObjs;
	VAR n: FinObj; tag: LONGINT;
BEGIN
	n := FinObjs;	(* find all checked objects that are marked *)
	WHILE n # NIL DO
		S.GET(n.obj - 4, tag);
		n.marked := MarkBit IN S.VAL(SET, tag);
		n := n.next
	END;
	n := FinObjs;	(* now mark all objects reachable from the marked checked objects *)
	WHILE n # NIL DO
		IF ~n.marked THEN Mark(S.VAL(BlockPtr, n.obj)) END;
		n := n.next
	END
END CheckFinObjs;

PROCEDURE Sweep;
	VAR p, end: Blockm4Ptr; lastp: FreeBlockPtr; tag, notmarked, tdesc: Tag; size, lastsize, i: LONGINT;
		lastA: ARRAY N+1 OF Kernel32.ADDRESS;
		thisSuper, lastSuper, nextSuper: SuperBlockPtr;
BEGIN
	i := 0; lastp := NIL;
	WHILE i <= N DO A[i] := nil; lastA[i] := S.ADR(A[i]); INC(i) END;
	
	lastSuper := NIL;
	thisSuper := S.VAL(SuperBlockPtr, superblocks);
	WHILE thisSuper # NIL DO
		p := S.VAL(Blockm4Ptr, thisSuper^.firstblock);
		end := S.VAL(Blockm4Ptr, thisSuper^.endblock);
		nextSuper := S.VAL(SuperBlockPtr, thisSuper^.next);

		lastsize := 0;
		WHILE p # end DO
			tag := S.VAL(Tag, S.VAL(SET, p^.tag) - free);
			notmarked := S.VAL(Tag, S.VAL(SET, tag) - mark);
			tdesc := S.VAL(Tag, S.VAL(SET, notmarked) - array);
			IF notmarked # tdesc THEN (* array block *) size := p^.lastElemToMark + tdesc^.size - S.VAL(Kernel32.ADDRESS, p);
			ELSE size := tdesc^.size + 4;
			END;
			size := S.VAL(LONGINT, S.VAL(SET, size + B-1)-S.VAL(SET, B-1));
			IF tag = notmarked THEN (* collect *)
				IF lastsize = 0 THEN lastp := S.VAL(FreeBlockPtr, p) END;
				INC(lastsize, size)
			ELSE
				p^.tag := notmarked;
				IF lastsize > 0 THEN
					lastp^.size := lastsize - 4;
					lastp^.tag := S.VAL(Tag, S.VAL(SET, S.ADR(lastp^.size)) + free);
					i := lastsize DIV B;
					IF i > N THEN i := N END;
					lastp^.next := nil;
					S.PUT(lastA[i], lastp);
					lastA[i] := S.ADR(lastp^.next);
					lastsize := 0
				END
			END;
			INC(S.VAL(Kernel32.ADDRESS, p), size)
		END;
	
		(* last collected block: *)
		IF (lastsize = thisSuper.endblock - thisSuper.firstblock) & (S.VAL(LONGINT, thisSuper) # S.ADR(oberonsuperblock)) THEN
			(* whole block is free, unlink it*)
			IF lastSuper = NIL THEN superblocks := S.VAL(LONGINT, nextSuper);
				supermin := S.VAL(LONGINT, nextSuper)
			ELSE lastSuper.next := thisSuper.next
			END;
			
			(* adjust  max pointer *)
			IF nextSuper = NIL THEN	(* hanged out the last block *)
				ASSERT(lastSuper # NIL, 32);
				supermax := lastSuper^.endblock
			END;

			Kernel32.VirtualFree(S.VAL(LONGINT, thisSuper), thisSuper.size, Kernel32.MEMDecommit);
			Kernel32.VirtualFree(S.VAL(LONGINT, thisSuper), 0, Kernel32.MEMRelease); thisSuper := NIL
		ELSIF lastsize > 0 THEN (* last collected block: *) lastSuper := thisSuper;
			lastp^.size := lastsize - 4;
			lastp^.tag := S.VAL(Tag, S.VAL(SET, S.ADR(lastp^.size)) + free);
			i := lastsize DIV B;
			IF i > N THEN i := N END;
			lastp^.next := nil;
			S.PUT(lastA[i], lastp);
			lastA[i] := S.ADR(lastp^.next)
		ELSE lastSuper := thisSuper	(* tk *)
		END;
		thisSuper := nextSuper;
	END
END Sweep;

PROCEDURE CheckCandidates;	(* nofcand > 0 *)
	VAR i, j, h, p: LONGINT; block, lastBlock, nextBlock: Blockm4Ptr; tag, notmarked, tdesc: Tag;
	thisSuper: SuperBlockPtr; 
BEGIN
	(* first sort them in increasing order using shellsort *)
	h := 1; REPEAT h := h*3 + 1 UNTIL h > nofcand;
	REPEAT h := h DIV 3; i := h;
		WHILE i < nofcand DO p := candidates[i]; j := i;
			WHILE (j >= h) & (candidates[j-h] > p) DO
				candidates[j] := candidates[j-h]; j := j-h;
			END;
			candidates[j] := p; INC(i)
		END
	UNTIL h = 1;
	
	(* sweep phase *)
	i := 0; p := candidates[0];

	thisSuper := S.VAL(SuperBlockPtr, superblocks);
	LOOP

		IF thisSuper = NIL THEN EXIT END;
		block := S.VAL(Blockm4Ptr, thisSuper^.firstblock);
		lastBlock := S.VAL(Blockm4Ptr, thisSuper^.endblock);

		(* next block calc *)
		tag := block^.tag;
		notmarked := S.VAL(Tag, S.VAL(SET, tag) - (mark+free));
		tdesc := S.VAL(Tag, S.VAL(SET, notmarked) - array);
		IF notmarked # tdesc THEN (* array block *) h := block^.lastElemToMark + tdesc^.size - S.VAL(Kernel32.ADDRESS, block)
		ELSE h := tdesc^.size + 4
		END;
		nextBlock := S.VAL(Blockm4Ptr, S.VAL(Kernel32.ADDRESS, block) + S.VAL(LONGINT, S.VAL(SET, h + B-1)-S.VAL(SET, B-1)));
		(* end of next block calc *)		
		
		LOOP
			IF p <= S.VAL(Kernel32.ADDRESS, block) + 4 THEN
				IF p = S.VAL(Kernel32.ADDRESS, block) + 4 THEN 
					S.GET(p-4, h);
					IF h # p THEN Mark(S.VAL(BlockPtr, p)) END
				END;
				INC(i);
				IF i = nofcand THEN EXIT END;
				p := candidates[i]
			ELSIF p <= S.VAL(Kernel32.ADDRESS, block) + 28 THEN (* system block *)
				IF p = S.VAL(Kernel32.ADDRESS, block) + 28 THEN Mark(S.VAL(BlockPtr, S.VAL(Kernel32.ADDRESS, block)+4)) END;
				INC(i);
				IF i = nofcand THEN EXIT END;
				p := candidates[i]
			ELSE
				block := nextBlock;
				IF block = lastBlock THEN EXIT END;
				
				(* next block calc *)

				tag := block^.tag;
				notmarked := S.VAL(Tag, S.VAL(SET, tag) - (mark+free));
				tdesc := S.VAL(Tag, S.VAL(SET, notmarked) - array);
				IF notmarked # tdesc THEN (* array block *) h := block^.lastElemToMark + tdesc^.size - S.VAL(Kernel32.ADDRESS, block)
				ELSE h := tdesc^.size + 4
				END;
				nextBlock := S.VAL(Blockm4Ptr, S.VAL(Kernel32.ADDRESS, block) + S.VAL(LONGINT, S.VAL(SET, h + B-1)-S.VAL(SET, B-1)))
				(* end of next block calc *)
			END
		END;
		IF i = nofcand THEN EXIT END;
		thisSuper := S.VAL(SuperBlockPtr, thisSuper.next)
	END;
	nofcand := 0
END CheckCandidates;

PROCEDURE - Less(x, y: LONGINT): BOOLEAN
	8BH, 0FCH, (* mov edi, esp *)
	8BH,  5FH,  0H, 	(* mov ebx, 0[edi] *)
	8BH, 57H, 04H,	(* mov edx, 4[edi] *)
	3BH, 0DAH,		(* cmp ebx, edx *)
	0FH, 92H, 0C0H;  (* setb al *)

PROCEDURE Candidate*(p: LONGINT);
	VAR tag: LONGINT; thisSuper: SuperBlockPtr;
BEGIN
	IF ((p MOD B = 0) OR (p MOD 16 = 8)) & Less(supermin, p) & Less(p, supermax) THEN
		thisSuper := S.VAL(SuperBlockPtr, superblocks);
		LOOP
			IF thisSuper = NIL THEN EXIT
			ELSIF Less(p, thisSuper.endblock) & Less(thisSuper.firstblock, p) THEN
				S.GET(p-4, tag);
				IF tag MOD 8 IN {0, 2} (* array or record, not yet marked, not free *) THEN
					candidates[nofcand] := p; INC(nofcand);
					IF nofcand = LEN(candidates) THEN CheckCandidates END
				END;
				EXIT
			END;
			thisSuper := S.VAL(SuperBlockPtr, thisSuper.next)
		END
	END
(*
	IF ((p MOD B = 0) OR (p MOD 16 = 8)) & (p > supermin) & (p < supermax) THEN
		S.GET(p-4, tag);
		IF tag MOD 8 IN {0, 2} (* array or record, not yet marked *) THEN
			candidates[nofcand] := p; INC(nofcand);
			IF nofcand = LEN(candidates) THEN CheckCandidates END
		END
	END
*)
END Candidate;

PROCEDURE FinalizeObjs;
	VAR n, prev: FinObj;
BEGIN
	n := FinObjs; prev := NIL;
	WHILE n # NIL DO
		IF ~n.marked THEN
			IF n = FinObjs THEN FinObjs := FinObjs.next ELSE prev.next := n.next END;
			n.fin(S.VAL(S.PTR, n.obj))	(* may ressurrect checked object *)
		ELSE prev := n
		END;
		n := n.next;
	END
END FinalizeObjs;

PROCEDURE ^ NewSys* (size: LONGINT; VAR p: Kernel32.ADDRESS);

(** GC - Immediately activate the garbage collector. *)
PROCEDURE GC*;
BEGIN
	IF (GCenabled = 1) & (CheckStacks # NIL) THEN
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		IF BeginAtomic() THEN
			HandleQ(mkQ);
			(* check stacks *)
			CheckStacks();
			IF nofcand > 0 THEN CheckCandidates END;
			CheckFinObjs;
			Sweep;
			FinalizeObjs;
			IF reserve = 0 THEN 
				reserve := Kernel32.VirtualAlloc(0, ReserveBlockSize + 16 + B, Kernel32.MEMCommit, Kernel32.PageReadWrite)
			END;
			EndAtomic()
		END;
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
	END
END GC;

	(* ---------------------------------------------------------------- *)

PROCEDURE FinalizeAll(basic: BOOLEAN);
	VAR n: FinObj;
BEGIN n := FinObjs;
	WHILE n # NIL DO
		IF basic = n.basic THEN
			n.fin(S.VAL(S.PTR, n.obj))
		END;
		n := n.next
	END
END FinalizeAll;

PROCEDURE DummyF*(): BOOLEAN;
BEGIN
	RETURN FALSE
END DummyF;

PROCEDURE Dummy*();
BEGIN
END Dummy;

(** Exit - Terminate Oberon with a fatal error. Termination handlers will be called. *)
PROCEDURE Exit* (err: LONGINT);
BEGIN
	Kernel32.EnterCriticalSection(S.ADR(moduleCS));
	GCenabled := MIN(INTEGER); CheckStacks := NIL;
	BeginAtomic := DummyF; EndAtomic := Dummy;
	IF err = 0 THEN
		FinalizeAll(FALSE);
		HandleQ(quitQ)
	END;
	FinalizeAll(TRUE);
	Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
	Kernel32.DeleteCriticalSection(S.ADR(moduleCS));
	Kernel32.ExitProcess(err)
END Exit;

	(* -------------------------- memory allocation ----------------------- *)

PROCEDURE - HALT1
	0B8H, 01H, 0H, 0H, 0H,	(* mov eax,1 *)
	0CCH;	(* breakpoint *)

PROCEDURE AllocSuperBlock(VAR adr: Kernel32.ADDRESS; size: LONGINT);
VAR block, p, p0: SuperBlockPtr; rest: FreeBlockPtr; s, alloc: LONGINT;
BEGIN
	IF size <= SuperBlockSize THEN alloc := SuperBlockSize
	ELSE alloc := size + (-size MOD B)
	END;
	INC(alloc, 16 + B);
	adr := Kernel32.VirtualAlloc(0, alloc, Kernel32.MEMCommit, Kernel32.PageReadWrite);
	IF adr = Kernel32.NULL THEN
		IF reserve # Kernel32.NULL THEN 
			Kernel32.VirtualFree(reserve, ReserveBlockSize + 16 + B, Kernel32.MEMDecommit);
			Kernel32.VirtualFree(reserve, 0, Kernel32.MEMRelease); reserve := Kernel32.NULL
		ELSE
			alloc := ReserveBlockSize + 16 + B;
			adr := Kernel32.VirtualAlloc(0, alloc, Kernel32.MEMCommit, Kernel32.PageReadWrite)
		END
	END;
	IF adr # 0 THEN
		ASSERT(adr MOD 4 = 0, 32);
		block := S.VAL(SuperBlockPtr, adr);
		block^.next := 0;
		block^.size := alloc;
		block^.firstblock := adr + 16;
		block^.firstblock := block^.firstblock + (-block^.firstblock-4) MOD B;
		ASSERT((block^.firstblock + 4) MOD B = 0, 33);
		s := adr + alloc - block^.firstblock; s := s - s MOD B;
		block^.endblock := block^.firstblock + s;
		ASSERT((s MOD B = 0) & (s >= size) & (superblocks # 0), 34);
		p0 := NIL;
		p := S.VAL(SuperBlockPtr, superblocks);
		WHILE (p # NIL) & (p^.firstblock < block^.firstblock) DO p0 := p; p := S.VAL(SuperBlockPtr, p.next) END;
		IF p0 = NIL THEN (* first block *)
			block.next := S.VAL(LONGINT, p); superblocks := S.VAL(LONGINT, block);
			supermin := block^.firstblock
		ELSE
			block.next := S.VAL(LONGINT, p); p0.next := S.VAL(LONGINT, block);
			IF block.next = 0 THEN (* last block *)
				supermax := block^.endblock
			END
		END;
		ASSERT(supermin < supermax, 35);
		rest := S.VAL(FreeBlockPtr, block^.firstblock);
		rest^.tag := S.VAL(Tag, S.VAL(SET, S.ADR(rest^.size))+free);
		rest^.size := block^.endblock - block^.firstblock - 4;
		(* hang into existing free lists *)
		rest^.next := A[N];
		A[N] := S.VAL(LONGINT, rest);
		adr := A[N]
	ELSE adr := 0
		(* out of memory *)
	END
END AllocSuperBlock;

PROCEDURE NewBlock (size: LONGINT): InitPtr;	(* size MOD B = 0 *)
	VAR i, rest: LONGINT; adr, AN: Kernel32.ADDRESS; ptr: InitPtr; restptr: FreeBlockPtr;
BEGIN
	IF size < 0 (* NEW(p, MAX(LONGINT)) *) THEN HALT1 END;
	Kernel32.EnterCriticalSection(S.ADR(moduleCS));
	i := size DIV B;
	IF i > N THEN i := N END;
	adr := S.ADR(A[0]) + 4*i;
	AN := S.ADR(A[N]);	(* constant register *)
	LOOP
		S.GET(adr, ptr);
		IF adr = AN THEN
			LOOP
				IF ptr = NIL THEN
					IF firstTry THEN 
						GC;
						firstTry := FALSE; ptr := NewBlock(size); firstTry := TRUE;
						Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN ptr
					ELSE (* reserve := NIL; GC; firstTry := TRUE; (* HALT1; *) RETURN NIL *)
						firstTry := TRUE;
						AllocSuperBlock(adr, size);
						IF adr = Kernel32.NULL THEN HALT1
						ELSE ptr := NewBlock(size); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN ptr
						END
					END
				END;
				IF ptr^.z0 + 4 >= size THEN EXIT END;
				adr := S.ADR(ptr^.z1); S.GET(adr, ptr)
			END;
			EXIT
		END;
		IF ptr # NIL THEN EXIT END;
		INC(adr, 4)
	END;
	(* ptr # NIL *)
	S.PUT(adr, ptr^.z1);
	rest := ptr^.z0 + 4 - size;
	restptr := S.VAL(FreeBlockPtr, S.VAL(Kernel32.ADDRESS, ptr) + size);
	IF rest > 0 THEN	(* >= B >= 16 *)
		i := rest DIV B;
		IF i > N THEN i := N END;
		restptr^.tag := S.VAL(Tag, S.VAL(SET, S.ADR(restptr^.size))+free);
		restptr^.size := rest - 4;
		restptr^.next := A[i]; A[i] := S.VAL(Kernel32.ADDRESS, restptr)
	END;
	Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
	RETURN ptr
END NewBlock;

(** Private compiler interface. Do not use. *)
PROCEDURE NewRec* (tag: Tag; VAR p: Kernel32.ADDRESS);	(* implementation of NEW(ptr) *)
	VAR size: LONGINT; ptr, init: InitPtr;
BEGIN (* tag^.size = rectyp^.size *)
	size := S.VAL(LONGINT, S.VAL(SET, tag^.size + (4 (*tag*) + B-1))-S.VAL(SET, B-1));
	ptr := NewBlock(size);
	IF ptr = NIL THEN p := Kernel32.NULL; RETURN END;
	init := S.VAL(InitPtr, S.VAL(Kernel32.ADDRESS, ptr) + size - 32);
	init^.z0 := 0; init^.z1 := 0; init^.z2 := 0; init^.z3 := 0; init^.z4 := 0; init^.z5 := 0; init^.z6 := 0;
	WHILE init # ptr DO
		DEC(S.VAL(Kernel32.ADDRESS, init), 32);
		init^.z0 := 0; init^.z1 := 0; init^.z2 := 0; init^.z3 := 0; init^.z4 := 0; init^.z5 := 0; init^.z6 := 0; init^.z7 := 0
	END;
	ptr^.tag := tag;
	p := S.VAL(Kernel32.ADDRESS, ptr) + 4
END NewRec;

(** Private compiler interface. Do not use. *)
PROCEDURE NewSys* (size: LONGINT; VAR p: Kernel32.ADDRESS);	(* implementation of S.NEW(ptr, size) *)
	VAR ptr, init: InitPtr;
BEGIN
	size := S.VAL(LONGINT, S.VAL(SET, size + (28 + B-1))-S.VAL(SET, B-1));
	ptr := NewBlock(size);
	IF ptr = NIL THEN p := 0; RETURN END;
	init := S.VAL(InitPtr, S.VAL(Kernel32.ADDRESS, ptr) + size - 32);
	WHILE init # ptr DO
		init^.tag := NIL; init^.z0 := 0; init^.z1 := 0; init^.z2 := 0; init^.z3 := 0; init^.z4 := 0; init^.z5 := 0; init^.z6 := 0;
		DEC(S.VAL(Kernel32.ADDRESS, init), 32);
	END;
	ptr^.tag := S.VAL(Tag, S.ADR(ptr^.z0));
	ptr^.z0 := size - 4;
	ptr^.z1 := -4;
	init^.z2 := 0; init^.z3 := 0; init^.z4 := 0;
	ptr^.z5 := S.ADR(ptr^.z0);
	init^.z6 := 0;
	p := S.VAL(Kernel32.ADDRESS, ptr) + 28
END NewSys;

(** Private compiler interface. Do not use. *)
PROCEDURE NewArr* (nofdim, nofelem: LONGINT; eltag: Tag; VAR p: Kernel32.ADDRESS);
	(* implementation of NEW(ptr, dim0, dim1, ...) *)
	VAR size, firstElem, elSize, arrSize, vectSize: LONGINT; ptr, init: InitPtr;
BEGIN
	IF eltag = NIL THEN (* ARRAY OF POINTER *) eltag := S.VAL(Tag, PointerTD) END;
	elSize := eltag^.size;
	arrSize := nofelem*elSize;
	vectSize := 8*(nofdim DIV 2) + 4;	(* -> ADR(firstElem) MOD 8 = 0 *)
	IF eltag^.ptroff = -4 THEN (* no pointers in element type *)
		NewSys(arrSize + vectSize + 12, p); RETURN
	END;
	size := S.VAL(LONGINT, S.VAL(SET, arrSize + vectSize + (16 + B-1))-S.VAL(SET, B-1));
	ptr := NewBlock(size);
	IF ptr = NIL THEN p := Kernel32.NULL; RETURN END;
	init := S.VAL(InitPtr, S.VAL(Kernel32.ADDRESS, ptr) + size - 32);
	WHILE init # ptr DO
		init^.tag := NIL; init^.z0 := 0; init^.z1 := 0; init^.z2 := 0; init^.z3 := 0; init^.z4 := 0; init^.z5 := 0; init^.z6 := 0;
		DEC(S.VAL(Kernel32.ADDRESS, init), 32);
	END;
	ptr^.tag := S.VAL(Tag, S.VAL(SET, eltag) + array);
	firstElem := S.ADR(ptr^.z3) + vectSize;
	ptr^.z0 := firstElem + arrSize - elSize;
	(* ptr^.z1 is reserved for mark phase *)
	ptr^.z2 := firstElem;
	ptr^.z3 := 0; ptr^.z4 := 0; ptr^.z5 := 0; ptr^.z6 := 0;
	p := S.VAL(Kernel32.ADDRESS, ptr) + 4
END NewArr;

	(* --------------------------------------------------------------------- *)

(** Used - Return the size in bytes of the amount of memory currently in use in the heap. *) 
PROCEDURE Used*(): LONGINT;
	VAR heap, code, data: LONGINT; thisSuper: SuperBlockPtr;
BEGIN
	Kernel32.EnterCriticalSection(S.ADR(moduleCS));
	getCodeSize(code, data);
	heap := code + data;
	thisSuper := S.VAL(SuperBlockPtr, superblocks);
	WHILE thisSuper # NIL DO
		heap := heap + thisSuper.size;
		thisSuper := S.VAL(SuperBlockPtr, thisSuper^.next);
	END;
	IF reserve # 0 THEN heap := heap + ReserveBlockSize END;
	heap := heap-Available();
	Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
	RETURN heap
END Used;

PROCEDURE *enableGC();
BEGIN
	INC(GCenabled)
END enableGC;

PROCEDURE *disableGC();
BEGIN
	DEC(GCenabled)
END disableGC;

PROCEDURE InitKernel;	(* heapAdr, heapSize, firstBlock and modules already initialized *)
	VAR size, i: LONGINT; p: Blockm4Ptr; rest: FreeBlockPtr; tag, tdesc: Tag; m: Module;
		td: POINTER TO RECORD filler: ARRAY 4 OF LONGINT; name: Name END;
BEGIN
	Kernel32.InitCriticalSection(S.ADR(moduleCS));
	Kernel32.EnterCriticalSection(S.ADR(moduleCS));
	FinObjs := NIL;
	size := heapAdr + heapSize - firstBlock;
	DEC(size, size MOD B);
	endBlock := firstBlock + size;

	m := S.VAL(Module, modules);
	WHILE m.name # "Kernel" DO m := m.link END;
	(* initialise ptrElemTag *)
	i := LEN(m.tdescs^);
	REPEAT DEC(i);
		PointerTD := m.tdescs[i];
		S.GET(PointerTD - 4, td)
	UNTIL td.name = "PtrElemDesc";

	i := LEN(m.tdescs^);
	REPEAT DEC(i);
		queueTD := m.tdescs[i];
		S.GET(queueTD - 4, td)
	UNTIL td.name = "QElem";

	i := LEN(m.tdescs^);
	REPEAT DEC(i);
		finObjTD := m.tdescs[i];
		S.GET(finObjTD - 4, td)
	UNTIL td.name = "FinObjNode";

	p := S.VAL(Blockm4Ptr, firstBlock);
	WHILE p^.tag # NIL DO
		tag := p^.tag;
		tdesc := S.VAL(Tag, S.VAL(SET, tag) - array - mark);
		IF array * S.VAL(SET, tag) # {} THEN (* array block *) size := p^.lastElemToMark + tdesc^.size - S.VAL(Kernel32.ADDRESS, p)
		ELSE size := tdesc^.size + 4
		END;
		size := S.VAL(LONGINT, S.VAL(SET, size + B-1)-S.VAL(SET, B-1));
		INC(S.VAL(Kernel32.ADDRESS, p), size)
	END;
	rest := S.VAL(FreeBlockPtr, p);
	rest^.tag := S.VAL(Tag, S.VAL(SET, S.ADR(rest^.size))+free);
	rest^.size := S.VAL(LONGINT, endBlock) - S.VAL(LONGINT, rest) - 4;
	rest^.next := 0;
	i := 0;
	firstTry := TRUE;
	i := 0;
	WHILE i < N DO A[i] := nil; INC(i) END;
	A[N] := S.VAL(LONGINT, rest);
	INC(GCenabled); EnableGC := enableGC; DisableGC := disableGC;
	oberonsuperblock.next := 0;
	oberonsuperblock.size := heapSize;
	oberonsuperblock.firstblock := firstBlock;
	oberonsuperblock.endblock := endBlock;
	superblocks := S.ADR(oberonsuperblock);
	supermin :=  firstBlock;
	supermax := endBlock;
	reserve := Kernel32.VirtualAlloc(0, ReserveBlockSize + 16 + B, Kernel32.MEMCommit, Kernel32.PageReadWrite);
	InitQ(mkQ); InitQ(quitQ);
	Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
END InitKernel;

BEGIN
	hInstance := Kernel32.GetModuleHandle(Kernel32.NULL); version := "Win32 2.3 (12.5.1999)";
	(* rely on initialisation of initialised and EventLoop to FALSE and NIL, resp. *)
	BeginAtomic := DummyF; EndAtomic := Dummy;
	CheckStacks := NIL;
	S.GETREG(S.ESP, stackBottom);
	firstBlock := heapAdr;
	GCenabled := 0; InitKernel()
END Kernel.

(** Remarks:

1. The NEW built-in of the Oberon language is mapped to the NewX procedures of the kernel, where X is Rec, Sys, or Arr. These procedures should never be called directly.

2. The NEW built-in of the Oberon language will return a pointer initialized to NIL when not enough memory can be found to fulfil the request. Note that this version of the Kernel does not initiate an "out of memory" trap (in contrast to other kernels that do).

3. Finalization allows an object to obtain control before it is removed from the heap by the garbage collector. First declare a finalization procedure:

	PROCEDURE Finalize (f: PTR);
	BEGIN
		WITH f: ObjType DO
			...
		END
	END Finalize;

then register a specific object (any pointer based record type) for finalization with:

	Kernel.RegisterObject(obj, Finalize);

At finalization object can prevent being collected by anchoring it again somewhere in a used data-structure or a global pointer variable. Finalization increases the garbage collector time and should thus be used sparingly.

*)