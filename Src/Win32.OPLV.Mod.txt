(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE OPLV; (** non-portable / source: Win32.OPLV.Mod *)	(* tk 6.7.96 *)
(* 
	6.7.96	Method support 

	code generator for Intel i386, i387 / i485 / i586 - Diplomarbeit ETH Zürich WS 95/96
	by Erwin Brandenberger, 90-903-378
	author's address:
		Thalerstrasse 116
		9400 Rorschacherberg, Switzerland
		phone: +41 (0)71 855 26 04

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*)

	IMPORT
		S := SYSTEM, Kernel32, Files, Modules, PLT := OPLT, PLO := OPLO, PLL := OPLL, PLC := OPLC;
	
	CONST

		Var = 1; Par = 2; VarPar = 3; Con = 4; Fld = 5; LProc = 6; XProc = 7; TProc = 14;
		TypPointer = 10; TypRecord = 11;
		Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6; Real = 7; LReal = 8; Set = 9;
		String = 10; NilTyp = 11; Pointer = 13; Comp = 15; Array = 2; DynArr = 3; Record = 4;

		Tend = 00H; Telsif=01H; Telse=02H; Twend=03H; Tcastrap=04H; Tcaslbl1=05H; Tcasrng1=06H; Tcaslbl2=07H; Tcasrng2=08H;
		Tbegin = 09H; TconstNil = 00H; TconstFalse = 01H; TconstTrue = 02H;
		TconstChar = 03H; TconstSInt = 04H; TconstInt = 05H; TconstLInt = 06H;
		TconstSet = 07H; TconstReal = 08H; TconstLReal = 09H; TconstString = 0AH;
		Tderef = 0BH; Tindex = 0CH; TmopNot = 0DH; TmopMinus = 0EH;
		TmopAbs = 0FH; TmopCap = 10H; TmopOdd = 11H;
		TdopAnd = 12H; TdopOr = 13H; TdopTimes = 14H; TdopSlash = 15H;
		TdopDiv = 16H; TdopMod = 17H; TdopPlus = 18H; TdopMinus = 19H;
		TdopMsk = 1AH; TdopAsh = 1BH; TdopLen = 1CH; TdopIn = 1DH;
		TdopEql = 1EH; TdopNeq = 1FH; TdopLss = 20H; TdopLeq = 21H;
		TdopGtr = 22H; TdopGeq = 23H; Tupto = 24H;
		Tcall = 25H; TasgnNewfn = 26H; TasgnAssign = 27H; TasgnIncfn = 28H;
		TasgnDecfn = 29H; TasgnInclfn = 2AH; TasgnExclfn = 2BH;
		TasgnCopyfn = 2CH; Tassert = 2DH; Tif = 2EH; Tcase = 2FH; Twhile = 30H; Trepeat = 31H; 
		Tloop = 32H; Texit = 33H; Twith=34H; Ttrap = 35H;

		UvarGlobal = 40H; UvarDirect = 41H; UvarIndirect = 42H;
		UvarparIndirect = 43H; Uproc = 44H; Ufield = 45H;
		Uguard = 46H; Ueguard = 47H; UmopIs = 48H; UmopConv = 49H; UmopConvSet = 4AH;
		Uenter = 4BH; Ureturn0 = 4CH; Ureturn1 = 4DH;
		UcallXPrc = 4EH; UcallXFnc = UcallXPrc+1; UcallXRFnc = UcallXPrc+2;
		UcallLPrc = 51H; UcallLFnc = UcallLPrc+1; UcallLRFnc = UcallLPrc+2;
		UcallPrcV = 54H; UcallFncV = UcallPrcV+1; UcallRFncV = UcallPrcV+2;
		UasgnAssignBool = 57H; UasgnAssignOther = 58H;

		flgOK = 0; flgNoLeft = -1; flgNoRight = -2; flgEnter = -3;

		Local = FALSE; Global = TRUE; Internal = FALSE; External = TRUE;
	
		internal = 0;
		MethodOffs = -72;
	
		EUEnd = 0; EURecord = 1; EUobjScope = 0; EUrecScope = 1; EUerrScope = -1;
	
	VAR
		assert, refs: BOOLEAN;
		dsp: INTEGER;
		body*: LONGINT;
		N, above, below, TAG: LONGINT;
		constNodeOT: ARRAY NilTyp+1 OF SHORTINT;
		relT: ARRAY TdopGeq+1 OF SHORTINT;
		bstk: ARRAY 64 OF LONGINT;
		contyp: ARRAY TconstSet+1 OF PLT.Struct;
		block: POINTER TO ARRAY OF PLL.Node;
		nilNode, falseNode, trueNode: PLL.Node;
		R: Files.Rider;
		M: Modules.Module;
		ExitChain: PLC.Label;
		threadAbortNotify: Kernel32.ThreadStartRoutine;
		threadID: LONGINT;

(*Dictionary*)
	
	PROCEDURE PushDict;
	BEGIN bstk[dsp] := below; INC(dsp)
	END PushDict;
	
	PROCEDURE PopDict;
	BEGIN DEC(dsp); below := bstk[dsp]
	END PopDict;

(* Node Creation *)

	PROCEDURE NNode(VAR p: PLL.Node; tag: LONGINT; typ: PLT.Struct; obj: PLT.Object; left, right: PLL.Node; global: BOOLEAN);
		VAR n: PLL.Node;
	BEGIN
		IF global THEN NEW(n); block[N+above] := n; INC(above)
		ELSE NEW(n); block[N+below] := n; DEC(below) END;
		n.tag := tag; n.flag := 0; n.subflg := 0; n.typ := typ; n.obj := obj; n.left := left; n.right := right; n.safe := FALSE; n.global := global; p := n
	END NNode;
		
	PROCEDURE UNodeO(tag: LONGINT; flag: SHORTINT; typ: PLT.Struct; obj: PLT.Object; global: BOOLEAN);
	VAR n: PLL.Node;
	BEGIN
		IF global THEN NEW(n); block[N+above] := n; INC(above)
		ELSE NEW(n); block[N+below] := n; DEC(below) END;
		n.tag := tag; n.flag := flag; n.subflg := 0; n.typ := typ; n.obj := obj; n.safe := FALSE; n.global := global
	END UNodeO;

	PROCEDURE UNodeLR(tag: LONGINT; flag: SHORTINT; typ: PLT.Struct; left, right: PLL.Node; global: BOOLEAN);
	VAR n: PLL.Node;
	BEGIN
		IF global THEN NEW(n); block[N+above] := n; INC(above)
		ELSE NEW(n); block[N+below] := n; DEC(below) END;
		n.tag := tag; n.flag := flag; n.subflg := 0; n.typ := typ; n.left := left; n.right := right; n.safe := FALSE; n.global := global
	END UNodeLR;
	
	PROCEDURE PNode(VAR p: PLL.Node; remain, match: SHORTINT; par: PLL.Node; global: BOOLEAN);
	VAR n: PLL.Node;	(*p.typ=result type, p.obj=formal parameter*)
	BEGIN
		IF global THEN NEW(n); block[N+above] := n; INC(above)
		ELSE NEW(n); block[N+below] := n; DEC(below) END;
		n.tag := p.tag; n.flag := remain; n.subflg := match; n.typ := p.typ; n.left := p; n.right := par; n.safe := FALSE; n.global := global;
		IF match = 1 THEN n.obj := p.obj.par ELSE n.obj := p.obj.nxtobj END;
		p := n
	END PNode;

	PROCEDURE CallNode(VAR n: PLL.Node; tag: LONGINT; nofpar: INTEGER; typ: PLT.Struct; obj: PLT.Object; left: PLL.Node; global: BOOLEAN);
	BEGIN
		IF typ = PLT.notyp THEN NNode(n, tag, NIL, obj, left, NIL, global)
		ELSIF typ.form IN {Real, LReal} THEN NNode(n, tag+2, typ, obj, left, NIL, global)
		ELSE NNode(n, tag+1, typ, obj, left, NIL, global) END;
		n.flag := SHORT(nofpar)
	END CallNode;

	PROCEDURE VarNodes(n: PLL.Node; typ: PLT.Struct; global: BOOLEAN);
	BEGIN
		IF typ = PLT.booltyp THEN
			UNodeLR(UasgnAssignBool, flgNoLeft, NIL, NIL, n, global);
			UNodeLR(UasgnAssignBool, flgNoRight, NIL, n, NIL, global)
		ELSE
			UNodeLR(UasgnAssignOther, flgNoLeft, NIL, NIL, n, global);
			UNodeLR(UasgnAssignOther, flgNoRight, NIL, n, NIL, global)
		END;
		IF typ.form = Pointer THEN
			NNode(n, Tderef, typ.BaseTyp, NIL, n, NIL, global)
		ELSIF (typ.comp = Array) OR (typ.comp = DynArr) THEN
			UNodeLR(Tindex, flgNoRight, typ.BaseTyp, n, NIL, global)
		END
	END VarNodes;
	
	PROCEDURE GenNode(obj: PLT.Object; typ: PLT.Struct; mode: INTEGER; external, global: BOOLEAN);
		VAR n: PLL.Node; fld: PLT.Object;
	BEGIN
		CASE mode OF
		|	Var:
				IF obj.level = 0 THEN NNode(n, UvarGlobal, typ, obj, NIL, NIL, global)
				ELSE NNode(n, UvarDirect, typ, obj, NIL, NIL, global)
				END;
				IF ~external THEN VarNodes(n, typ, global) END
		|	Par:
				IF (typ.comp = DynArr) OR ((typ.size > 4) & (typ.form # LReal)) THEN NNode(n, UvarIndirect, typ, obj, NIL, NIL, global)
				ELSE NNode(n, UvarDirect, typ, obj, NIL, NIL, global)
				END;
				IF ~external THEN VarNodes(n, typ, global) END
		|	VarPar:
				NNode(n, UvarparIndirect, typ, obj, NIL, NIL, global);
				IF ~external THEN VarNodes(n, typ, global) END
		|	TypPointer:
				UNodeO(Uguard, flgNoLeft, typ, NIL, global);
				UNodeO(Ueguard, flgNoLeft, typ, NIL, global);
				UNodeO(UmopIs, flgNoLeft, PLT.booltyp, obj, global)
		|	TypRecord:
				UNodeO(Uguard, flgNoLeft, typ, NIL, global);
				UNodeO(Ueguard, flgNoLeft, typ, NIL, global);
				UNodeO(UmopIs, flgNoLeft, PLT.booltyp, obj, global);
				fld:=typ.dsc;	WHILE	fld#NIL	DO	(* mfix *)
					IF fld.mode = Fld THEN
						UNodeO(Ufield, flgNoLeft, fld.typ, fld, global)	
					ELSE
						NNode(n, Uproc, fld.typ, fld, NIL, NIL, global);
						IF external THEN 
							CallNode(n, UcallXPrc, fld.nofpar, fld.typ, fld, NIL, global);
							CallNode(n, UcallXPrc, fld.nofpar, fld.typ, fld, NIL, global); n.safe := TRUE;
						ELSE 
							CallNode(n, UcallLPrc, fld.nofpar, fld.typ, fld, NIL, global); 
							CallNode(n, UcallLPrc, fld.nofpar, fld.typ, fld, NIL, global); n.safe := TRUE;
							UNodeO(Uenter, flgEnter, fld.typ, fld, global)
						END;
					END;
					fld:=fld.nxtobj
				END
		|	LProc, XProc:
				NNode(n, Uproc, typ, obj, NIL, NIL, global);
				IF external THEN CallNode(n, UcallXPrc, obj.nofpar, typ, obj, NIL, global)
				ELSE
					CallNode(n, UcallLPrc, obj.nofpar, typ, obj, NIL, global);
					UNodeO(Uenter, flgEnter, typ, obj, global)
				END
		|	Con:
				IF typ.form # Bool THEN NNode(n, constNodeOT[typ.form], typ, obj, NIL, NIL, Global) END
		ELSE
		END
	END GenNode;

	PROCEDURE GenNodes(obj: PLT.Object; external, global: BOOLEAN);
	BEGIN
		WHILE obj # NIL DO GenNode(obj, obj.typ, obj.mode, external, global); obj := obj.nxtobj END;
	END GenNodes;

(* Code generation *)

	PROCEDURE ^ Statement;
	PROCEDURE ^ Compile(n: PLL.Node; VAR x: PLC.Item);

	PROCEDURE Call(n: PLL.Node; VAR x: PLC.Item);
		VAR tag: LONGINT; proc: PLL.Node; left, right, rcv: PLL.Node; 
	BEGIN
		tag := n.tag; left := n.left; right := n.right;
		IF n.flag = 0 THEN PLC.PushRegs END;
		IF n.subflg # 0 THEN Compile(right, x); PLC.Parameter(x, n.obj, left.tag = Tderef); Call(left, x) END;
		IF n.flag = 0 THEN proc := n; 
			rcv := NIL; WHILE proc.subflg > 0 DO rcv := proc; proc := proc.left END;
			x.mnolev := proc.obj.level; x.adr := proc.obj.linkadr; x.typ := proc.obj.typ; x.mode := proc.obj.mode;
			IF x.mode = TProc THEN x.offs := MethodOffs - 4*(proc.obj.adr DIV 10000H) END;
			NEW(n); n.left := proc; n.obj := proc.obj; n.right := rcv;
			IF (tag = UcallPrcV) OR (tag = UcallFncV) OR (tag = UcallRFncV) THEN Compile(proc.left, x); 
				PLC.Call(x, NIL, n)
			ELSE PLC.Call(x, proc.obj, n)
			END;
			IF (tag=UcallXPrc) OR (tag=UcallLPrc) OR (tag=UcallPrcV) THEN PLC.PopResult(NIL, x)
			ELSE PLC.PopResult(proc, x)
			END
		END
	END Call;

	PROCEDURE Dim (VAR z, nofelem: PLC.Item; n: PLL.Node; typ: PLT.Struct; nofdim: LONGINT);
		VAR
			nofArrElems: LONGINT;
			len, cons: PLC.Item;
			btyp: PLT.Struct;
	BEGIN
		Compile(n.left, len);
		PLC.PushLen(len);
		IF len.mode # Con THEN PLC.GenDimTrap (len) END;
		IF nofdim = 1 THEN 
			nofelem := len; nofelem.typ := PLT.linttyp
		ELSE PLC.MulDim (nofelem, len)
		END;
		IF n.right # NIL THEN Dim(z, nofelem, n.right, typ.BaseTyp, nofdim + 1)
		ELSE
			btyp := typ.BaseTyp; nofArrElems := 1 (*0*) ;	(* <<< mh 30.3.1994 *)
			WHILE btyp.comp = Array DO
				nofArrElems := nofArrElems * btyp.n;
				btyp := btyp.BaseTyp
			END;
			IF nofArrElems # 1 (*0*) THEN	(* <<< mh 30.3.1994 *)
				cons.mode := Con; cons.typ := PLT.linttyp; cons.adr := nofArrElems; cons.node := NIL;
				PLC.MulDim (nofelem, cons)
			END;
			PLC.NewArray (z, nofelem, nofdim, btyp, TRUE);
			INC (z.offs, 4) (* z -> first len element *)
		END;
		PLC.PopLen (z); (* fill in each dimension size *)
		INC (z.offs, 4)
	END Dim;

	PROCEDURE Compile(n: PLL.Node; VAR x: PLC.Item);
	VAR
		tag: LONGINT; 
		y, z: PLC.Item;
		left, right: PLL.Node;
		obj, obj0: PLT.Object;
	BEGIN
		tag := n.tag; left := n.left; right := n.right; obj := n.obj;
		CASE tag OF	(* for expressions, the type of Node parameter is guaranteed to be the correct result *)
		| TconstNil..TconstSet:	x.mode:=Con; x.typ := n.typ; x.adr := obj.ival
		| TconstReal:	PLL.AllocConst(obj.intval2, 4, 4, obj.ival);
			x.mode := PLO.Abs; x.adr := obj.ival; x.inx := PLL.none;
		| TconstLReal:	PLL.AllocConst(obj.rval, 8, 4, obj.ival);
			x.mode := PLO.Abs; x.adr := obj.ival; x.inx := PLL.none;
		| TconstString:	
			IF obj.level # 0 THEN NEW(obj0); obj0^:=obj^; n.obj:=obj0; obj:=obj0 END;	(* reallocate string *)
			IF obj.adr = 0 THEN PLL.AllocConst(obj.xval^, obj.intval2, 4, obj.ival) END;
			x.mode := PLO.Abs; x.adr := obj.ival; x.offs := obj.intval2; x.inx := PLL.none
		| UvarGlobal, UvarDirect, UvarIndirect, UvarparIndirect:
			x.node := n; x.mnolev := obj.level; x.scale := PLO.noScale; x.inx := PLL.none;
			IF obj.level <= 0 THEN x.mode := PLO.Abs ELSE x.mode := obj.mode END;
			x.adr := obj.linkadr; x.offs := 0;
			IF (obj.typ.comp IN {DynArr, Array}) & (x.mode IN {Var, Par, VarPar}) THEN
				x.descReg := PLL.RiscFP; x.descOffs := x.adr
			END
		| Ufield:	Compile(left, x); PLC.Field(x, n.obj.adr)
		| Tderef:	Compile(left, x); PLC.DeRef(x);
			IF n.typ.comp = DynArr THEN x.descReg := x.adr; x.descOffs := PLC.PtrToArrOffs; 
				(* x.offs := PLC.PtrToArrOffs + 4 + (n.typ.n + 1) * 4 *)
				x.offs := PLC.PtrToArrOffs + 8 + 8*((n.typ.n+1) DIV 2)	(* dVdW *)
			END
		| Tindex:	Compile(right, y); Compile(left, x); PLC.Index(x, y)
		| Uguard:	Compile(left, x); PLC.TypeTest(x, n.typ, TRUE, FALSE, (left.tag = UvarparIndirect) & (left.typ.comp = Record));
		| Ueguard:	Compile(left, x); PLC.TypeTest(x, n.typ, TRUE, TRUE, (left.tag = UvarparIndirect) & (left.typ.comp = Record));
		| Uproc:	x.typ := n.typ; x.mode := obj.mode; x.node := n; x.mnolev := obj.level; x.inx := PLL.none; 
			IF x.mode = TProc THEN x.offs := MethodOffs - 4*(obj.adr DIV 10000H) END;
		| UmopIs:	Compile(left, x); 
			IF n.obj.typ.form = Pointer THEN PLC.TypeTest(x, n.obj.typ, FALSE, FALSE, FALSE)
			ELSE PLC.TypeTest(x, n.obj.typ, FALSE, FALSE, TRUE) END
		| UmopConv:	Compile(left, x); PLC.Convert(x, n.typ.form)
		| UmopConvSet:	Compile(left, y); PLC.SetElem(x, y);
		| TmopNot:	Compile(left, y); PLC.Not(x, y)
		| TmopMinus:	Compile(left, y); PLC.Neg(x, y)
		| TmopAbs:	Compile(left, y); PLC.AbsVal(x, y)
		| TmopCap:	Compile(left, y); PLC.Cap(x, y)
		| TmopOdd:	Compile(left, y); PLC.Odd(x, y)
		| TdopTimes:	Compile(left, x); Compile(right, y); PLC.Mul(z, x, y, x.typ.form); x := z
		| TdopSlash, TdopDiv:	Compile(left, x); Compile(right, y); PLC.Div(z, x, y, x.typ.form); x := z
		| TdopPlus:	Compile(left, x); Compile(right, y); PLC.Add(z, x, y, x.typ.form); x := z
		| TdopMinus:	Compile(left, x); Compile(right, y); PLC.Sub(z, x, y, x.typ.form); x := z
		| TdopMod:	Compile(left, x); Compile(right, y); PLC.Mod(z, x, y); x := z
		| TdopAnd:	Compile(left, x); PLC.CondAnd(x); Compile(right, y); PLC.And(z, x, y); x := z
		| TdopOr:	Compile(left, x); PLC.CondOr(x); Compile(right, y); PLC.Or(z, x, y); x := z
		| TdopEql..TdopGeq:	Compile(left, x); PLC.Relation(x); Compile(right, y); PLC.Cmp(z, x, y, relT[tag]); x := z
		| TdopIn:	Compile(left, x); Compile(right, y); PLC.In(z, x, y); x := z
		| TdopAsh:	Compile(left, x); Compile(right, y); PLC.Ash(z, x, y); x := z
		| TdopMsk:	Compile(left, x); Compile(right, y); PLC.Msk(z, x, y); x := z
		| TdopLen:	Compile(left, x); Compile(right, y); PLC.Len(z, x, y); x := z
		| Tupto:	Compile(left, x); Compile(right, y); PLC.SetRange(z, x, y); x := z
		| TasgnNewfn:	Compile(left, x);
			IF right # NIL THEN Dim(x, z, right, x.typ.BaseTyp, 1); z := x;
			ELSE PLC.NewRec(x, x.typ.BaseTyp) END
		| UasgnAssignOther, UasgnAssignBool:
			Compile(right, y); PLC.Relation(y); Compile(left, x); PLC.Assign(x, y)
			(*Compile(left, x); Compile(right, y); PLC.Assign(x, y)*)
		| TasgnIncfn, TasgnDecfn:	Compile(left, x); Compile(right, y); PLC.IncDec(x, y, tag=TasgnIncfn)
		| TasgnInclfn, TasgnExclfn:	Compile(left, x); Compile(right, y); PLC.Include(x, y, tag=TasgnInclfn)
		| TasgnCopyfn:	Compile(left, x); Compile(right, y); PLC.Copy(x, y)
		| Uenter:	(* do nothing *) 
		| UcallXPrc, UcallLPrc, UcallPrcV:	Call(n, x);
		| UcallXFnc, UcallLFnc, UcallFncV, UcallXRFnc, UcallLRFnc, UcallRFncV:	Call(n, x)
		| Ureturn0:	PLC.Exit(obj);
		| Ureturn1:	Compile(left, x); PLC.Return(x, n.obj.typ.form); PLC.Exit(obj);
		ELSE
			HALT(96)
		END;
		x.typ := n.typ
	END Compile;

	PROCEDURE Enter(n: PLL.Node); (* ejz *)
		VAR name: ARRAY 64 OF CHAR; proc, locals: PLT.Object; dum: PLL.Node; typ: PLT.Struct;
	BEGIN
		proc := n.obj; typ := proc.typ;
		PushDict; INC(PLC.level);
		IF typ = PLT.notyp THEN NNode(dum, Ureturn0, NIL, proc, NIL, NIL, Local)
		ELSE UNodeO(Ureturn1, flgNoLeft, typ, proc, Local) END;
		locals := proc.par; PLT.ReadScope(R, M, PLC.level, locals, Local);
		IF refs THEN proc.locals := locals ELSE proc.locals := proc.par END;
		PLL.Traverse(locals); PLL.VarAdr(locals, proc.intval2);
		GenNodes(locals, Internal, Local);
		Files.ReadNum(R, TAG);
		WHILE TAG # Tbegin DO Statement END;  (*nested*)
		PLC.pc := 0; PLC.RiscCodeErr := FALSE;
		PLC.Enter(proc, proc.intval2, n);
		Files.ReadNum(R, TAG);
		WHILE TAG # Tend DO Statement END; (*body*)
		IF proc.typ # PLT.notyp THEN PLC.Trap(PLL.FuncTrap, n) ELSE PLC.Exit(proc) END;
		PLL.OutRefPoint(proc, PLC.level-1);
		COPY(proc.name, name);
		PLL.OutRefName(name); PLL.OutRefs(proc.locals);
		IF ~PLC.RiscCodeErr THEN PLL.GenCode(PLC.pc) END;
		proc.lim := PLO.pc + PLO.codeBase;
		DEC(PLC.level);
		PopDict;
	END Enter;

	PROCEDURE RString(VAR r: Files.Rider; VAR string: ARRAY OF CHAR; VAR len: LONGINT);
		VAR i: INTEGER;
	BEGIN	PLT.ReadString(r, string); i := 0; WHILE string[i] # 0X DO INC(i) END; len := i+1
	END RString;

	PROCEDURE Input(VAR n: PLL.Node);
		VAR match, remain: SHORTINT; h: PLL.Node;
			tag: LONGINT; sr: REAL;
			obj, sent: PLT.Object; restyp: PLT.Struct; left, right, par: PLL.Node;
	BEGIN tag := TAG;
		CASE tag OF
		| TconstNil:	n := nilNode; Files.ReadNum(R, TAG)
		| TconstFalse:	n := falseNode; Files.ReadNum(R, TAG)
		| TconstTrue:	n := trueNode; Files.ReadNum(R, TAG)
		| TconstChar..TconstLInt:
				NEW(obj); Files.ReadNum(R, obj.ival); Files.ReadNum(R, TAG);
				NNode(n, tag, contyp[tag], obj, NIL, NIL, Global)
		| TconstSet:
				NEW(obj); Files.ReadNum(R, obj.ival); Files.ReadNum(R, TAG);
				NNode(n, tag, contyp[tag], obj, NIL, NIL, Global)
		| TconstReal:
				NEW(obj); Files.ReadReal(R, sr); obj.intval2 := S.VAL(LONGINT, sr); Files.ReadNum(R, TAG);
				NNode(n, TconstReal, PLT.realtyp, obj, NIL, NIL, Global)
		| TconstLReal:
				NEW(obj); Files.ReadLReal(R, obj.rval); Files.ReadNum(R, TAG);
				NNode(n, TconstLReal, PLT.lrltyp, obj, NIL, NIL, Global)
		| TconstString:
				NEW(obj); NEW(obj.xval); RString(R, obj.xval^, obj.intval2); Files.ReadNum(R, TAG);
				NNode(n, TconstString, PLT.stringtyp, obj, NIL, NIL, Global)
		| Tderef:
				Files.ReadNum(R, TAG); Input(left);
				NNode(n, Tderef, left.typ.BaseTyp, NIL, left, NIL, left.global)
		| Tindex:
				Files.ReadNum(R, TAG); Input(left); Input(right);
				NNode(n, Tindex, left.typ.BaseTyp, NIL, left, right, left.global & right.global)
		| TmopNot..TmopCap:
				Files.ReadNum(R, TAG); Input(left);
				NNode(n, tag, left.typ, NIL, left, NIL, left.global)
		| TmopOdd:
				Files.ReadNum(R, TAG); Input(left);
				NNode(n, TmopOdd, PLT.booltyp, NIL, left, NIL, left.global)
		| TdopAnd..TdopAsh:
				Files.ReadNum(R, TAG); Input(left); Input(right);
				NNode(n, tag, left.typ, NIL, left, right, left.global & right.global)
		| TdopLen:
				Files.ReadNum(R, TAG); Input(left); Input(right);
				NNode(n, TdopLen, PLT.linttyp, NIL, left, right, left.global & right.global)
		| TdopIn..TdopGeq:
				Files.ReadNum(R, TAG); Input(left); Input(right);
				NNode(n, tag, PLT.booltyp, NIL, left, right, left.global & right.global)
		| Tupto:
				Files.ReadNum(R, TAG); Input(left); Input(right);
				NNode(n, Tupto, PLT.settyp, NIL, left, right, left.global & right.global)
		| TasgnNewfn:
				Files.ReadNum(R, TAG); Input(left);
				NNode(n, TasgnNewfn, NIL, NIL, left, NIL, left.global);
				restyp:=left.typ.BaseTyp; h:=n;
				WHILE (restyp.form=Comp) & (restyp.comp=DynArr) DO  
					NEW(par); Input(par.left); h.right:=par; h:=par;
					restyp:=restyp.BaseTyp
				END;
		| TasgnAssign:
				Files.ReadNum(R, TAG); Input(left); Input(right);
				IF left.typ = PLT.booltyp THEN NNode(n, UasgnAssignBool, NIL, NIL, left, right, left.global & right.global)
				ELSE NNode(n, UasgnAssignOther, NIL, NIL, left, right, left.global & right.global) END
		| TasgnIncfn..TasgnCopyfn:
				Files.ReadNum(R, TAG); Input(left); Input(right);
				NNode(n, tag, NIL, NIL, left, right, left.global & right.global)
		| Tcall:
				Files.ReadNum(R, TAG); Input(left); restyp := left.typ.BaseTyp; match := 0; remain := SHORT(left.typ.nofdsc);
				NEW(sent); sent.par := left.typ.dsc; CallNode(n, UcallPrcV, remain, restyp, sent, left, left.global);
				WHILE remain > 0 DO Input(par); INC(match); DEC(remain); 
					PNode(n, remain, match, par, n.global&par.global)
				END
		ELSE
			n := block[N+tag];
			CASE n.flag OF
			| flgOK:	Files.ReadNum(R, TAG)
			| flgNoLeft:	Files.ReadNum(R, TAG); Input(left); NNode(n, n.tag, n.typ, n.obj, left, n.right, left.global & n.global)
			| flgNoRight:	Files.ReadNum(R, TAG); Input(right); NNode(n, n.tag, n.typ, n.obj, n.left, right, n.global & right.global)
			| flgEnter:	Enter(n)
			ELSE
				Files.ReadNum(R, TAG); match := n.subflg; remain := n.flag;	(*params*)
				WHILE remain > 0 DO	Input(par); INC(match); DEC(remain); PNode(n, remain, match, par, n.global & par.global) END
			END
		END
	END Input;

	PROCEDURE Statement;
		VAR stat, exp: PLL.Node; dum: PLC.Item; prevExitChain, L, Lc, elseLabel: PLC.Label; num, tag, class, min, max, lo, hi, tab: LONGINT; 
			obj: PLT.Object; typ: PLT.Struct; else, done: BOOLEAN; 
	BEGIN
		stat := NIL;
		CASE TAG OF
		| Tassert:	
			Files.ReadNum(R, num); Files.ReadNum(R, TAG); Input(exp);
			IF assert THEN
				(* L := PLC.Nil; *) Lc := PLC.Nil;
				Compile(exp, dum); PLC.Jncc(dum, Lc, stat);
				PLC.Trap(SHORT(num), stat);
				PLC.FixLink(Lc); (* PLC.FixLink(L); *)
			END
		| Tif, Twith:	tag:=TAG; done := FALSE;
			Files.ReadNum(R, TAG); L := PLC.Nil; Lc := PLC.Nil; Input(exp); class:=exp.tag; Compile(exp, dum); PLC.Jncc(dum, Lc, stat);
			IF (tag=Twith) & (class=UmopIs) THEN
				PushDict;
				obj:=exp.left.obj; typ:=obj.typ; obj.typ:=exp.obj.typ;
				GenNode(obj, obj.typ, obj.mode, FALSE, exp.left.global)
			END;
			LOOP
				CASE TAG OF
				| Telsif:
					Files.ReadNum(R, TAG); PLC.Jmp(L, stat); PLC.FixLink(Lc);
					Input(exp); class := exp.tag; Compile(exp, dum); PLC.Jncc(dum, Lc, stat);
					IF (tag=Twith) & (class=UmopIs) THEN
						PopDict; obj.typ:=typ; PushDict;
						obj:=exp.left.obj; typ:=obj.typ; obj.typ:=exp.obj.typ;
						GenNode(obj, obj.typ, obj.mode, FALSE, exp.left.global);
					END
				| Telse:
					IF (tag=Twith) & (class=UmopIs) THEN PopDict; obj.typ:=typ END;
					Files.ReadNum(R, TAG); PLC.Jmp(L, stat); PLC.FixLink(Lc); done:=TRUE
				| Tend:
					Files.ReadNum(R, TAG); IF ~done THEN PLC.FixLink(Lc) END;
					PLC.FixLink(L);
					EXIT
				| Twend:
					Files.ReadNum(R, TAG); IF ~done THEN PLC.Jmp(L, stat); PLC.FixLink(Lc); PLC.Trap(PLL.WithTrap, stat) END;
					PLC.FixLink(L);
					IF class=UmopIs THEN PopDict; obj.typ:=typ END;
					EXIT
				ELSE Statement END
			END
		| Tcase:	
			Files.ReadNum(R, min); Files.ReadNum(R, max); Files.ReadNum(R, TAG); else := TRUE;
			Input(exp); Compile(exp, dum); L := PLC.Nil; PLC.Case(dum, min, max, tab, elseLabel, stat);
			LOOP
				CASE TAG OF
				| Tcastrap: 
					Files.ReadNum(R, TAG); PLC.FixLink(elseLabel); elseLabel := PLC.pc; PLC.Trap(PLL.CaseTrap, stat); else := FALSE
				| Tcaslbl1:
					IF else THEN PLC.FixLink(elseLabel); elseLabel := PLC.pc; else := FALSE END;
					PLC.Jmp(L, stat); 
					Files.ReadNum(R, lo); Files.ReadNum(R, TAG);
					PLL.CaseJump(PLC.pc, tab, lo-min, lo-min)
				| Tcasrng1:
					IF else THEN PLC.FixLink(elseLabel); elseLabel := PLC.pc; else := FALSE END;
					PLC.Jmp(L, stat);
					Files.ReadNum(R, lo); Files.ReadNum(R, hi); Files.ReadNum(R, TAG);
					PLL.CaseJump(PLC.pc, tab, lo-min, hi-min)
				| Tcaslbl2:
					Files.ReadNum(R, lo); Files.ReadNum(R, TAG);
					PLL.CaseJump(PLC.pc, tab, lo-min, lo-min)
				| Tcasrng2:
					Files.ReadNum(R, lo); Files.ReadNum(R, hi); Files.ReadNum(R, TAG);
					PLL.CaseJump(PLC.pc, tab, lo-min, hi-min)
				| Tend:
					IF else THEN PLC.FixLink(elseLabel); elseLabel := PLC.pc; else := FALSE END;
					Files.ReadNum(R, TAG); PLC.Jmp(L, stat); 
					PLC.CaseFixup(tab, elseLabel, max-min+1); PLC.FixLink(L); EXIT
				ELSE 
					IF else THEN PLC.FixLink(elseLabel); elseLabel := PLC.pc; else := FALSE END;
					Statement 
				END
			END
		| Twhile:	
			Files.ReadNum(R, TAG); L := PLC.Nil; Lc := PLC.Nil; PLC.Jmp(L, stat); PLC.DefLabel(Lc); Input(exp);
			WHILE TAG#Tend DO Statement END;
			Files.ReadNum(R, TAG); PLC.FixLink(L); Compile(exp, dum); PLC.Jcc (dum, Lc, stat)
		| Trepeat:	
			Files.ReadNum(R, TAG); PLC.DefLabel(L);
			WHILE TAG#Tend DO Statement END;
			Files.ReadNum(R, TAG); Input(exp); Compile(exp, dum); PLC.Jncc(dum, L, stat)
		| Tloop:
			Files.ReadNum(R, TAG); 
			prevExitChain := ExitChain; ExitChain := PLC.Nil; PLC.DefLabel(L);
			WHILE TAG#Tend DO Statement END;
			Files.ReadNum(R, TAG);
			PLC.Jmp(L, stat); PLC.FixLink(ExitChain); ExitChain := prevExitChain
		| Texit:	Files.ReadNum(R, TAG); PLC.Jmp(ExitChain, stat)
		| Ttrap:	Files.ReadNum(R, num); Files.ReadNum(R, TAG); PLC.Trap(SHORT(num), stat)
		ELSE
			Input(stat);	(* entry, return, assignment or call *)
			Compile(stat, dum)
		END
	END Statement;

(* error message *)

	PROCEDURE Str(s: ARRAY OF CHAR);
		VAR i: INTEGER;
	BEGIN	i:=0; REPEAT Modules.resMsg[Modules.resMsgLen]:=s[i]; INC(i); INC(Modules.resMsgLen) UNTIL s[i-1]=0X; DEC(Modules.resMsgLen);
	END Str;
	
	PROCEDURE Ch(ch: CHAR);
	BEGIN	Modules.resMsg[Modules.resMsgLen]:=ch; INC(Modules.resMsgLen); Modules.resMsg[Modules.resMsgLen]:=0X
	END Ch;
	
	PROCEDURE Ln;
	BEGIN	Modules.resMsg[Modules.resMsgLen]:=0DX; INC(Modules.resMsgLen); Modules.resMsg[Modules.resMsgLen]:=0X
	END Ln;

(* loading *)

	PROCEDURE LSW (x: LONGINT): LONGINT;
	BEGIN (* least significant word (unsigned) *)
		RETURN S.VAL(LONGINT, S.VAL(SET, x) * S.VAL(SET, 0FFFFH))
	END LSW;

	PROCEDURE BuildExpBlock(M: Modules.Module; obj: PLT.Object);
		VAR nofObj: INTEGER; obj2: PLT.Object; typ: PLT.Struct;
	
		PROCEDURE ExportRecord(typ: PLT.Struct; VAR scope: Modules.ExportDesc);
			VAR nofFld: INTEGER; fld: PLT.Object; old: Modules.ExportPtr;  
		BEGIN
			IF typ.mod = M THEN
				IF typ.oref # 0 THEN old := S.VAL(Modules.ExportPtr, typ.oref);
					scope.nofExp := old.nofExp; scope.dsc := old.dsc; 
				ELSE 
					nofFld := 2; fld := typ.dsc;
					WHILE fld # NIL DO
						IF fld.vis # internal THEN INC(nofFld) END;
						fld := fld.nxtobj
					END;
					NEW(scope.dsc, nofFld);
					scope.nofExp := nofFld; nofFld := 2;
					PLT.FPrintTyp(typ); typ.oref := S.ADR(scope);
					IF (typ.BaseTyp # NIL) & (typ.mod = M) THEN ExportRecord(typ.BaseTyp, scope.dsc[0]) END;
					scope.dsc[0].fp := typ.pbfp; scope.dsc[0].adr := typ.strobj.lim - PLO.sb; 
					scope.dsc[1].fp := typ.pvfp; 
					fld := typ.dsc;
					WHILE fld # NIL DO
						IF fld.vis # internal THEN
							scope.dsc[nofFld].fp := fld.fp; typ := fld.typ;
							WHILE (typ#NIL) & ((typ.form = Comp) & (typ.comp # Record) OR (typ.form = Pointer)) DO typ := typ.BaseTyp END;
							IF (typ#NIL) & (typ.form = Comp) & (typ.comp = Record) THEN ExportRecord(typ, scope.dsc[nofFld]) END; 
							INC(nofFld)
						END;
						fld := fld.nxtobj
					END	
				END
			END
		END ExportRecord;

	BEGIN
		obj2 := obj; nofObj := 0;
		WHILE obj # NIL DO  
			IF obj.vis # internal THEN PLT.FPrintObj(M, obj); INC(nofObj) END; obj := obj.nxtobj;
		END;
		IF nofObj # 0 THEN NEW(M.export.dsc, nofObj) END;
		M.export.nofExp := nofObj; nofObj := 0; 
		WHILE obj2 # NIL DO 
			IF obj2.vis # internal THEN
				M.export.dsc[nofObj].fp := obj2.fp;
				IF obj2.mode = Var THEN M.export.dsc[nofObj].adr := obj2.linkadr - PLO.sb;
				ELSIF obj2.mode=XProc THEN M.export.dsc[nofObj].adr := LSW(PLL.entry[obj2.adr])
				ELSE M.export.dsc[nofObj].adr := 0
				END;
				IF (obj2.mode > XProc) OR (obj2.mode = Var) THEN typ := obj2.typ;
					WHILE (typ#NIL) & ((typ.form = Comp) & (typ.comp # Record) OR (typ.form = Pointer)) DO typ := typ.BaseTyp END;
					IF (typ#NIL) & (typ.form = Comp) & (typ.comp = Record) THEN ExportRecord(typ, M.export.dsc[nofObj]) END
				END;
				INC(nofObj)
			END;
			obj2 := obj2.nxtobj
		END
	END BuildExpBlock;

	PROCEDURE CheckUseBlock(VAR R: Files.Rider; M: Modules.Module; VAR res: INTEGER);
		VAR mod: Modules.Module; name: Modules.ModuleName;
	
		PROCEDURE FindObj(VAR obj: PLT.Object; name: ARRAY OF CHAR);
		BEGIN
			obj := S.VAL(PLT.Object, mod.publics);
			WHILE (obj # NIL) & (obj.name # name) DO obj := obj.nxtobj END
		END FindObj;
	
		PROCEDURE FindField(VAR obj: PLT.Object; typ: PLT.Struct; name: ARRAY OF CHAR);
		BEGIN obj := typ.dsc;
			WHILE (obj # NIL) & (obj.name # name) DO obj := obj.nxtobj END
		END FindField;
	
		PROCEDURE Err;
		BEGIN 
			IF res = 0 THEN Str(M.name); Str(" imports incompatible version of "); Str(mod.name); Str(": "); res := 16
			ELSE Ch(9X) END
		END Err;

		PROCEDURE CheckScope(scope: Modules.ExportDesc; level: INTEGER; typ: PLT.Struct);
			VAR fp, i: LONGINT; typ2: PLT.Struct; obj: PLT.Object; tmpErr: BOOLEAN; n: PLL.Node; (* mfix *)
		BEGIN	tmpErr := (level = EUerrScope);
			IF level = EUrecScope THEN (* do not insert fields here *)
				UNodeO(Uguard, flgNoLeft, typ, NIL, Global);
				UNodeO(Ueguard, flgNoLeft, typ, NIL, Global);
				UNodeO(UmopIs, flgNoLeft, PLT.booltyp, typ.strobj, Global)
			END;
			i := -1;
			Files.ReadNum(R, fp);
			WHILE fp # EUEnd DO
				IF fp = EURecord THEN 
					IF i = -1 THEN i := 0; typ2 := typ.BaseTyp END;
					IF tmpErr THEN CheckScope(scope.dsc[i], EUerrScope, typ2)
					ELSE CheckScope(scope.dsc[i], EUrecScope, typ2)
					END
				ELSE PLT.ReadString(R, name); 
					IF level >= EUobjScope THEN tmpErr := FALSE;
						i := 0; WHILE (i < scope.nofExp) & (scope.dsc[i].fp # fp) DO INC(i) END;
						IF i >= scope.nofExp THEN Err; tmpErr := TRUE; Ln;
							Ch(9X); obj := NIL; Str(name); Str(" incompatible"); DEC(i)
						ELSIF level = EUrecScope THEN FindField(obj, typ, name);
							IF obj.mode = Fld THEN
								UNodeO(Ufield, flgNoLeft, obj.typ, obj, Global);
							ELSE
								NNode(n, Uproc, typ, obj, NIL, NIL, Global);
								CallNode(n, UcallXPrc, obj.nofpar, obj.typ, obj, NIL, Global);
								CallNode(n, UcallXPrc, obj.nofpar, obj.typ, obj, NIL, Global); n.safe := TRUE;
							END;
							typ2 := obj.typ
						ELSE FindObj(obj, name);
							typ2 := obj.typ; 
							IF (obj.mode = Var) OR (obj.mode = XProc) OR (obj.mode = Con) THEN
								GenNode(obj, typ2, obj.mode, External, Global)
							END
						END
					END;
					IF (obj # NIL) & (obj.mode # TProc) & ((obj.mode # XProc) & (obj.mode # Con) OR (level = EUrecScope)) THEN
						WHILE (typ2#NIL) & ((typ2.form = Comp) & (typ2.comp # Record) OR (typ2.form = Pointer)) DO
							IF typ2.form = Pointer THEN GenNode(obj, typ2, TypPointer, External, Global) END;
							typ2:=typ2.BaseTyp
						END
					END
				END;
				Files.ReadNum(R, fp)
			END
		END CheckScope;

	BEGIN res := 0; PLT.ReadString(R, name);
		WHILE (name # "") & (res = 0) DO
			mod := Modules.modList;
			WHILE (mod # NIL) & (mod.name # name) DO mod := mod.link END;
			IF mod # NIL THEN CheckScope(mod.export, 0, NIL) END;
			PLT.ReadString(R, name)
		END
	END CheckUseBlock;

	PROCEDURE [stdcall] *ThreadAbortNotify(id: LONGINT): LONGINT;
		VAR i: LONGINT;
	BEGIN
		IF id = threadID THEN
			block := NIL;
			i := LEN(PLL.recTab); WHILE i > 0 DO DEC(i); PLL.recTab[i] := NIL END;
			threadID := -1
		END;
		IF threadAbortNotify # NIL THEN
			RETURN threadAbortNotify(id)
		ELSE
			RETURN 0
		END
	END ThreadAbortNotify;

	PROCEDURE Load*(VAR buf: Files.Rider; mod: Modules.Module; globals: PLT.Object; b, a: LONGINT); (* ejz *)
		VAR res: INTEGER; 
	BEGIN
		threadID := Kernel32.GetCurrentThreadId();
		R := buf; M := mod; below := -1; above := Ttrap + 1;

		NEW(block, b+a-1); N := b-1;

		UNodeO(UmopConv, flgNoLeft, PLT.chartyp, NIL, Global);
		UNodeO(UmopConv, flgNoLeft, PLT.sinttyp, NIL, Global);
		UNodeO(UmopConv, flgNoLeft, PLT.inttyp, NIL, Global);
		UNodeO(UmopConv, flgNoLeft, PLT.linttyp, NIL, Global);
		UNodeO(UmopConv, flgNoLeft, PLT.realtyp, NIL, Global);
		UNodeO(UmopConv, flgNoLeft, PLT.lrltyp, NIL, Global);
		UNodeO(UmopConvSet, flgNoLeft, PLT.settyp, NIL, Global);
		
		GenNodes(globals, Internal, Global);
	
		res := 0;
		CheckUseBlock(R, mod, res);
	
		IF res = 0 THEN
			Files.ReadNum(R, TAG); WHILE TAG # Tbegin DO Statement END; (* nested *)
			
			body := PLO.pc; PLC.pc := 0; PLC.RiscCodeErr := FALSE; PLC.Enter(NIL, 0, NIL);
			Files.ReadNum(R, TAG); WHILE TAG # Tend DO Statement END; (* body *)
			PLC.Exit(NIL);
			IF ~PLC.RiscCodeErr THEN PLL.GenCode(PLC.pc); PLL.OutRefPoint(NIL, -1); PLL.OutRefName("$$"); PLL.OutRefs(globals) END;
			block := NIL; buf := R;
			BuildExpBlock(mod, globals)
		END;
		block := NIL; Modules.res := res;
		threadID := -1
	END Load;

	PROCEDURE EnableAssert*;
	BEGIN	assert:=TRUE
	END EnableAssert;

	PROCEDURE DisableAssert*;
	BEGIN	assert:=FALSE
	END DisableAssert;

	PROCEDURE EnableRefs*;
	BEGIN refs := TRUE
	END EnableRefs;
	
	PROCEDURE DisableRefs*;
	BEGIN refs := FALSE
	END DisableRefs;

BEGIN
	refs := TRUE; assert := TRUE; threadID := -1;
	threadAbortNotify := Kernel32.threadAbortNotify;
	Kernel32.threadAbortNotify := ThreadAbortNotify;
	
	constNodeOT[Char] := TconstChar; constNodeOT[SInt] := TconstSInt;
	constNodeOT[Int] := TconstInt; constNodeOT[LInt] := TconstLInt;
	constNodeOT[Real] := TconstReal; constNodeOT[LReal] := TconstLReal;
	constNodeOT[Set] := TconstSet; constNodeOT[String] := TconstString;
	constNodeOT[NilTyp] := TconstNil;
	
	contyp[TconstChar] := PLT.chartyp; contyp[TconstSet] := PLT.settyp;
	contyp[TconstSInt] := PLT.sinttyp; contyp[TconstInt] := PLT.inttyp;
	contyp[TconstLInt] := PLT.linttyp;

	NEW(nilNode); nilNode.tag := TconstNil; nilNode.typ := PLT.niltyp;
	nilNode.global := Global;
	NEW(nilNode.obj);
	
	NEW(falseNode); falseNode.tag := TconstFalse; falseNode.typ := PLT.booltyp;
	falseNode.global := Global;
	NEW(falseNode.obj);

	NEW(trueNode); trueNode.tag := TconstTrue; trueNode.typ := PLT.booltyp;
	trueNode.global := Global;
	NEW(trueNode.obj);  trueNode.obj.ival := 1;
	
	relT[TdopEql] := 9; relT[TdopNeq] := 10; relT[TdopLss] := 11; relT[TdopLeq] := 12; relT[TdopGtr] := 13; relT[TdopGeq] := 14;
END OPLV.
