(* OBERON System 3, Release 2.2.

Copyright 1996, 1997 Team of the Institute of Computer Systems of ETH Zürich, ETH Center, CH-8092 Zürich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

or requested from the above mentioned address.

Under the license terms stated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Keys;

IMPORT
	Kernel32, Input, Oberon, Objects, Display, Fonts, User32, Attributes, Texts, Files, Out, Crypt, ListRiders, Gadgets,
	Effects, Display3;
	
TYPE
	KeyGadget* = POINTER TO KeyGadgetDesc;
	KeyGadgetDesc* = RECORD (Gadgets.FrameDesc)
		key*: Crypt.Key;
	END;
	
	Timer = ARRAY 2 OF LONGINT;

VAR
	(* for teletype *)
	fnt: Fonts.Font;
	mX, cX, cY: INTEGER;
	
	(* for random number pool *)
	buf: ARRAY 1024 OF CHAR;
	bufpos: INTEGER;
	timer: Timer;

	listR: ListRiders.Rider;
	W: Texts.Writer;
	Z: LONGINT;
	
(* ------ KeyGadget code *)

PROCEDURE KeyGadgetAttributes (F: KeyGadget; VAR M: Objects.AttrMsg);
BEGIN
	IF M.id = Objects.get THEN
		IF M.name = "Gen" THEN
			M.class := Objects.String; COPY("Keys.NewKeyGadget", M.s); M.res := 0
		ELSIF M.name = "LineupHY" THEN
			M.class := Objects.Int; M.i := F.H - Fonts.Default.height; M.res := 0;
		ELSE Gadgets.framehandle(F, M)
		END
	ELSIF M.id = Objects.set THEN
		Gadgets.framehandle(F, M)
	ELSIF M.id = Objects.enum THEN
		Gadgets.framehandle(F, M)
	END
END KeyGadgetAttributes;

PROCEDURE RoundedRect(Q: Display3.Mask; col, X, Y, W, H, mode: INTEGER);
CONST bufSize = 21;
VAR i, x, y, r, d, dx, dy, ox, oy, lx, ly: INTEGER;
	buf: ARRAY bufSize OF INTEGER;
	
	PROCEDURE Walk(x, y: INTEGER);
	VAR p, Y: INTEGER;
	BEGIN
		IF y # ly THEN Y := (y + ly) DIV 2;
			p := x + ox;
			IF buf[Y + r] = -1 THEN buf[Y + r] := p
			ELSE
				IF ox + x < buf[Y + r] THEN Display3.ReplConst(Q, col, ox + x, oy + y, buf[Y + r] - p + 1, 1, mode)
				ELSE Display3.ReplConst(Q, col, buf[Y + r], oy + y, p - buf[Y + r] + 1, 1, mode)
				END;
				buf[Y + r] := -1;
			END;
			ly := y;
		END;
		lx := x;
	END Walk;
	
BEGIN lx := -1; ly := -1;
	FOR i := 0 TO bufSize - 1 DO buf[i] := -1 END;
	r := 5;
	x :=  r; y := 0;
	d := 2* r; dx := 4* r; dy := 0;
	ox := X + W - 1 - r; oy := Y + H - 1 - r;
	WHILE y # r DO
		WHILE d <= 1 DO DEC(x); Walk(x, y); DEC(dx,4); INC(d,dx) END;
		INC(y); Walk(x, y); INC(dy,4); DEC(d,dy);
	END;
	WHILE x # 0 DO DEC(x); Walk(x, y); DEC(dx,4); INC(d,dx) END;
	
	Display3.ReplConst(Q, col, X + r, Y + H - 1, W - 2 * r, 1, mode);
	ox := X + r; oy := Y + H - 1 - r;
	d := -d;
	WHILE x # -r DO
		WHILE d <= 1 DO DEC(y); Walk(x,y); DEC(dy,4); INC(d,dy) END;
		DEC(x); Walk(x,y); INC(dx,4); DEC(d,dx);
	END;
	WHILE y # 0 DO DEC(y); Walk(x,y); DEC(dy,4); INC(d,dy) END;
	
	Display3.ReplConst(Q, col, X, Y + r, W, H - 2 * r, mode);
	
	ox := X + r; oy := Y + r;
	d := -d;
	WHILE y # -r DO
		WHILE d <= 1 DO INC(x); Walk(x,y); DEC(dx,4); INC(d,dx) END;
		DEC(y); Walk(x,y); INC(dy,4); DEC(d,dy);
	END;
	WHILE x # 0 DO INC(x); Walk(x,y); DEC(dx,4); INC(d,dx) END;
	
	Display3.ReplConst(Q, col, X + r, Y, W - 2 * r, 1, mode);
	ox := X + W -1 - r; oy := Y + r;
	d := -d;
	WHILE x # r DO
		WHILE d <= 1 DO INC(y); Walk(x,y); DEC(dy,4); INC(d,dy) END;
		INC(x); Walk(x,y); INC(dx,4); DEC(d,dx);
	END;
	WHILE y # 0 DO INC(y); Walk(x,y); DEC(dy,4); INC(d,dy) END;
END RoundedRect;

PROCEDURE RestoreKeyGadget (F: KeyGadget; Q: Display3.Mask; x, y, w, h: INTEGER);
VAR private: BOOLEAN; col: INTEGER;
BEGIN
	IF F.key # NIL THEN private := F.key.private
	ELSE private := FALSE
	END;
	
	IF private THEN RoundedRect(Q, 7, x, y, w, h, Display.replace)
	ELSE RoundedRect(Q, 11, x, y, w, h, Display.replace)
	END;
	IF F.key.certificates # NIL THEN col := 5 ELSE col := Display3.red END;
	Display3.Circle(Q, col, Display.solid, x + w - 10, y + h - 10, 6, 1, {Display3.filled}, Display.paint);
	IF F.key # NIL THEN
		Display3.CenterString(Q, Display.BG, x, y, w, h DIV 2, Fonts.Default, F.key.name, Display.paint);
		IF private THEN
			Display3.CenterString(Q, Display.BG, x, y + h DIV 2, w * 2 DIV 3, h DIV 2,
				Fonts.This("Courier10b.Scn.Fnt"), "Private", Display.paint);
		ELSE
			Display3.CenterString(Q, Display.BG, x, y + h DIV 2, w * 2 DIV 3, h DIV 2,
				Fonts.This("Courier10b.Scn.Fnt"), "Public", Display.paint);
		END
	ELSE
		Display3.CenterString(Q, Display.BG, x, y + h DIV 2, w * 2 DIV 3, h DIV 2,
			Fonts.This("Courier10b.Scn.Fnt"), "Empty Key", Display.paint);
	END;
	IF Gadgets.selected IN F.state THEN
		Display3.FillPattern(Q, Display3.white, Display3.selectpat,
			x, y, x, y, w, h, Display.paint)
	END
END RestoreKeyGadget;

PROCEDURE CopyKeyGadget* (VAR M: Objects.CopyMsg; from, to: KeyGadget);
BEGIN to.key := from.key; Gadgets.CopyFrame(M, from, to)
END CopyKeyGadget;

PROCEDURE HandleKeyGadget* (F: Objects.Object; VAR M: Objects.ObjMsg);
	VAR x, y, w, h: INTEGER; F1: KeyGadget; Q: Display3.Mask; ch: CHAR;
BEGIN
	WITH F: KeyGadget DO
		IF M IS Display.FrameMsg THEN
			WITH M: Display.FrameMsg DO
				IF (M.F = NIL) OR (M.F = F) THEN (* message addressed to box *)
					x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H;
					IF M IS Display.DisplayMsg THEN
						WITH M: Display.DisplayMsg DO
							IF M.device = Display.screen THEN
								IF (M.id = Display.full) OR (M.F = NIL) THEN
									Gadgets.MakeMask(F, x, y, M.dlink, Q);
									RestoreKeyGadget(F, Q, x, y, w, h)
								ELSIF M.id = Display.area THEN
									Gadgets.MakeMask(F, x, y, M.dlink, Q);
									Display3.AdjustMask(Q, x + M.u, y + h - 1 + M.v, M.w, M.h);
									RestoreKeyGadget(F, Q, x, y, w, h)
								END
							END
						END
					ELSE Gadgets.framehandle(F, M)
					END
				END
			END
		ELSIF M IS Objects.AttrMsg THEN KeyGadgetAttributes(F, M(Objects.AttrMsg))
		ELSIF M IS Objects.FileMsg THEN
			WITH M: Objects.FileMsg DO
				IF M.id = Objects.store THEN
					IF F.key # NIL THEN
						Files.Write(M.R, 1X);
						Crypt.WriteKey(M.R, F.key)
					ELSE Files.Write(M.R, 0X);
					END;
					Gadgets.framehandle(F, M)
				ELSIF M.id = Objects.load THEN
					Files.Read(M.R, ch);
					IF ch = 1X THEN
						NEW(F.key); Crypt.ReadKey(M.R, F.key);
					ELSE ASSERT(ch = 0X)
					END;
					Gadgets.framehandle(F, M)
				END
			END
		ELSIF M IS Objects.CopyMsg THEN
			WITH M: Objects.CopyMsg DO
				IF M.stamp = F.stamp THEN M.obj := F.dlink (*non-first arrival*)
				ELSE (*first arrival*)
					NEW(F1); F.stamp := M.stamp; F.dlink := F1;
					CopyKeyGadget(M, F, F1); M.obj := F1
				END
			END
		ELSE Gadgets.framehandle(F, M)
		END
	END
END HandleKeyGadget;

PROCEDURE InitKeyGadget* (F: KeyGadget; K: Crypt.Key);
BEGIN F.W := 100; F.H := 50; INCL(F.state, Gadgets.transparent);
	F.key := K; F.handle := HandleKeyGadget
END InitKeyGadget;

PROCEDURE NewKeyGadget*;
VAR F: KeyGadget;
BEGIN NEW(F); InitKeyGadget(F, NIL); Objects.NewObj := F
END NewKeyGadget;

(* ------ Integrate code *)

PROCEDURE InsertObj(T: Texts.Text; pos: LONGINT; obj: Objects.Object);
VAR W: Texts.Writer;
BEGIN
	Texts.OpenWriter(W);
	Texts.WriteObj(W, obj);
	Texts.Insert(T, pos, W.buf)
END InsertObj;

(* Integrate using the ConsumeMsg the obj at the current caret position *)
PROCEDURE Integrate(obj: Objects.Object);
VAR C: Display.ConsumeMsg;
BEGIN
	IF obj # NIL THEN
		C.id := Display.integrate; C.obj := obj; C.F := NIL; Display.Broadcast(C);
		IF C.res < 0 THEN (* did not integrate *)
			InsertObj(Oberon.Log, Oberon.Log.len, obj)
		END
	END;
END Integrate;

(* ------ Teletype code *)

PROCEDURE WhiteScreen;
BEGIN Display.ReplConst(Display.FG, 0, 0, Display.Width, Display.Height, Display.replace);
	fnt := Fonts.This("Syntax14.Scn.Fnt");
END WhiteScreen;

PROCEDURE Msg(s: ARRAY OF CHAR);
VAR r: Objects.Object; p: INTEGER;
BEGIN
	p := 0;
	WHILE s[p] # 0X DO
		fnt.GetObj(fnt,ORD(s[p]),r);
		WITH r: Fonts.Char DO
   		Display.CopyPattern(Display.BG, r.pat, cX + r.x, cY + r.y, Display.paint);
		   INC(cX, r.dx); INC(p); 
		END;
	END;
END Msg;

PROCEDURE Goto(X, Y: INTEGER);
BEGIN cX := X; cY := Y; mX := X;
END Goto;

PROCEDURE Ln;
BEGIN cX := mX; DEC(cY, fnt.height);
END Ln;

PROCEDURE RestoreScreen;
VAR msg: Display.ControlMsg;
BEGIN msg.F := NIL; msg.id := Display.restore; Display.Broadcast(msg);
	fnt := NIL; (* reclain font *)
END RestoreScreen;

(* ------ Timer Interface *)

PROCEDURE Start;
VAR r: LONGINT;
BEGIN r := Kernel32.QueryPerformanceCounter(timer[0]);
END Start;

PROCEDURE Stop(VAR elapsed: LONGINT);
VAR t: Timer; r: LONGINT;
BEGIN
	r := Kernel32.QueryPerformanceCounter(t[0]);
	IF t[1] = timer[1] THEN elapsed := t[0] - timer[0]
	ELSE elapsed := MAX(LONGINT) - timer[0] + t[0]
	END;
END Stop;

(* ------ Generation of Random number pool *)

PROCEDURE GetRandomNumbers*(count: INTEGER);
VAR x, y: INTEGER; sum, keys: SET; ch: CHAR; time, elapsed, lastelapsed: LONGINT;
BEGIN
	lastelapsed := -1;
	WhiteScreen;
	Goto(100, 400); bufpos := 0;
	Msg("A supply of random numbers is required to generate the RSA keys."); Ln;
	Msg("The random numbers are calculated from the time intervals between keys"); Ln;
	Msg("pressed on the keyboard. Please type some random characters."); Ln; Ln;
	Start; sum := {};
	REPEAT
		Input.Mouse(keys, x, y); sum := sum+keys; 
		Oberon.DrawCursor(Oberon.Mouse, Effects.Arrow, x, y);
		IF Input.Available() > 0 THEN
			IF bufpos < 1024 THEN
				Input.Read(ch);
				Stop(elapsed);
				IF elapsed # lastelapsed THEN
					buf[bufpos] := CHR(elapsed MOD 256); INC(bufpos);
					Msg(".");
					lastelapsed := elapsed;
					IF bufpos MOD (count DIV 4) = 0 THEN Ln END
				END
			END
		END
	UNTIL bufpos = count;
	User32.MessageBeep(1);
	Ln;
	Msg("Thank you");
	time := Oberon.Time();
	WHILE (Input.Available() > 0) OR (Oberon.Time() - time < Input.TimeUnit * 2) DO
		IF Input.Available() > 0 THEN Input.Read(ch) END;
	END;
	RestoreScreen
END GetRandomNumbers;

PROCEDURE GetRandom(): LONGINT;
VAR x, i: LONGINT;
BEGIN
	x := 0;
	FOR i := 0 TO 3 DO
		DEC(bufpos);
		x := x * 256 + ORD(buf[bufpos])
	END;
	RETURN x
END GetRandom;

PROCEDURE Random(VAR r: Crypt.Register);
VAR i: LONGINT;
BEGIN
	Crypt.Init(r, 0);
	FOR i := 0 TO (LEN(r) DIV 2-1) DO r[i] := GetRandom() END;
	i := LEN(r) DIV 2-1;
	IF r[i] < 0 THEN r[i] := ABS(r[i]) END;
END Random;

PROCEDURE Uniform(): REAL;
CONST
a = 16807;	m = 2147483647; 	
q = m DIV a;	r = m MOD a;
VAR g: LONGINT;
BEGIN
	g := a*(Z MOD q) - r*(Z DIV q);
	IF g > 0 THEN Z := g ELSE Z := g + m END;
	RETURN Z*(1.0/m)
END Uniform;

PROCEDURE PseudoRandom (VAR r: Crypt.Register);
VAR i: LONGINT;
BEGIN
	Crypt.Init(r, 0);
	FOR i := 0 TO (LEN(r) DIV 2-1) DO r[i] := ENTIER(Uniform() * MAX(LONGINT)) END;
END PseudoRandom;

PROCEDURE WriteHex(VAR W: Texts.Writer; VAR r: Crypt.Register);
VAR i, x, p: LONGINT; buf: ARRAY 9 OF CHAR; ok: BOOLEAN;

	PROCEDURE Wr(n: LONGINT);
	BEGIN
		IF n < 10 THEN buf[p] := CHR(ORD("0") + n)
		ELSE buf[p] := CHR(ORD("A") + n - 10)
		END;
		INC(p)
	END Wr;
	
BEGIN ok := FALSE;
	Texts.Write(W, "["); Texts.WriteInt(W, (Crypt.Significance(r) + 1) * 32, 0);Texts.Write(W, "]");
	FOR i := LEN(r) - 1 TO 0 BY -1 DO
		x := r[i];
		IF (x # 0) OR ok THEN ok := TRUE;
			p := 0;
			Wr(x MOD 16); x := x DIV 16; Wr(x MOD 16); x := x DIV 16;
			Wr(x MOD 16); x := x DIV 16; Wr(x MOD 16); x := x DIV 16;
			Wr(x MOD 16); x := x DIV 16; Wr(x MOD 16); x := x DIV 16;
			Wr(x MOD 16); x := x DIV 16; Wr(x MOD 16);
			REPEAT DEC(p); Texts.Write(W, buf[p]); UNTIL p = 0
		END
	END;
	IF ~ok THEN Texts.Write(W, "0") END;
END WriteHex;

PROCEDURE Dump(s: ARRAY OF CHAR; VAR r: Crypt.Register);
BEGIN
	Texts.WriteString(W, s); WriteHex(W, r); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
END Dump;

PROCEDURE TestPair(pw: ARRAY OF CHAR; VAR public, private: Crypt.Key);
VAR error: ARRAY 64 OF CHAR;
	msg, enc, dec, t: Crypt.RegisterPtr; res: INTEGER; x: LONGINT; digest: Crypt.CipherKey;
BEGIN
	NEW(msg, public.size DIV 32);
	NEW(enc, public.size DIV 32);
	NEW(dec, public.size DIV 32);

	Crypt.Init(msg^, 1234);
	Crypt.RSAEncrypt (public, msg^, enc^);
	Crypt.RSADecrypt(private, pw, enc^, dec^, res); ASSERT(res = 0, 90);
	x := Crypt.Compare(dec^, msg^);
	IF x # 0 THEN
		COPY("Crypto error, pub -> priv", error);
		Out.Int(x, 0); Out.Ln;
		Dump("coded priv exp=", private.exponent^);
		NEW(t, public.size DIV 32); Crypt.Move(t^, private.exponent^);
		Crypt.MD5Init; Crypt.MD5WriteString(pw); Crypt.MD5Close(digest);
		Crypt.IDEAInitDecoding(digest); Crypt.CipherRegister(t^);
		Dump("priv exp=", t^);
		
		Dump("priv mod=", private.modulus^);
		Dump("pub exp=", public.exponent^);
		Dump("pub mod=", public.modulus^);
		Dump("msg=", msg^);
		Dump("enc=", enc^);
		Dump("dec=", dec^);
		HALT(99)
	END;
	
	Crypt.Init(msg^, 100234);
	Crypt.RSADecrypt(private, pw, msg^, enc^, res); ASSERT(res = 0, 90);
	Crypt.RSAEncrypt (public, enc^, dec^);
	x := Crypt.Compare(dec^, msg^);
	IF x # 0 THEN
		COPY("Crypto error, pub -> priv", error);
		Out.Int(x, 0); Out.Ln;
		Dump("coded priv exp=", private.exponent^);
		NEW(t, public.size DIV 32); Crypt.Move(t^, private.exponent^);
		Crypt.MD5Init; Crypt.MD5WriteString(pw); Crypt.MD5Close(digest);
		Crypt.IDEAInitDecoding(digest); Crypt.CipherRegister(t^);
		Dump("priv exp=", t^);

		Dump("priv mod=", private.modulus^);
		Dump("pub exp=", public.exponent^);
		Dump("pub mod=", public.modulus^);
		Dump("msg=", msg^);
		Dump("enc=", enc^);
		Dump("dec=", dec^);
		HALT(100)
	END;
END TestPair;

PROCEDURE TestImplementation*;
VAR
	pub, priv: Crypt.Key; p, q: Crypt.RegisterPtr;
	size: INTEGER; pw: ARRAY 128 OF CHAR;
BEGIN
	pw := "Hello";
	size := 512;
	NEW(p, size DIV 2 DIV 32); NEW(q, size DIV 2 DIV 32);
	NEW(pub); NEW(priv);
	WHILE Input.Available() = 0 DO
		PseudoRandom(p^); Crypt.NextPrime(p^);
		PseudoRandom(q^); Crypt.NextPrime(q^);
		ASSERT(Crypt.Compare(p^, q^) # 0);
		Dump("p=", p^);
		Dump("q=", q^);
		Crypt.MakeKeys(p^, q^, "Test Key", pw, pub, priv);
		TestPair(pw, pub, priv);
	END
END TestImplementation;

PROCEDURE Enum(K: Crypt.Key);
VAR d: ListRiders.String;
BEGIN NEW(d); COPY(K.name, d.s); listR.do.Write(listR, d)
END Enum;

PROCEDURE MakeKeyPair*;
VAR
	S: Attributes.Scanner;
	pub, priv: Crypt.Key; p, q: Crypt.RegisterPtr;
	pw, pw0, name: ARRAY 128 OF CHAR;
	R: Crypt.Keyring;
	KA, KB: KeyGadget;
	context, obj: Objects.Object;
	size: INTEGER;
	M: ListRiders.ConnectMsg;
BEGIN
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF (S.class = Attributes.String) & (S.s # "") THEN COPY(S.s, name);
		size := 512;
		Attributes.Scan(S);
		IF S.class IN {Attributes.String, Attributes.Name} THEN
			IF S.s = "medium" THEN size := 512
			ELSIF S.s = "high" THEN size := 1024
			END;
		END;
		NEW(p, size DIV 2 DIV 32); NEW(q, size DIV 2 DIV 32);
		NEW(pub); NEW(priv);
		Crypt.GetPassword("Please enter password to", "protect the private key of", name, Fonts.This("Syntax12.Scn.Fnt"), pw, FALSE);
		Crypt.GetPassword("", "Verify password", "", Fonts.This("Syntax12.Scn.Fnt"), pw0, FALSE);
		IF pw = pw0 THEN
			GetRandomNumbers(size DIV 8);
			
			Out.String(" Building keys of "); Out.Int(size, 0); Out.String(" bits."); Out.Ln;
			Out.String(" Manufacturing prime factors. Please be patient ..."); Out.Ln;
			Random(p^); Crypt.NextPrime(p^);
			Random(q^); Crypt.NextPrime(q^);
			ASSERT(Crypt.Compare(p^, q^) # 0);
			
			Out.String(" Manufacturing keys for "); Out.Char(22X); Out.String(name); Out.Char(22X); Out.Ln;
			Crypt.MakeKeys(p^, q^, name, pw, pub, priv);
			
			TestPair(pw, pub, priv);

			NEW(KA); InitKeyGadget(KA, pub); (* Integrate(KA); *)
			NEW(KB); InitKeyGadget(KB, priv); (* Integrate(KB); *)
			
			R := Crypt.OpenKeyring("Public.Ring"); Crypt.InsertKey(R, pub); Crypt.CloseKeyring(R);
			R := Crypt.OpenKeyring("Private.Ring"); Crypt.InsertKey(R, priv); Crypt.CloseKeyring(R);
			
			Out.String(" Done"); Out.Ln;
			
			(* Update display *)
			context := Gadgets.context;
			REPEAT
				obj := Gadgets.FindObj(context, "KeyList"); context := context.dlink
			UNTIL (obj # NIL) OR (context = NIL);
			IF obj # NIL THEN
				M.R := NIL; obj.handle(obj, M);
				IF M.R # NIL THEN
					listR := M.R;
					WHILE ~listR.eol DO listR.do.DeleteLink(NIL, listR) END;
					Attributes.GetString(obj, "Keyring", name);
					R := Crypt.OpenKeyring(name);
					Crypt.EnumKeys(R, Enum);
					Gadgets.Update(obj)
				END
			END
			
		ELSE Out.String(" Sorry, password does not verify"); Out.Ln
		END
	ELSE Out.String(" no user identfication string specified"); Out.Ln
	END
END MakeKeyPair;

(* ----- Key DB stuff *)

PROCEDURE Updatelist(name: ARRAY OF CHAR; R: Crypt.Keyring; s: ARRAY OF CHAR);
VAR obj: Objects.Object; M: ListRiders.ConnectMsg;
BEGIN
	obj := Gadgets.FindObj(Gadgets.context, s);
	IF obj # NIL THEN
		M.R := NIL; obj.handle(obj, M);
		IF M.R # NIL THEN
			listR := M.R;
			WHILE ~listR.eol DO listR.do.DeleteLink(NIL, listR) END;
			Crypt.EnumKeys(R, Enum);
			Attributes.SetString(obj, "Keyring", name);
			Gadgets.Update(obj)
		END
	END
END Updatelist;

PROCEDURE Directory*;
VAR R: Crypt.Keyring; S: Attributes.Scanner;
BEGIN
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF S.class IN {Attributes.String, Attributes.Name} THEN
		R := Crypt.OpenKeyring(S.s);
		IF R # NIL THEN
			Updatelist(S.s, R, "KeyList");
		ELSE Out.String(" can't open keyring"); Out.Ln
		END
	ELSE Out.String(" no keyring specified"); Out.Ln
	END
END Directory;

PROCEDURE ExportKey*;
VAR R: Crypt.Keyring; S: Attributes.Scanner; K: Crypt.Key; KG: KeyGadget;
BEGIN
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF S.class IN {Attributes.String, Attributes.Name} THEN
		R := Crypt.OpenKeyring(S.s);
		IF R # NIL THEN
			Attributes.Scan(S);
			IF S.class IN {Attributes.String, Attributes.Name} THEN
				Crypt.FindKey(R, S.s, K);
				IF K # NIL THEN
					NEW(KG); InitKeyGadget(KG, K); Integrate(KG)
				ELSE Out.String(" no such key or private key"); Out.Ln
				END
			ELSE Out.String(" no name specified"); Out.Ln
			END
		ELSE Out.String(" can't open keyring"); Out.Ln
		END
	ELSE Out.String(" no keyring specified"); Out.Ln
	END
END ExportKey;

PROCEDURE DeleteKey*;
VAR R: Crypt.Keyring; S: Attributes.Scanner; K: Crypt.Key;
BEGIN
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF S.class IN {Attributes.String, Attributes.Name} THEN
		R := Crypt.OpenKeyring(S.s);
		IF R # NIL THEN
			Attributes.Scan(S);
			IF S.class IN {Attributes.String, Attributes.Name} THEN
				Crypt.FindKey(R, S.s, K);
				IF K # NIL THEN
					Crypt.DeleteKey(R, K); Crypt.CloseKeyring(R);
					Out.String(" done"); Out.Ln;
					Updatelist(S.s, R, "KeyList");
				ELSE Out.String(" no such key"); Out.Ln
				END
			ELSE Out.String(" no name specified"); Out.Ln
			END
		ELSE Out.String(" can't open keyring"); Out.Ln
		END
	ELSE Out.String(" no keyring specified"); Out.Ln
	END
END DeleteKey;

PROCEDURE DetailsKey*;
VAR R: Crypt.Keyring; S: Attributes.Scanner; K: Crypt.Key; C: Crypt.Certificate;
BEGIN
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF S.class IN {Attributes.String, Attributes.Name} THEN
		R := Crypt.OpenKeyring(S.s);
		IF R # NIL THEN
			Attributes.Scan(S);
			IF S.class IN {Attributes.String, Attributes.Name} THEN
				Crypt.FindKey(R, S.s, K);
				IF K # NIL THEN
					Texts.Write(W, 22X);
					Texts.WriteString(W, K.name);
					Texts.Write(W, 22X); Texts.WriteLn(W);
					IF K.private THEN Texts.WriteString(W, "   Private Key ")
					ELSE Texts.WriteString(W, "   Public Key ")
					END;
					Texts.WriteInt(W, K.size, 0); Texts.WriteString(W, " bits  ");
					Texts.WriteDate(W, K.time, K.date);
					Texts.WriteLn(W);
					C := K.certificates;
					WHILE C # NIL DO
						Texts.WriteString(W, "   Certification Authority: "); Texts.WriteString(W, C.authority);
						Texts.WriteLn(W);
						C := C.next
					END;
					Texts.Append(Oberon.Log, W.buf);
				ELSE Out.String(" no such key"); Out.Ln
				END
			ELSE Out.String(" no name specified"); Out.Ln
			END
		ELSE Out.String(" can't open keyring"); Out.Ln
		END
	ELSE Out.String(" no keyring specified"); Out.Ln
	END
END DetailsKey;

PROCEDURE ImportKey*;
VAR S: Attributes.Scanner; R: Crypt.Keyring; obj: Objects.Object;
BEGIN
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF S.class IN {Attributes.String, Attributes.Name} THEN
		R := Crypt.OpenKeyring(S.s);
		IF R # NIL THEN
			obj := Gadgets.senderObj;
			IF (obj # NIL) & (obj IS KeyGadget) THEN
				WITH obj: KeyGadget DO
					IF obj.key # NIL THEN
						Crypt.InsertKey(R, obj.key);
						Crypt.CloseKeyring(R);
						Out.String(" done"); Out.Ln;
						Updatelist(S.s, R, "KeyList")
					END
				END
			END
		ELSE Out.String(" can't open keyring"); Out.Ln
		END
	ELSE Out.String(" no keyring specified"); Out.Ln
	END
END ImportKey;

(* ------- Certificate handling ------- *)

PROCEDURE CertifyKeys*;
VAR S: Attributes.Scanner; R: Crypt.Keyring; K: Crypt.Key; user, pw: ARRAY 128 OF CHAR;
	obj: Objects.Object; time, count: LONGINT; C: Crypt.Certificate; ok: BOOLEAN; digest: Crypt.CipherKey;
	signature: Crypt.RegisterPtr; res: INTEGER;
BEGIN
	Out.String("Keys.CertifyKeys"); Out.Ln;
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF S.class IN {Attributes.Name, Attributes.String} THEN
		R := Crypt.OpenKeyring("Private.Ring");
		IF R # NIL THEN
			COPY(S.s, user);
			Crypt.FindKey(R, user, K);
			IF (K # NIL) & K.private THEN
				Crypt.GetPassword("Please enter the password", "to unlock the private key of", user, Fonts.This("Syntax12b.Scn.Fnt"), pw, FALSE);
				
				Gadgets.GetSelection(obj, time);
				IF (time >= 0) & (obj # NIL) THEN
					ok := TRUE; count := 0;
					WHILE (obj # NIL) & ok DO
						IF obj IS KeyGadget THEN
							WITH obj: KeyGadget DO
								Out.String("Signing "); Out.String(obj.key.name); Out.Ln;
								INC(count);
								Crypt.MD5Init; Crypt.MD5WriteKey(obj.key); Crypt.MD5Close(digest);
								Crypt.RSASignDigest(K, pw, digest, signature, res);
								IF res = 0 THEN
									C := obj.key.certificates;
									WHILE (C # NIL) & (C.authority # user) DO C := C.next END;
									IF C = NIL THEN NEW(C); C.next := obj.key.certificates; obj.key.certificates := C END;
									COPY(user, C.authority); C.signature := signature;
									INC(count);
									Gadgets.Update(obj)
								ELSE
									Out.String(" [wrong password]"); Out.Ln;
									ok := FALSE
								END
							END;
						END;
						obj := obj.slink
					END;
					IF (count = 0) & ok THEN Out.String(" [no keys selected]"); Out.Ln END;
				END
			ELSE Out.String(" [no such key or public key]"); Out.Ln
			END
		ELSE Out.String(" [can't open keyring]"); Out.Ln
		END
	ELSE Out.String(" [no key identification given]"); Out.Ln
	END
END CertifyKeys;

PROCEDURE VerifyKeys*;
VAR obj: Objects.Object; time: LONGINT; R: Crypt.Keyring;

	(* might get into a recursive loop *)
	PROCEDURE CheckKey(K: Crypt.Key);
	VAR C: Crypt.Certificate; k: Crypt.Key; digest: Crypt.CipherKey; res: INTEGER;
	BEGIN
		C := K.certificates;
		IF C = NIL THEN Out.String("   has no certificates"); Out.Ln
		ELSE
			Crypt.MD5Init; Crypt.MD5WriteKey(K); Crypt.MD5Close(digest);
			WHILE C # NIL DO
				Out.String("   Certification by "); Out.Char(22X); Out.String(C.authority); Out.Char(22X);
				Crypt.FindKey(R, C.authority, k);
				IF k = NIL THEN Out.String("   failed, public key of certification authority is not known"); Out.Ln;
				ELSE
					Crypt.RSAVerifySignature(k, digest, C.signature, res);
					IF res = 0 THEN
						Out.String("  verifies OK"); Out.Ln;
						Out.String("Checking key of "); Out.Char(22X); Out.String(k.name); Out.Char(22X); Out.Ln;
						CheckKey(k);
					ELSE Out.String("   failed, signature does not match (key is not to be trusted)"); Out.Ln;
					END
				END;
				C := C.next
			END;
		END
	END CheckKey;
	
BEGIN
	R := Crypt.OpenKeyring("Public.Ring");
	Gadgets.GetSelection(obj, time);
	IF (time >= 0) & (obj # NIL) THEN
		WHILE obj # NIL DO
			IF obj IS KeyGadget THEN
				WITH obj: KeyGadget DO
					Out.String("Checking key of "); Out.Char(22X); Out.String(obj.key.name); Out.Char(22X); Out.Ln;
					CheckKey(obj.key)
				END
			END;
			obj := obj.slink
		END
	END
END VerifyKeys;

BEGIN Z := Oberon.Time();
	Texts.OpenWriter(W)
END Keys.

