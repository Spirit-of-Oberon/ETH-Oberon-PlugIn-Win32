(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Watson0; (** portable, except where noted / source: Win32.Watson0.Mod *)	(** PS, tk	/		/	Windows & Macintosh-Version *)

	IMPORT OPT:= OOPT, OPU:=OOPU, Modules, Fonts, Objects, Texts, Oberon, Gadgets, 
		TextFields, ListRiders, Icons, Attributes, Links, FileDir, Strings;

	CONST
	(* CONST used to read symbol file *)

		(*object modes *)
		Var = 1; VarPar = 2; Con = 3; Fld = 4; Typ = 5; XProc = 7; Anchor = 14; Removed = 15;
		CProc = 9; TProc = 13;
	
		(* structure forms *)
		Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6;
		Real = 7; LReal = 8; Set = 9; String = 10; NilTyp = 11;
		Pointer = 13; ProcTyp = 14; Comp = 15;
			
		(* composite structure forms *)
		Array = 2; DynArr = 3; Record = 4;

		(* visibility of objects *)
		internal = 0; externalR = 2;

	(* other CONST *)
		(* text link colors *)
		TextCol = 15; LinkCol = 3; ImportCol = 1; UsedCol = 8;

		(* commands *)
		ObjCmd = "Watson.ShowObj "; ModCmd = "Watson.ShowDef "; GotoCmd = "Watson.Goto ";
		ImpCmd = "Watson.ShowImports "; LookupCmd = "Watson.LookupObj";

	VAR
	(* global vars *)
		W: Texts.Writer;
		options*: ARRAY 12 OF CHAR;	(** options: ['x' | 'd'] *)(* set by Watson.GetArgs and appended at a control's cmd *)
		expandTypes,	(* show base type(s) of record definition *)
		showAdr: BOOLEAN;	(* show adresses, entry number of object *)
		Hex: ARRAY 17 OF CHAR;	(* array of hex digits *)
		fp: LONGINT; 	(* fingerprint *)
		objNum: LONGINT;	(* number to generate object name *)

	(* vars used by symbol file reader *)
		curObj: OPT.Object;	(* current object in process *)
		syspos: LONGINT;	(* text pos where to write imported modules *)
		sysImported,	(* indicates whether SYSTEM is imported or not *)
		first,	(* FALSE: keyword ['CONST' | 'TYPE' | 'VAR'] has already been written to text *)
		showObj, showExports, showImps: BOOLEAN;	(* TRUE: only one object is shown *)
		boldFont: Fonts.Font; 


	(* *************** AUX. PROCEDURES *************** *)

	(* ---------------------- string funktions ----------------------- *)
(*
	PROCEDURE Append (VAR d: ARRAY OF CHAR; s: ARRAY OF CHAR);	(* appends string s to string d *)
		VAR i, j: INTEGER; ch: CHAR;
	BEGIN
		i := 0; WHILE d[i] # 0X DO INC(i) END;
		j := 0; REPEAT ch := s[j]; d[i] := ch; INC(i); INC(j) UNTIL ch = 0X
	END Append;

	PROCEDURE AppendCh (VAR d: ARRAY OF CHAR; ch: CHAR);	(* appends char ch to string d *)
		VAR i: INTEGER;
	BEGIN
		i := 0; WHILE d[i] # 0X DO INC(i) END;
		d[i]:= ch; d[i+1]:= 0X
	END AppendCh;
*)
	(* ---------------------- output procedures ----------------------- *)

	PROCEDURE Str (s: ARRAY OF CHAR);	(* writes string s to W *)
	BEGIN Texts.WriteString(W, s) 
	END Str;
	
	PROCEDURE Ch (ch: CHAR);	(* writes char ch to W *)
	BEGIN Texts.Write(W, ch) 
	END Ch;
	
	PROCEDURE Num (i: LONGINT);	(* writes number i to W *)
	BEGIN Texts.WriteInt(W, i, 0);
	END Num;
	
	PROCEDURE Hexa(i: LONGINT; short: BOOLEAN);	(* writes number i to W as a hex. number *)
	BEGIN
		IF ~short THEN	(* fully 32 bit number *)
			Ch(Hex[i DIV 10000000H MOD 10H]); i:= i MOD 10000000H;
			Ch(Hex[i DIV 1000000H MOD 10H]); i:= i MOD 1000000H;
			Ch(Hex[i DIV 100000H MOD 10H]); i:= i MOD 100000H;
			Ch(Hex[i DIV 10000H MOD 10H]); i:= i MOD 10000H
		END;
		Ch(Hex[i DIV 1000H MOD 10H]); i:= i MOD 1000H;
		Ch(Hex[i DIV 100H MOD 10H]); i:= i MOD 100H;
		Ch(Hex[i DIV 10H MOD 10H]); Ch(Hex[i MOD 10H])
	END Hexa;
	
	PROCEDURE Ln;	(* writes a line feed to W *)
	BEGIN Texts.WriteLn(W) 
	END Ln;
	
	PROCEDURE Indent (i: INTEGER);	(* writes i tabs to W *)
	BEGIN WHILE i > 0 DO Ch(9X); DEC(i) END
	END Indent;

	PROCEDURE Control(name, cmd, par: ARRAY OF CHAR);
	(* writes a control object to W. Name will be set to name and command cmd+options+par *)
		VAR obj: Objects.Object; A: Objects.AttrMsg;
	BEGIN
		obj:= Gadgets.CreateObject("TextGadgets.NewControl");
		IF obj # NIL THEN
			IF par # "" THEN
				A.id:= Objects.set; A.name:= "Cmd"; A.class:= Objects.String; A.res:= -1;
				COPY(cmd, A.s);
				IF options # "" THEN Strings.AppendCh(A.s, Oberon.OptionChar); Strings.Append(A.s, options);
				Strings.AppendCh(A.s, " ") END;
				Strings.Append(A.s, par); obj.handle(obj, A)
			END;
			IF name # "" THEN Gadgets.NameObj(obj, name) END;
			Texts.WriteObj(W, obj)
		END
	END Control;

	PROCEDURE StrUsed (obj: OPT.Object);	(* writes string s or popup menu to W *)
		VAR c: TextFields.Caption; l: Gadgets.Frame; lo: Objects.Object; P: Icons.Iconizer;
				d: ListRiders.String; C: ListRiders.ConnectMsg; w: Texts.Writer;
				h: INTEGER; objname: ARRAY 12 OF CHAR; str: ARRAY 128 OF CHAR;
	BEGIN 
		IF	(obj.used) & showExports	THEN	
			Texts.OpenWriter(w); Texts.SetColor(w, UsedCol);

			Strings.IntToStr(objNum, objname); INC(objNum);
			IF objNum < 0 THEN objNum := 0 END;

			NEW(c); NEW(c.text); Texts.Open(c.text, "");
			Texts.WriteString(w, obj.name); Texts.Append(c.text, w.buf);
			TextFields.InitCaption(c, c.text); c.underlined:=TRUE;

			lo := Gadgets.CreateObject("ListGadgets.NewFrame");
			IF lo # NIL THEN l := lo(Gadgets.Frame) ELSE l := NIL END;
			lo := Gadgets.CreateObject("ListModels.NewList");
			IF (l # NIL) & (lo # NIL) THEN
				Links.SetLink(l, "Model", lo);
				Attributes.SetBool(lo, "Sorted", TRUE);
				Attributes.SetBool(l, "MultiSel", FALSE);
				Attributes.SetBool(l, "ExtendSel", FALSE);
				str := LookupCmd; Strings.Append(str, " &O"); Strings.Append(str, objname); Strings.Append(str, ".Point  ");
				Strings.Append(str, OPT.modules[-obj.mnolev].name); Strings.AppendCh(str, "."); Strings.Append(str, obj.name);
				Attributes.SetString(l, "Cmd", str);
				str := "O"; Strings.Append(str, objname); Attributes.SetString(l, "Name", str);

				C.R := NIL; lo.handle(lo, C);
				obj := obj.sibling; h := 8;
				WHILE obj # NIL DO
					NEW(d); COPY(obj.name, d.s); C.R.do.Write(C.R, d);
					obj := obj.sibling; h := h + Fonts.Default.height
				END;
				IF h > 200 THEN h := 200 END; l.H := h; 
	
				NEW(P); Icons.MakeIconizer(P, c, l); P.pin:=FALSE;
				Attributes.SetBool(P, "Popup", TRUE);
				
				Texts.SetOffset(W, -2); Texts.WriteObj(W, P); Texts.SetOffset(W, 0)
			END
		ELSE
			Texts.WriteString(W, obj.name)
		END
	END StrUsed;

	PROCEDURE IdentifierUsed(obj: OPT.Object);	(* writes a string name and a control to W *)
	BEGIN	StrUsed(obj); Control(obj.name, "", "");
	END IdentifierUsed;

	PROCEDURE Identifier(name: ARRAY OF CHAR);	(* writes a string name and a control to W *)
		VAR i, j: INTEGER;
	BEGIN 
		Str(name);
		IF showObj THEN	(* cut module qualifier *)
			i:= 0; REPEAT INC(i) UNTIL (name[i]=".") OR (name[i]= 0X);
			IF name[i] # 0X THEN
				INC(i); j:= 0; REPEAT name[j]:= name[i]; INC(i); INC(j) UNTIL name[j]=0X
			END
		END;
		Control(name, "", "");
	END Identifier;

	PROCEDURE ToLog;	(* writes W to the log *)
	BEGIN Texts.Append(Oberon.Log, W.buf)
	END ToLog;

	(* *************** SYMBOL FILE *************** *)

	(* ---------------------- write sybol file info ----------------------- *)

	PROCEDURE WriteConstValue (obj: OPT.Object);	(* writes the value of a constant object *)
		VAR i: INTEGER; y: LONGINT; s: SET; 
	BEGIN
		y:= obj.conval.intval;
		CASE obj.typ^.form OF
			| SInt, Int, LInt:  Texts.WriteInt(W, y, 0)
			| Real:  Texts.WriteReal(W, SHORT(obj.conval.realval), 15)
			| LReal:  Texts.WriteLongReal(W, obj.conval.realval, 20)
			| Bool:  IF y = 0 THEN Str("FALSE") ELSE Str("TRUE") END 
			| Char:
				IF (y >= 32) & (y <= 126) THEN Ch(22X); Ch(CHR(y)); Ch(22X)
				ELSE i := SHORT(y DIV 16);
					IF i > 0 THEN
						IF i > 9 THEN Ch("0") END;
						Ch(Hex[i])
					END;
					Ch(Hex[y MOD 16]); Ch("X")
				END
			| Set:
				Ch("{"); s := obj.conval.setval; y := 0;
				WHILE y <= MAX(SET) DO
					IF y IN s THEN Texts.WriteInt(W, y, 0); EXCL(s, y); IF s # {} THEN Str(", ") END END;
					INC(y)
				END;
				Ch("}")
			| NilTyp:  Str("NIL")
			| String: Ch(22X); Str(obj.conval.ext^); Ch(22X)
		END
	END WriteConstValue;

	PROCEDURE ^ WriteType (typ: OPT.Struct; i: INTEGER);

	PROCEDURE WriteBase (typ: OPT.Struct);	(* writes the base type of a record *)
		VAR base: OPT.Struct;
	BEGIN
		base := typ.BaseTyp;
		IF base # NIL THEN
			Str(" ( "); WriteType(typ.BaseTyp, 0);
			IF expandTypes THEN WriteBase(typ.BaseTyp) END;
			Str(" )");
		END
	END WriteBase;
	
	PROCEDURE WriteParams0 (VAR obj: OPT.Object; i: INTEGER);
	(* writes field list of a proc. or record: all variables of same type *)
		VAR typ: OPT.Struct; mode: INTEGER;
	BEGIN
		typ := obj.typ; mode := obj.mode;
		LOOP
			IF obj.name="" THEN Str("@") ELSE Str(obj.name) END;
			IF (obj.vis = externalR) THEN Ch("-") END;
			obj := obj.link;
			IF (obj = NIL) OR (obj.name="") & ~showAdr OR (obj.mode # mode) OR (obj.typ # typ) THEN EXIT END;
			Str(", ");
		END;
		Str(": "); WriteType(typ, i + 1)
	END WriteParams0;
	
	PROCEDURE WriteParams (param: OPT.Object; resTyp: OPT.Struct);	(* writes parameter list of a procedure *)
	BEGIN
		IF (param # NIL) OR (resTyp # OPT.notyp) THEN
			Str(" (");
			WHILE (param # NIL) DO
				IF param.mode = VarPar THEN Str("VAR ") END;
				IF param.name = "" THEN
					WriteType(param.typ, 0);
					param := param.link;
					IF param # NIL THEN Str(", ") END
				ELSE
					WriteParams0(param, 0);
					IF param # NIL THEN Str("; ") END
				END
			END;
			Ch(")");
		END;
		IF resTyp # OPT.notyp THEN Str(": "); WriteType(resTyp, 0) END
	END WriteParams;
	
	PROCEDURE WriteProc (obj: OPT.Object);	(* writes a procedure *)
	BEGIN
		IF showAdr & (obj.mode # CProc) THEN Ch("["); Num(obj.adr); Str("] "); Str("{"); Num(fp); Str("} ") END;
		Str("PROCEDURE ");
		IdentifierUsed(obj);
		WriteParams(obj.link, obj.typ);
		Ch(";")
	END WriteProc;
	
	PROCEDURE WriteTProcs (obj: OPT.Object; i: INTEGER);	(* writes a type bound procedure *)
		VAR firstpar: OPT.Object;
	BEGIN
		IF obj # NIL THEN
			WriteTProcs(obj.left, i);
			IF obj.mode = TProc THEN
				Indent(i);
				IF showAdr THEN
					Ch("["); Num(obj.adr MOD 10000H); Str(", "); Num(obj.adr DIV 10000H); Str("] ");
					Str("{"); Num(obj.fp); Str("} ") 
				END;
				Str("PROCEDURE (");
				firstpar := obj.link;
				IF firstpar.mode = VarPar THEN Str("VAR ") END;
				Str(firstpar.name); Str(": "); Str(firstpar.typ.strobj.name); Str(") ");
				StrUsed(obj);
				WriteParams(firstpar^.link, obj.typ);
				Ch(";"); Ln;
			END;
			WriteTProcs(obj.right, i);
		END;
	END WriteTProcs;
	
	PROCEDURE FieldUsed(fld: OPT.Object): BOOLEAN;
		VAR o: OPT.Object;
	BEGIN
		IF ~showImps THEN RETURN TRUE END;
		o := fld.sibling; 
		IF (o # NIL) & (o.vis # 0) THEN Texts.SetFont(W, boldFont) ELSE Texts.SetFont(W, Fonts.Default) END;
		RETURN o#NIL 
	END FieldUsed;	
	
	PROCEDURE WriteFieldList (fld: OPT.Object; i: INTEGER);	(* writes all record field lists, exept type bound proc.*)
	BEGIN
		WHILE (fld # NIL) & (fld.mode = Fld) & ~FieldUsed(fld) DO fld:=fld.link END;
		WHILE (fld # NIL) & (fld.mode = Fld) DO
			IF fld.name#"" THEN Indent(i);
				IF showAdr THEN Ch("["); Num(fld.adr); Str("] "); Str("{"); Num(fld.fp); Str("} ") END;
				StrUsed(fld); 
				WHILE (fld.link # NIL) & (fld.link.typ = fld.typ) & (fld.link.name # "") DO
					IF FieldUsed(fld.link) THEN
						IF showAdr THEN Ch("["); Num(fld.adr); Str("] "); Str("{"); Num(fld.fp); Str("} ") END;
						IF fld.vis = externalR THEN Ch("-") END; Str(", "); fld := fld.link; 
						StrUsed(fld)
					ELSE fld := fld.link END;
				END;
				IF fld.vis = externalR THEN Ch("-") END; 
				IF fld.typ # OPT.notyp THEN Str(": "); WriteType(fld.typ, i + 1) END; Ch(";"); Ln
			ELSIF (fld # NIL) & showAdr	THEN Indent(i);
				IF showAdr THEN Ch("["); Num(fld.adr); Str("] "); Str("{"); Num(fld.fp); Str("} ") END;
				Str("@: "); WriteType(fld.typ, i + 1); Ch(";"); Ln	
			END;
			fld := fld.link; WHILE (fld # NIL) & (fld.mode = Fld) & ~FieldUsed(fld) DO fld := fld.link END;
		END;
		Texts.SetFont(W, Fonts.Default);
	END WriteFieldList;
	
	PROCEDURE WriteInstVars (typ: OPT.Struct; i: INTEGER; extlev: LONGINT);	(* writes a record definition *)
	BEGIN
		IF typ # NIL THEN
			IF expandTypes & (extlev > 0) THEN
				WriteInstVars(typ.BaseTyp, i, extlev);
				Indent(i); Str("(* "); Str(OPT.modules[typ.mno].name); Ch("."); Str(typ.strobj.name); Str(" *)"); Ln
			END;
			WriteFieldList(typ.link, i);
			WriteTProcs(typ.link, i)
		END
	END WriteInstVars;

	PROCEDURE WriteForm (typ: OPT.Struct; i: INTEGER);	(* writes a type *)
	BEGIN
		IF (typ.form = Comp) & (typ.comp = Record) THEN
			Str("RECORD"); WriteBase(typ);
			IF showAdr THEN Str(" [size = "); Num( typ.size); Ch("]") END;
			IF typ.link # NIL THEN Ln; WriteInstVars(typ, i, typ.extlev); Indent(i - 1) ELSE Ch(" ") END;
			Str("END")
		ELSIF (typ.form = Comp) & (typ.comp = Array) THEN
			Str("ARRAY "); Num(typ.n); Str(" OF "); WriteType(typ.BaseTyp, i)
		ELSIF (typ.form = Comp) & (typ.comp = DynArr) THEN
			Str("ARRAY OF "); WriteType(typ.BaseTyp, i)
		ELSIF typ.form = Pointer THEN
			Str("POINTER TO "); WriteType(typ.BaseTyp, i);
		ELSIF typ.form = ProcTyp THEN
			Str("PROCEDURE");
			WriteParams(typ.link, typ.BaseTyp)
		END
	END WriteForm;

	PROCEDURE WriteType(typ: OPT.Struct; i: INTEGER);	(* writes a type declaration *)
		VAR cmd, par: ARRAY 32 OF CHAR; makeLink: BOOLEAN; 
	BEGIN
		IF (typ.strobj # NIL) & (typ.strobj.name # "") THEN
			makeLink:= FALSE;
			IF (typ = OPT.bytetyp) OR (typ = OPT.sysptrtyp) THEN
				Str("SYSTEM."); sysImported := TRUE;
			ELSIF (typ.mno >= 1) & (ABS(typ.strobj.vis) > internal) THEN
				(* type def. is in an other module or is visible within this module => make a link *)
				makeLink:= TRUE;
				Texts.SetColor(W, LinkCol);
				IF (typ.mno > 1) OR showObj THEN
					(* write module qualifier because object is not in cur. module or showObj option is on *)
					Str(OPT.modules[typ.mno].name); Ch(".")
				END 
			END;
			Str(typ.strobj.name);
			IF makeLink THEN
				IF (typ.mno > 1) THEN	(* definition is in an other module *)
					cmd:= ObjCmd;
					COPY(OPT.modules[typ.mno].name, par); Strings.AppendCh(par, "."); Strings.Append(par, typ.strobj.name)
				ELSE
					IF ~showObj OR (curObj.link = typ.strobj) OR (curObj = typ.strobj) THEN
						(* type def. is in the same text *)
						cmd:= GotoCmd; par:= ""
					ELSE
						cmd:= ObjCmd;
						COPY(OPT.modules[typ.mno].name, par); Strings.AppendCh(par, ".")
					END;
					Strings.Append(par, typ.strobj.name)
				END;
				Control("", cmd, par); Texts.SetColor(W, TextCol)
			END
		ELSE (* anonymous type *) WriteForm(typ, i)
		END
	END WriteType;
	
	PROCEDURE WriteObject(obj: OPT.Object; ind, mode: INTEGER; incons: BOOLEAN);	(* writes any object as given mode *)
		VAR h: OPT.Object; name: ARRAY 32 OF CHAR;
	BEGIN
		IF showAdr THEN OPT.FPrintObj(obj); 
			IF ~incons THEN fp := obj.fp END
		END;
		curObj:= obj;	(* set cur. object in process *)
		IF mode = Con THEN
			IF first THEN Indent(ind); Str("CONST"); Ln; first := FALSE END;
			Indent(ind+1);
			IF incons THEN Texts.SetFont(W, boldFont) END;
			IF showAdr THEN Str("{"); Num(fp); Str("} ") END;
			IdentifierUsed(obj);
			Str(" = "); WriteConstValue(obj); Ch(";");
			IF incons THEN Texts.SetFont(W, Fonts.Default) END;
			Ln
		ELSIF mode = Var THEN
			IF first THEN Indent(ind); Str("VAR"); Ln; first := FALSE END;
			Indent(ind+1);
			IF incons THEN Texts.SetFont(W, boldFont) END;
			IF showAdr THEN Str(" ["); Num(obj.adr); Str("] "); Str("{"); Num(fp); Str("} ") END;
			IdentifierUsed(obj);
			IF obj.vis  = externalR THEN Ch("-") END;
			Str(": "); WriteType(obj.typ, ind+2); Ch(";");
			IF incons THEN Texts.SetFont(W, Fonts.Default) END;
			Ln
		ELSIF (mode = Typ) & (obj.vis > internal) THEN	(* write a type object just if it is vivible *)
			IF first THEN Indent(ind); Str("TYPE"); Ln; first := FALSE END;
			Indent(ind+1);
			IF showAdr THEN Str("{"); Num(fp); Str("} ") END;
			IF incons THEN Texts.SetFont(W, boldFont) END;
			IF showObj THEN 
				COPY(OPT.modules[obj.typ.mno].name, name); Strings.AppendCh(name, "."); Strings.Append(name, obj.name);
				Identifier(name);
			ELSE IdentifierUsed(obj);
			END;
			Str(" = ");
			IF obj.typ.strobj # obj THEN WriteType(obj.typ, 0)  (* alias type *)
			ELSE WriteForm(obj.typ, ind+2)
			END;
			Ch(";"); Ln;
			IF obj.link # NIL THEN (* group of two types (POINTER TO ... & ...Desc) and not alias *)
				h:= obj.link;
				IF ABS(h^.vis) > internal THEN
					Indent(ind+1);
					IF showAdr THEN OPT.FPrintObj(obj.link); Str("{"); Num(obj.link.fp); Str("} ") END;
					IF showObj THEN 
						COPY(OPT.modules[h.typ.mno].name, name); Strings.AppendCh(name, "."); Strings.Append(name, h.name);
						Identifier(name);
					ELSE IdentifierUsed(h)
					END;
					Str(" = "); WriteForm(h.typ, ind+2); Ch(";"); Ln
				END
			END;
			IF incons THEN Texts.SetFont(W, Fonts.Default) END;
			Ln;
		ELSIF mode IN {XProc, CProc} THEN first:= FALSE; Indent(ind); 
			IF incons THEN Texts.SetFont(W, boldFont) END;
			WriteProc(obj); Ln;
			IF incons THEN Texts.SetFont(W, Fonts.Default) END;
		ELSIF mode = Removed THEN 
			IF first THEN Indent(ind); Str("UNDEFINED"); Ln; first:=FALSE END;
			Indent(ind+1); 
			IF incons THEN Texts.SetFont(W, boldFont) END;
			Str(obj.name); Ln;
			IF incons THEN Texts.SetFont(W, Fonts.Default) END;
		END
	END WriteObject;
		
	PROCEDURE WriteScope(obj: OPT.Object; ind, mode: INTEGER);	(* writes all objects of given mode *)

		PROCEDURE Scope (obj: OPT.Object; mode: INTEGER);
			VAR obj2: OPT.Object;
		BEGIN
			IF obj # NIL THEN
				Scope(obj.left, mode);
				IF obj.mode = Anchor THEN obj2 := obj.link; fp:=obj.fp ELSE obj2:=obj END;
				IF obj2.mode = mode THEN WriteObject(obj2, ind, mode, (obj.mode=Anchor) & (obj.vis#0)) END;
				Scope(obj.right, mode);
			END;
		END Scope;	

	BEGIN first := TRUE;
		Scope(obj, mode);
		IF ~first THEN Ln END
	END WriteScope;

	PROCEDURE WriteDef;	(* writes a module definition *)
		VAR scope: OPT.Object; i: INTEGER;
	BEGIN sysImported:= FALSE; OPT.modNo:=1;
		scope:= OPT.modules[1].right; 
		Str("DEFINITION "); Str(OPT.modules[1].name);
		Ch(";"); Ln; Ln;
		syspos := W.buf.len;
		
		i:= 2; (* assume that OPT.GlbMod[0] is "self" *)
		first := TRUE;
		WHILE i < OPT.nofmod DO
			IF first THEN Indent(1); Str("IMPORT "); first := FALSE; syspos := W.buf.len ELSE Str(", ") END;
			IF i MOD 11 = 0 THEN Ln; Indent(2) END;
			Texts.SetColor(W, ImportCol);
			Str(OPT.modules[i].name);
			Texts.SetColor(W, TextCol);
			Control("", ModCmd, OPT.modules[i].name);
			INC(i)
		END;
		IF ~first THEN Ch(";"); Ln; Ln END;
		
		WriteScope(scope, 1, Con);
		WriteScope(scope, 1, Typ);
		WriteScope(scope, 1, Var);
		WriteScope(scope, 1, CProc);
		WriteScope(scope, 1, XProc);
		Str("END "); Str(OPT.modules[1].name); Ch("."); Ln
	END WriteDef;

	PROCEDURE WriteImpScope(name: ARRAY OF CHAR; scope: OPT.Object);
	BEGIN	 
		Indent(1); Str("FROM "); 
		Texts.SetColor(W, ImportCol);
		Str(name);
		Texts.SetColor(W, TextCol);
		Control("", ModCmd, name);
		Str(" IMPORT"); Ln; Ln;
		WriteScope(scope, 2, Con); 
		WriteScope(scope, 2, Typ); 
		WriteScope(scope, 2, Var); 
		WriteScope(scope, 2, XProc);
		WriteScope(scope, 2, Removed);
		Ln;
	END WriteImpScope;

	PROCEDURE WriteImports(name: ARRAY OF CHAR);	(* writes a modules import definitions *)
		VAR mod: OPU.Module;
	BEGIN sysImported:= FALSE; 
		Str("DEFINITION "); Str(name);
		Ch(";"); Ln; Ln;
		syspos := W.buf.len; OPT.modNo:=1;
		mod := OPU.DecorateImp(name, WriteImpScope);
		sysImported := FALSE; Str("END "); Str(name); Ch("."); Ln
	END WriteImports;

	PROCEDURE MakeText(T: Texts.Text);	(* appends writer W and inserts import list *)
	BEGIN
		Texts.Append(T, W.buf);
		IF sysImported & ~showObj THEN
			IF OPT.nofmod > 2 THEN Str("SYSTEM, ") ELSE Ch(09X); Str("IMPORT SYSTEM;"); Ln; Ln END;
			Texts.Insert(T, syspos, W.buf);
		END
	END MakeText;

	(* ------------------------ read & prepare symbols ------------------- *)

	PROCEDURE Find (name: ARRAY OF CHAR; VAR obj: OPT.Object);	(* looks for object name in the OPT top scope *)
	BEGIN obj := OPT.modules[1].right;
		LOOP
			IF obj = NIL THEN RETURN
			ELSIF name < obj.name THEN obj := obj.left
			ELSIF name > obj.name THEN obj := obj.right
			ELSE RETURN
			END
		END
	END Find;

	PROCEDURE FindPointer(name: ARRAY OF CHAR; VAR obj: OPT.Object);	(* find pointer to record name *)
	
		PROCEDURE FindP(name: ARRAY OF CHAR; root: OPT.Object);
			VAR typ: OPT.Struct;
		BEGIN
			IF root#NIL THEN
				IF (root.mode = Typ) & (root.typ.form = Pointer) THEN
					typ:= root.typ.BaseTyp;
					IF (typ.strobj # NIL) & (typ.strobj.name = name) THEN obj:=root END
				END;
				IF obj=NIL THEN FindP(name, root.right) END;
				IF obj=NIL THEN FindP(name, root.left) END;
			END
		END FindP;

	BEGIN obj:=NIL; FindP(name, OPT.modules[1].right)
	END FindPointer;
	
	
	PROCEDURE GroupTypes (obj: OPT.Object);
	(* groups pointer and its corresponding record, so they can be writter together *)
		VAR typ: OPT.Struct; h: OPT.Object;
	BEGIN
		IF obj # NIL THEN
			GroupTypes(obj.left);
			IF (obj.mode = Typ) THEN typ:= obj.typ;
				IF typ.form = Pointer THEN
					IF typ.BaseTyp.strobj # NIL THEN (* named base type *)
						Find(typ.BaseTyp.strobj.name, h);
						IF (h # NIL) & (h.typ.mno = 1) THEN
							obj.link:= h;
							h.vis := -h.vis	(* prevent normal output of this type *)
						END;
					END;
				END
			END;
			GroupTypes(obj.right)
		END
	END GroupTypes;

	PROCEDURE ReadSym (VAR mod: ARRAY OF CHAR): BOOLEAN;	(* read the symbol file by calling OPT.Import *)
		VAR theMod: OPU.Module;
	BEGIN
		IF mod = "SYSTEM" THEN 
			Str("definition of SYSTEM not available"); Ln; ToLog; RETURN FALSE
		ELSE	
			theMod:=OPU.DecorateDef(mod);
			IF theMod#NIL THEN
				GroupTypes(OPT.modules[1].right); 
				RETURN TRUE
			ELSE
				Str("-- symbol file not found"); Ln; ToLog;
				RETURN FALSE
			END 
		END
	END ReadSym;


	(* *************** OBJECT FILE *************** *)

	(* ---------------------- write object info ----------------------- *)
	
	PROCEDURE Commands(VAR modName: ARRAY OF CHAR);	(* writes all commands of this module  *)
		VAR M: Modules.Module; i, NrOfCmds: LONGINT;
	BEGIN
		M := Modules.ThisMod(modName);
		IF M # NIL THEN
			Str("DEFINITION "); Str(modName);
			Ch(";"); Ln; Ln;
	
			(* commands *)
			i:=0; NrOfCmds := LEN(M.cmds^);
			WHILE i < NrOfCmds DO
				Ch(09X);	(* TAB *)
				IF showAdr THEN Ch("["); Hexa(M.cmds[i].adr, TRUE); Str("] ") END;
				Str(M.name); Ch("."); Str(M.cmds[i].name); Control(M.cmds[i].name, "", ""); Ln;
				INC(i)
			END;
			Str("END "); Str(modName); Ch(".")
		ELSE
			Str("Module "); Str(modName); Str(" not found"); ToLog
		END
	END Commands;
	


	(* *************** INTERFACE *************** *)

	PROCEDURE SetOptions;	(* parses variable options and sets corresponding 'flags' *)
		VAR i: INTEGER;
	BEGIN
		expandTypes:= FALSE; showAdr:= FALSE; i:= 0;
		WHILE options[i] # 0X DO
			IF options[i] = "x" THEN expandTypes:= TRUE
			ELSIF options[i] = "d" THEN showAdr:= TRUE
			END;
			INC(i)
		END
	END SetOptions;

	(** converts a symbol file *)
	PROCEDURE ShowDef*(VAR mod: ARRAY OF CHAR; T: Texts.Text);
	BEGIN
		SetOptions;
		Str("reading "); Str(mod); Ln; ToLog;
		IF ReadSym(mod) THEN 
			showObj := FALSE;
			WriteDef; MakeText(T)
		END;
		curObj:=NIL; OPU.Collect;
	END ShowDef;

	(** converts import definitions *)
	PROCEDURE ShowImports*(VAR mod: ARRAY OF CHAR; T: Texts.Text);	(** non-portable *)
	BEGIN	showImps:=TRUE;
		SetOptions;
		Str("reading "); Str(mod); Ln; ToLog;
		showObj := FALSE;
		WriteImports(mod); MakeText(T);
		showImps:=FALSE; curObj:=NIL; OPU.Collect;
	END ShowImports;

	PROCEDURE QualIdent (VAR qualifier, identifier: ARRAY OF CHAR);
	(* separates module and object name *)
		VAR i, j: INTEGER;
	BEGIN
		i := 0; j := 0;
		WHILE (qualifier[i] # ".") & (qualifier[i] # 0X) DO INC(i) END;
		qualifier[i] := 0X; INC(i); j := 0; 
		WHILE qualifier[i] # 0X DO identifier[j] := qualifier[i]; INC(i); INC(j) END;
		identifier[j] := 0X
	END QualIdent;

	PROCEDURE DecorateExpMod(path, name: ARRAY OF CHAR; time, date, size: LONGINT; isdir: BOOLEAN);
		VAR dummy: ARRAY 24 OF CHAR;
	BEGIN	IF ~isdir THEN QualIdent(name, dummy); OPU.DecorateExpMod(name); Str("."); ToLog END
	END DecorateExpMod;

	(** initializes a process to find all client-objects of a module *)
	PROCEDURE ShowExpInit*(VAR mod: ARRAY OF CHAR): BOOLEAN;	(** non-portable *)
		VAR m: OPU.Module;
	BEGIN showExports:=TRUE; SetOptions; Str("reading "); Str(mod); Ln; ToLog;
		m:=OPU.DecorateExpInit(mod); RETURN m#NIL
	END ShowExpInit;

	(** checks and decorates a module if it imports any objects of a server module (specified in ShowExportsInit) *)
	PROCEDURE ShowExpDecorate*(VAR mod: ARRAY OF CHAR);	(** non-portable *)
	BEGIN
		IF mod="all" THEN FileDir.EnumerateFiles("", "*.Obj", FALSE, DecorateExpMod) 
		ELSE OPU.DecorateExpMod(mod); Str("."); ToLog END
	END ShowExpDecorate;

	(** shows the result of the previous calls to ShowExpInit and ShowExpDecorate *)
	PROCEDURE ShowExports*(T: Texts.Text);	(** non-portable *)
	BEGIN OPU.DecorateExpDone;
		GroupTypes(OPT.modules[1].right); 
		showObj := FALSE;
		WriteDef; MakeText(T);
		curObj:=NIL; OPU.Collect; showExports:=FALSE;
		Ln; ToLog
	END ShowExports;

	(** converts a symbol file, only shows the desired object *)
	PROCEDURE ShowObj*(VAR mod, objName: ARRAY OF CHAR; T: Texts.Text);
		VAR obj, pObj: OPT.Object;
	BEGIN
		SetOptions; Str("reading "); Str(mod); Ln; ToLog;
		IF ReadSym(mod) THEN
			Find(objName, obj);
			IF obj # NIL THEN 
				IF obj.vis < 0 THEN (* is a pair of types *)
					FindPointer(obj.name, pObj);	(* look for a corresponding pointer *)
					IF pObj # NIL THEN obj:= pObj; COPY(obj.name, objName) END
				END;
				showObj := TRUE; first := TRUE;
				WriteObject(obj, 1, obj.mode, FALSE); MakeText(T)
			ELSE Str("-- '"); Str(objName); Str("' not found"); Ln; ToLog;
			END
		END;
		curObj:=NIL; OPU.Collect
	END ShowObj;

	(** converts an object file and extracts commands *)
	PROCEDURE ShowCmd*(VAR file: ARRAY OF CHAR;  T: Texts.Text);
	BEGIN
		SetOptions; 
		Str("reading "); Str(file); Ln; ToLog;
		Commands(file); Texts.Append(T, W.buf)
	END ShowCmd;

	PROCEDURE EnumModule(path, name: ARRAY OF CHAR; time, date, size: LONGINT; isdir: BOOLEAN);
		VAR mod: OPU.Module; dummy: ARRAY 24 OF CHAR;
	BEGIN
		IF ~isdir THEN QualIdent(name, dummy); mod := OPU.CheckMod(name, TRUE); Str("."); ToLog END
	END EnumModule;

	(** checks if the specified module is consistent *)
	PROCEDURE CheckMod*(VAR name: ARRAY OF CHAR;  deep: BOOLEAN);	(** non-portable *)
		VAR mod: OPU.Module;
	BEGIN	
		IF name="all" THEN FileDir.EnumerateFiles("", "*.Obj", FALSE, EnumModule);
		ELSE mod:=OPU.CheckMod(name, deep);
			IF (mod=NIL) THEN Str(name); Ch(9X); Str("module not found"); Ln ELSE Str(".") END;
			ToLog
		END
	END CheckMod;
		
	(** shows the result of previous calls to CheckMod *)
	PROCEDURE ShowConsistency*(T: Texts.Text);	(** non-portable *)
		VAR mod: OPU.Module; 
	BEGIN
		mod:=OPU.modList;
		WHILE mod#NIL DO
			IF mod.mark THEN	
				IF mod.res # 0 THEN Texts.SetFont(W, boldFont) ELSE Texts.SetFont(W, Fonts.Default) END;
				Texts.SetColor(W, ImportCol); Str(mod.name); 
				Texts.SetColor(W, TextCol); Control("", ImpCmd, mod.name);
				Ch(9X);
				CASE mod.type OF
				| OPU.MC68: Str("MC680x0 module");
				| OPU.PPC: Str("PowerPC module");
				| OPU.Intel: Str("Intel module");
				| OPU.Portable: Str("OMI module");
				| OPU.Loaded: Str("loaded module");
				ELSE
				END;
				IF mod.res # 0 THEN Ch(9X); Str("(inconsistent!!)") END;
				Ln;
				Texts.SetColor(W, TextCol);
			END;
			mod:=mod.link
		END;
		Texts.Append(T, W.buf);
		curObj:=NIL; OPU.Collect;
		Ln; ToLog;
	END ShowConsistency;


BEGIN
	Hex := "0123456789ABCDEF";
	Texts.OpenWriter(W); boldFont:=Fonts.This("Syntax10b.Scn.Fnt");
END Watson0.
