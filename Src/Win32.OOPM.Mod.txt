(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE OOPM; (** non-portable / source: Win32.OOPM.Mod *)	(* RC, NM 6.3.89 / 16.12.92 / 12.12.93 /changes in red by jm 14.12.94*)
(*
	code generator for Intel i386, i387/ i486 - Diplomarbeit ETH-Zürich WS 92/93
	by Niklaus Mannhart, 87-913-117I
	author's address: 	Himmelrich 22
		6340 Baar, Switzerland
		e-mail: mannhart@inf.ethz.ch	phone: +41 (0)42 31 40 33

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

	March the 2nd 1993
	Release 12.12.93 / Release 1.0
	Release 12.1.94 / Release 1.1 (fixed bugs in OOPL.LoadProc and floating point compare (OOPL.FloadCmp))
	jm 28.8.95 - compiler error positions are now emitted in a larger field.
*)

(* Machine dependent constants needed before code generation *)
(* Host interface *)

	IMPORT Modules, Texts, Oberon, Fonts, Files, FileDir, OPLO, SYSTEM;

	CONST (* i386 *)

		(* basic type sizes *)
		ByteSize* = 1;	(* SYSTEM.BYTE *)
		CharSize* = 1;	(* CHAR *)
		BoolSize* = 1;	(* BOOLEAN *)
		SetSize* = 4;	(* SET *)
		SIntSize* = 1;	(* SHORTINT *)
		IntSize* = 2;	(* INTEGER *)
		LIntSize* = 4;	(* LONGINT *)
		RealSize* = 4;	(* REAL *)
		LRealSize* = 8;	(* LONGREAL *)
		ProcSize* = 4;	(* PROCEDURE type *)
		PointerSize* = 4;	(* POINTER type *)

		(* value of constant NIL *)
		nilval* = 0;

		(* target machine minimum values of basic types expressed in host machine format: *)
		MinSInt* = -80H;
		MinInt* = -8000H;
		MinLInt* =  80000000H;	(* i386: -2147483648*)
		MinRealPat = 0FF7FFFFFH;	(* most  negative, 32-bit pattern *)
		MinLRealPatL = 0FFFFFFFFH;	(* most  negative, lower 32-bit pattern *)
		MinLRealPatH = 0FFEFFFFFH;	(* most  negative, higher 32-bit pattern *)

		(* target machine maximum values of basic types expressed in host machine format: *)
		MaxSInt* = 7FH;
		MaxInt* = 7FFFH;
		MaxLInt* = 7FFFFFFFH;	(* i386: 2147483647*)
		MaxSet* = 31;	(* must be >= 15, else the bootstraped compiler cannot run (IN-tests) *)
		MaxRealPat = 7F7FFFFFH;	(* most positive, 32-bit pattern *)
		MaxLRealPatL = 0FFFFFFFFH;	(* most positive, lower 32-bit pattern *)
		MaxLRealPatH = 7FEFFFFFH;		(* most positive, higher 32-bit pattern *)

		(* maximal index value for array declaration: *)
		MaxIndex* = MaxLInt;

		(* parametrization of numeric scanner: *)
		MaxHDig* = 8;	(* maximal hexadecimal longint length *)
		MaxRExp* = 38;	(* maximal real exponent *)
		MaxLExp* = 308;	(* maximal longreal exponent *)

		(* inclusive range of parameter of standard procedure HALT: *)
		MinHaltNr* = 25;
		MaxHaltNr* = MAX(LONGINT);

		(* inclusive range of register number of procedures SYSTEM.GETREG and SYSTEM.PUTREG: *)
		MinRegNr* = 0;	(* interpretation is left to the back-end, e.g. for i386: *)
		MaxRegNr* = 31;	(* F0-F7 if second parameter is REAL or LONGREAL, R0-R7 else *)

		(* maximal condition value of parameter of SYSTEM.CC: *)
		MaxCC* = -1;	(* not implemented interpretation is left to the back-end *)

		(* initialization of linkadr field in ObjDesc, must be different from any valid link address: *)
		LANotAlloc* = -1;

		(* initialization of constant address, must be different from any valid constant address: *)
		ConstNotAlloc* = -1;	(* i386: only strings are allocated *)

		(* initialization of tdadr field in StrDesc, must be different from any valid address: *)
		TDAdrUndef* = -1;

		(* maximal number of cases in a case statement: *)
		MaxCases* = 128;

		(* maximal range of a case statement (higher label - lower label ~ jump table size): *)
		MaxCaseRange* = 512;

		(* whether field leaf of pointer variable p has to be set to FALSE, when NEW(p) or SYSTEM.NEW(p, n) is used: *)
		NEWusingAdr* = FALSE;

		(* special character (< " ") returned by procedure Get, if end of text reached *)
		Eot* = 0X;

	VAR
		MinReal*, MaxReal*: REAL;
		MinLReal*, MaxLReal*: LONGREAL;
		noerr*: BOOLEAN;	(* no error found until now *)
		curpos*, errpos*: LONGINT;	(* character and error position in source file *)
		breakpc*: LONGINT;	(* set by OPV.Init *)
		breakpos*: LONGINT;	(* set by Mark *)
		outputPath*: FileDir.FileName;		
		options: SET; portable*: BOOLEAN;
		errName*: ARRAY 32 OF CHAR; 
		errors: Texts.Text;

	CONST
		OFtag = 0BBX;	(* object file tag *)
		OFnative = 055X;
		OFportable = 088X;

	VAR
		LRealPat: RECORD L, H: LONGINT END ;
		lastpos, pat, refpatch: LONGINT;	(* last position error in source file *)
		inR: Texts.Reader;
		Log: Texts.Text;
		W: Texts.Writer;
		RefF, ObjF, ModF, SymF: Files.Rider;
		RefFile, ObjFile, ModFile, SymFile: Files.File;
		ObjFName: FileDir.FileName;
		nopath: ARRAY 2 OF CHAR;

	PROCEDURE Init*(opt: SET; source: Texts.Reader; log: Texts.Text);
		CONST portblOpt = 17;
	BEGIN inR := source; Log := log; options := opt; portable := portblOpt IN opt;
		noerr := TRUE; curpos := Texts.Pos(inR); errpos := curpos; lastpos := curpos-10
	END Init;

	PROCEDURE Get*(VAR ch: CHAR);	(* read next character from source text, Eot if no more *)
	BEGIN
		REPEAT
			Texts.Read(inR, ch); INC(curpos)
		UNTIL inR.eot OR ((inR.lib # NIL) & (inR.lib IS Fonts.Font))
	END Get;

	PROCEDURE SetFileName(VAR path, modName, fileName: ARRAY OF CHAR);
		VAR i, j: INTEGER; ch: CHAR;
	BEGIN	i:=0; ch:=path[0];
		WHILE	ch#0X	DO	fileName[i]:=ch; INC(i); ch:=path[i]	END;
		IF (i # 0) & (path[i-1] # FileDir.PathChar) THEN fileName[i] := FileDir.PathChar; INC(i) END;
		j:=0; ch:=modName[0];
		WHILE	ch#0X	DO	fileName[i]:=ch; INC(i); INC(j); ch:=modName[j]	END;
		fileName[i]:="."; fileName[i+1]:="O"; fileName[i+2]:="b"; fileName[i+3]:="j"; fileName[i+4]:=0X
	END SetFileName;

	(* ----- Fingerprint calculation ----- *)

	PROCEDURE FPrint*(VAR fp: LONGINT; val: LONGINT);
	BEGIN fp:=SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, SYSTEM.ROT(fp, 7)) / SYSTEM.VAL(SET, val))
	END FPrint;

	PROCEDURE FPrintSet*(VAR fp: LONGINT; set: SET);
	BEGIN FPrint(fp, SYSTEM.VAL(LONGINT, set))
	END FPrintSet;

	PROCEDURE FPrintReal*(VAR fp: LONGINT; real: REAL);
	BEGIN FPrint(fp, SYSTEM.VAL(LONGINT, real))
	END FPrintReal;

	PROCEDURE FPrintLReal*(VAR fp: LONGINT; lr: LONGREAL);
		VAR l, h: LONGINT;
	BEGIN
		SYSTEM.GET(SYSTEM.ADR(lr)+4, l); SYSTEM.GET(SYSTEM.ADR(lr), h);
		FPrint(fp, l); FPrint(fp, h);
	END FPrintLReal;
	
	(* ----- auxiliaries ----- *)

	PROCEDURE WString(VAR R: Files.Rider; VAR s: ARRAY OF CHAR);
		VAR i: INTEGER; ch: CHAR;
	BEGIN	i:=0; ch:=s[0];
		IF	ch=0X	THEN	Files.Write(R, 0X); RETURN	END;
		WHILE	(ch#0X) & (ch<7FX)	DO	INC(i); ch:=s[i]	END;
		IF	i>1	THEN	Files.WriteBytes(R, s, i-1)	END;
		IF	ch=0X	THEN	Files.Write(R, CHR(ORD(s[i-1])+80H))
		ELSE	
			IF	i>0	THEN	Files.Write(R, s[i-1])	END;
			Files.Write(R, 7FX); REPEAT	Files.Write(R, ch); INC(i); ch:=s[i]	UNTIL ch=0X;
			Files.Write(R, 0X)
		END
	END WString;

	(* ------------------------- Log Output ------------------------- *)

	PROCEDURE LogW*(ch: CHAR);
	BEGIN
		Texts.Write(W, ch); Texts.Append(Log, W.buf)
	END LogW;

	PROCEDURE LogWStr*(s: ARRAY OF CHAR);
	BEGIN
		Texts.WriteString(W, s); Texts.Append(Log, W.buf)
	END LogWStr;

	PROCEDURE LogWNum*(i, len: LONGINT);
	BEGIN
		Texts.WriteInt(W, i, len); Texts.Append(Log, W.buf)
	END LogWNum;

	PROCEDURE LogWHex*(i: LONGINT);
	BEGIN	Texts.WriteHex(W, i); Texts.Write(W, "H"); Texts.Append(Log, W.buf)
	END LogWHex;

	PROCEDURE LogWLn*;
	BEGIN
		Texts.WriteLn(W); Texts.Append(Log, W.buf)
	END LogWLn;

	PROCEDURE LogErrorMsg*(err: INTEGER);
		VAR
			S: Texts.Scanner;
			R: Texts.Reader;
			ch: CHAR;
	BEGIN
		LogWNum(err, 4);
		Texts.OpenScanner(S, errors, 0); Texts.Scan(S);
		WHILE ~S.eot & ~((S.class = Texts.Int) & (S.i = err) & (S.nextCh = 09X)) DO
			Texts.Scan(S)
		END;
		IF (S.class = Texts.Int) & (S.i = err) & (S.nextCh = 09X) THEN
			Texts.Write(W, 09X);
			Texts.OpenReader(R, errors, Texts.Pos(S));
			Texts.Read(R, ch);
			WHILE ~R.eot & (ch # 0DX) DO
				Texts.Write(W, ch); Texts.Read(R, ch)
			END;
			Texts.Append(Log, W.buf)
		END
	END LogErrorMsg;

	PROCEDURE Mark*(n: INTEGER; pos: LONGINT);
		CONST warning = 12;
	BEGIN
		IF n >= 0 THEN
			noerr := FALSE;
			IF (pos < lastpos) OR (lastpos + 9 < pos) OR (n>=450) & (n<=460) OR (n=155) THEN lastpos := pos;
				LogWLn; LogW(9X); LogW(9X);
				IF (n<450) OR (n>460) THEN
					LogWStr("pos"); LogWNum(pos, 7);
					IF n = 255 THEN LogWStr("  pc "); LogWHex(breakpc); breakpos := pos
					ELSIF n = 254 THEN LogWStr("  pc not found")
					ELSE LogWStr("  err"); LogErrorMsg(n)
					END
				ELSE LogWStr(errName);
					IF	n=450	THEN	LogWStr(" is no longer visible")
					ELSIF	n=451	THEN	LogWStr(" is new")
					ELSIF	n=452	THEN	LogWStr(" is redefined")
					END
				END
			END
		ELSIF warning IN options THEN
			LogWLn; LogW(9X); LogW(9X); LogWStr("pos"); LogWNum(pos, 7); LogWStr("  warning"); LogErrorMsg(-n)
		END
	END Mark;
	
	PROCEDURE err*(n: INTEGER);
	BEGIN Mark(n, errpos)
	END err;

	PROCEDURE error*(n: INTEGER);
	BEGIN
		LogWStr("error "); LogErrorMsg(n); LogWLn()
	END error;

	(* ----- sym output ----- *)
	
	PROCEDURE SymW*(b: CHAR);
	BEGIN	Files.Write(SymF, b)
	END SymW;

	PROCEDURE SymWNum*(i: LONGINT);
	BEGIN	Files.WriteNum(SymF, i)
	END SymWNum;

	PROCEDURE SymWPos*():LONGINT;
	BEGIN RETURN Files.Pos(SymF)+Files.Pos(ModF);
	END SymWPos;

	PROCEDURE SymWMod*(VAR name: ARRAY OF CHAR);
	BEGIN  WString(ModF, name)
	END SymWMod;

	PROCEDURE SymWSet*(s: SET);
	BEGIN	Files.WriteNum(SymF, SYSTEM.VAL(LONGINT, s))
	END SymWSet;

	PROCEDURE SymWReal*(VAR r: LONGREAL);
		VAR sr: REAL;
	BEGIN	sr:=SHORT(r); Files.WriteReal(SymF, sr)
	END SymWReal;

	PROCEDURE SymWLReal*(VAR r: LONGREAL);
	BEGIN	Files.WriteLReal(SymF, r)
	END SymWLReal;

	PROCEDURE SymWString*(VAR s: ARRAY OF CHAR);
	BEGIN	WString(SymF, s)
	END SymWString;

	(* ----- ref output ----- *)

	PROCEDURE RefW*(ch: CHAR);
	BEGIN Files.Write(RefF, ch)
	END RefW;

	PROCEDURE RefWNum* (i: LONGINT);
	BEGIN
		Files.WriteNum(RefF, i)
	END RefWNum;

	PROCEDURE ObjW*(ch: CHAR);
	BEGIN Files.Write(ObjF, ch)
	END ObjW;

	PROCEDURE ObjWInt*(i: INTEGER);
	BEGIN Files.WriteBytes(ObjF, i, 2)
	END ObjWInt;

	PROCEDURE ObjWLInt*(i: LONGINT);
	BEGIN Files.WriteBytes(ObjF, i, 4)
	END ObjWLInt;

	PROCEDURE ObjWBytes*(VAR bytes: ARRAY OF SYSTEM.BYTE; n: LONGINT);
	BEGIN Files.WriteBytes(ObjF, bytes, n)
	END ObjWBytes;

	PROCEDURE ObjWNum*(i: LONGINT);
	BEGIN	Files.WriteNum(ObjF, i)
	END ObjWNum;

	PROCEDURE ObjWString*(VAR s: ARRAY OF CHAR);
	BEGIN	WString(ObjF, s)
	END ObjWString;

	PROCEDURE ObjAllocInt*(): LONGINT;
		VAR pos: LONGINT;
	BEGIN	pos:=Files.Pos(ObjF); Files.WriteInt(ObjF, SYSTEM.VAL(INTEGER, 0));
		RETURN pos;
	END ObjAllocInt;

	PROCEDURE ObjFillInt*(pos: LONGINT; int: INTEGER);
		VAR savepos: LONGINT;
	BEGIN	savepos:=Files.Pos(ObjF);
		Files.Set(ObjF, ObjFile, pos); Files.WriteBytes(ObjF, int, 2);
		Files.Set(ObjF, ObjFile, savepos);
	END ObjFillInt;

	(* ----- files ----- *)

	PROCEDURE OpenSym*(VAR R: Files.Rider; VAR name: ARRAY OF CHAR; VAR done: BOOLEAN);
		VAR fileName: FileDir.FileName; ch, ch1: CHAR; symSize: LONGINT; F: Files.File;
	BEGIN
		SetFileName(nopath, name, fileName); 
		done := FALSE;
		F := Files.Old(fileName);
		IF F # NIL THEN
			Files.Set(R, F, 0); Files.Read(R, ch);
			IF ch=OFtag THEN Files.Read(R, ch1); Files.ReadNum(R, symSize);
				done := Modules.CheckName(F, name)
			ELSE (* eb, 30.11.95 err(511); *) done := FALSE
			END
		END
	END OpenSym;
	
	PROCEDURE Begin*(VAR modName: ARRAY OF CHAR);
	BEGIN	SetFileName(outputPath, modName, ObjFName);
		ObjFile:=Files.New(ObjFName); Files.Set(ObjF, ObjFile, 0); Files.Write(ObjF, OFtag);
		ModFile:=Files.New(""); Files.Set(ModF, ModFile, 0); 
		SymFile:=Files.New(""); Files.Set(SymF, SymFile, 0);
		RefFile := Files.New(""); Files.Set(RefF, RefFile, 0);
		IF portable THEN Files.Write(ObjF, OFportable) ELSE Files.Write(ObjF, OFnative) END;
	END Begin;

	PROCEDURE Commit(F: Files.File);
		VAR R: Files.Rider; buf: ARRAY 1024 OF CHAR;
	BEGIN
		Files.Set(R, F, 0); Files.ReadBytes(R, buf, 1024);
		WHILE ~R.eof DO
			Files.WriteBytes(ObjF, buf, 1024); Files.ReadBytes(R, buf, 1024)
		END;
		Files.WriteBytes(ObjF, buf, 1024-R.res)
	END Commit;

	PROCEDURE EndSym*;
		VAR sfsize: LONGINT;  
	BEGIN	Files.Write(ModF, 0X); 
		sfsize:=Files.Length(SymFile)+Files.Length(ModFile); Files.WriteNum(ObjF, sfsize);
		Commit(ModFile); Commit(SymFile);
		IF portable THEN ModFile:=Files.New(""); Files.Set(ModF, ModFile, 0); SymFile:=Files.New(""); Files.Set(SymF, SymFile, 0)
		ELSE refpatch:=Files.Pos(ObjF); ObjWInt(0); ObjWInt(0) END
	END EndSym;

	PROCEDURE EndObj*;
		VAR refsize: LONGINT;
	BEGIN
		IF portable THEN 
			Files.Write(ModF, 0X); Commit(ModFile); Files.Write(SymF, 0X); 
			Commit(SymFile); Files.Register(ObjFile)
		ELSE	
			refsize:=Files.Length(RefFile); ObjW(8DX); Commit(RefFile); 
			Files.Set(ObjF, ObjFile, refpatch); ObjWBytes(refsize, 4); 
			Files.Register(ObjFile)
		END
	END EndObj;
	
	PROCEDURE CloseObj*;
		VAR refsize: LONGINT;
	BEGIN (*ref block*)
		refsize:=Files.Length(RefFile);
		Commit(RefFile);
		Files.Set(ObjF, ObjFile, refpatch); ObjWBytes(refsize, 4);
		Files.Register(ObjFile)
	END CloseObj;

BEGIN
	OPLO.error := error; NEW(errors); Texts.Open(errors, "OberonErrors.Text");
	pat := MinRealPat; SYSTEM.MOVE(SYSTEM.ADR(pat), SYSTEM.ADR(MinReal), 4);	(*i386: -3.40282346E38*)
	pat := MaxRealPat; SYSTEM.MOVE(SYSTEM.ADR(pat), SYSTEM.ADR(MaxReal), 4);	(*i386: 3.40282346E38*)
	LRealPat.L := MinLRealPatL; LRealPat.H := MinLRealPatH;
	SYSTEM.MOVE(SYSTEM.ADR(LRealPat), SYSTEM.ADR(MinLReal), 8);	(*i386: -1.7976931348623157D308*)
	LRealPat.L := MaxLRealPatL; LRealPat.H := MaxLRealPatH;
	SYSTEM.MOVE(SYSTEM.ADR(LRealPat), SYSTEM.ADR(MaxLReal), 8);	(*i386: 1.7976931348623157D308*)
	Texts.OpenWriter(W); Log := Oberon.Log
END OOPM.
