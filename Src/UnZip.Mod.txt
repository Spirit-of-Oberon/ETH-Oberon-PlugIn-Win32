(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE UnZip; (** portable *)	(* *)
	IMPORT SYSTEM, Files, Objects, Strings, Display, Texts, Oberon, Attributes, Gadgets, TextGadgets, Documents, TextDocs,
		Desktops;

	CONST
		MaxBuffer = 16384;
		Menu = "UnZip.Open[Open] UnZip.OpenAscii[Ascii] UnZip.extract[Extract]";

	TYPE
		Node = POINTER TO NodeDesc;
		NodeDesc = RECORD
			zero, one: Node;
			val: LONGINT
		END;
		Code = RECORD
			val, len: LONGINT
		END;
		FileHeader = RECORD
			madeby, version, flag, method, time, date: INTEGER;
			crc32, compsize, uncompsize: LONGINT;
			namel, extral, commentl, disk, intattr: INTEGER;
			extattr, offset: LONGINT;
			fname: ARRAY 256 OF CHAR
		END;
							
		Entry* = POINTER TO EntryDesc;
		EntryDesc* = RECORD
			name*: ARRAY 256 OF CHAR;
			compsize*, uncompsize*: LONGINT;
			time*, date*, method*: INTEGER;
			next*: Entry;
			offsetdir: LONGINT;	(* offset in central dir *)
			offsetlocal: LONGINT;	(* offset del file header *)
			unsupp: INTEGER	(* is 0 only if Entry can be expanded *)
		END;

		Archive* = POINTER TO ArchiveDesc;
		ArchiveDesc* = RECORD
			File: Files.File;
			nofentries*: INTEGER;
			firstentry*: Entry
		END;
				
	VAR
		W: Texts.Writer;
		r1, r2: Files.Rider;
		F1, F2: Files.File;
		bufpos, uncompsize: LONGINT; 
		Buffer: ARRAY MaxBuffer OF CHAR;
		Dictionary: ARRAY 32*1024 OF CHAR;
		dictpos, dictsize, Posinbyte: LONGINT;	(* pos,size in Dictionary *)
		cycled, done: BOOLEAN; 		
		Sequence: ARRAY 19 OF LONGINT;

	PROCEDURE Init();
	BEGIN
		dictpos := 0; bufpos := 0;
		Posinbyte := 0;
		cycled := FALSE; done := FALSE
	END Init;

	PROCEDURE Copy(unsize: LONGINT);
		VAR counter: LONGINT;
	BEGIN
		counter := unsize;
		WHILE counter > 0 DO
			IF counter >= MaxBuffer THEN
				Files.ReadBytes(r1, Buffer, MaxBuffer);
				Files.WriteBytes(r2, Buffer, MaxBuffer)
			ELSE
				Files.ReadBytes(r1, Buffer, counter);
				Files.WriteBytes(r2, Buffer, counter)
			END;
			counter := counter-MaxBuffer
		END;
		Files.Register(F2)
	END Copy;

	PROCEDURE ReadBitsBuffer(n: LONGINT): LONGINT;
	(* Read n Bits from Buffer = from File *)
		VAR
			out, restdata, restsize: LONGINT;
			data: CHAR;
	BEGIN
		data := Buffer[bufpos]; out := ORD(data);
		out := SYSTEM.LSH(out, (32-n-Posinbyte));
		out := SYSTEM.LSH(out, (n-32));
		IF (8-Posinbyte) < n THEN	
			restsize := n-(8-Posinbyte);
			Posinbyte := 0; INC(bufpos);
			IF bufpos = MaxBuffer THEN
				Files.ReadBytes(r1, Buffer, MaxBuffer); bufpos := 0
			END;
			data := Buffer[bufpos]; restdata := ORD(data);
			restdata := SYSTEM.LSH(restdata, 32-restsize);
			restdata := SYSTEM.LSH(restdata, n-32);
			out := out+restdata; Posinbyte := restsize
		ELSE
			Posinbyte := (Posinbyte+n) MOD 8;
			IF Posinbyte = 0 THEN INC(bufpos) END
		END;
		IF bufpos = MaxBuffer THEN
			Files.ReadBytes(r1, Buffer, MaxBuffer); bufpos := 0
		END;
		RETURN out
	END ReadBitsBuffer;

	PROCEDURE InsertDict(data: CHAR);
	(* Insert data in Dictionary *)
	BEGIN
		IF ~cycled & (dictpos=dictsize-1) THEN cycled := TRUE END;
		Dictionary[dictpos] := data;
		dictpos := (dictpos+1) MOD dictsize
	END InsertDict;

	PROCEDURE ReadDict(Distance, Length: LONGINT);
	(* Read LENGTH Bytes at Distance DISTANCE in Dictionary= Output Stream *)
		VAR position, i: LONGINT;
	BEGIN
		i := 0; position := dictpos-Distance;
		IF ~cycled & (position < 0) THEN
			WHILE position<0 DO
				InsertDict(CHR(0));
				INC(position);
				Files.Write(r2, CHR(0))
			END
		ELSE
			position := position MOD dictsize;
			WHILE i < Length DO
				Files.Write(r2, Dictionary[position]);
				IF Files.Pos(r2) = uncompsize THEN done:=TRUE END;
				InsertDict(Dictionary[position]);
				position := (position+1) MOD dictsize;
				INC(i)
			END
		END
	END ReadDict;

	PROCEDURE BuildCode(VAR Codes: ARRAY OF Code; NofCodes, flag: LONGINT): Node;
		(* Build Code (Codes.val) with Codes.Len and return root of tree *)	
		(* 0=Implode 1=Deflate *) 
		VAR
			i, j, this, MyCode, len, bits, maxbits, last, inc: LONGINT;
			n, cur, root: Node; 
			blcount, nextcode: ARRAY 300 OF LONGINT;
			Implode, double: BOOLEAN;
	BEGIN
		Implode := FALSE; IF flag=0 THEN Implode:=TRUE END;
		maxbits := 0;
		FOR i := 0 TO NofCodes-1 DO blcount[i] := 0 END;
		FOR i := 0 TO NofCodes-1 DO
			INC(blcount[Codes[i].len]);
			IF Codes[i].len > maxbits THEN maxbits := Codes[i].len END
		END;
		MyCode:=0;
		FOR bits := 1 TO maxbits DO
			MyCode := (MyCode+blcount[bits-1])*2;
			nextcode[bits] := MyCode
		END;
		FOR i := 0 TO NofCodes-1 DO
			len := Codes[i].len;
			IF len # 0 THEN 
				Codes[i].val:=nextcode[len];
				INC(nextcode[len])
			ELSE
				Codes[i].val := -1
			END;
		END;	
		(* Codes.val is code to be inserted in tree *)
		last := 5; inc := 2; double := TRUE;
		NEW(n); n.zero := NIL; n.one := NIL; n.val := -1;
		root := n;
		FOR i := 0 TO NofCodes-1 DO
			n := root; j := 0; this := Codes[i].val;					
			IF this # -1 THEN	
				WHILE j < Codes[i].len DO			
		 			IF (Implode & ~SYSTEM.BIT(SYSTEM.ADR(this), Codes[i].len-j-1)) OR
		 				(~Implode & SYSTEM.BIT(SYSTEM.ADR(this), Codes[i].len-j-1)) THEN 
						IF n.one = NIL THEN
							NEW(cur);
							cur.one := NIL; cur.zero := NIL;
							cur.val := -1; n.one := cur;
							n := cur
						ELSE
							n:=n.one
						END				
					ELSIF n.zero = NIL THEN								
						NEW(cur);
						cur.zero := NIL; cur.one := NIL;
						cur.val := -1; n.zero := cur;
						n:=cur
					ELSE
						n := n.zero
					END;
					INC(j)
				END; (*WHILE*)
				cur.val := i	
			END
		END; (* FOR *)
		RETURN root						
	END BuildCode;

	PROCEDURE Implode(flags, unsize: LONGINT): LONGINT;
		VAR
			toMe, nofCodes, lengthofThis, nofThis, i, j, k, l: LONGINT;
			nofTrees, minMatch, lowDist, Distance, Length: LONGINT;
			bit, literal: LONGINT;
			LiteralTree, LengthTree, DistanceTree, cur: Node;
			Codes:ARRAY 256 OF Code;
			lung, data, res, byte: CHAR;
	BEGIN
		uncompsize := unsize; 
		IF ODD(flags DIV 2) THEN 
			dictsize := 8*1024
		ELSE
			dictsize := 4*1024
		END;
		IF ODD(flags DIV 4) THEN
			nofTrees := 3; minMatch := 3
		ELSE
			nofTrees := 2; minMatch := 2
		END; 
		FOR l := nofTrees TO 1 BY -1 DO
			k := 0; Files.Read(r1, lung); 
			nofCodes := ORD(lung);
			FOR i := 0 TO nofCodes  DO
				Files.Read(r1, data);
				lengthofThis := (ORD(data) MOD 16)+1;
				nofThis := (ORD(data) DIV 16)+1;	
				FOR j := 1 TO nofThis DO
					Codes[k].len := lengthofThis; INC(k)
				END
			END;
			CASE l OF
				3: LiteralTree:=BuildCode(Codes, k, 0);
				|2: LengthTree:=BuildCode(Codes, k, 0);
				|1:DistanceTree:=BuildCode(Codes, k, 0)
			ELSE
				RETURN 10
			END	 	
		END;
		(* Begin Decoding *)
		Files.ReadBytes(r1, Buffer, MaxBuffer); bufpos := 0;
		LOOP  
			IF done THEN EXIT END;
			literal := ReadBitsBuffer(1);
			IF literal = 1 THEN
				IF nofTrees = 3 THEN
					cur := LiteralTree;
					WHILE cur.val = -1 DO
						bit := ReadBitsBuffer(1);
						IF bit = 1 THEN
							IF cur.one # NIL THEN
								cur:=cur.one
							ELSE 
								RETURN 10 
							END
						ELSE
							IF cur.zero # NIL THEN
								cur := cur.zero 
							ELSE
								RETURN 10
							END
						END
					END;
					res := CHR(cur.val)
				ELSE  
					res := CHR(ReadBitsBuffer(8))	
				END;	
				Files.Write(r2, res);
				IF Files.Pos(r2) = uncompsize THEN done := TRUE END;
				InsertDict(res)
			ELSE (* not literal *) 
				(* read lower 6 or 7 bits of distance offset *)
				IF dictsize = 8*1024 THEN toMe := 6 ELSE toMe := 5 END;
				lowDist := 0;
				FOR i := 0 TO toMe DO
					bit := ReadBitsBuffer(1);
					lowDist := lowDist+SYSTEM.LSH(bit, i)
				END;
				(* read and decode upper 6 bits *)
				cur := DistanceTree;
				WHILE cur.val = -1 DO
					bit := ReadBitsBuffer(1);
					IF bit = 1 THEN
						IF cur.one = NIL THEN 
  	     	 			RETURN 10 
						ELSE
		   				cur := cur.one
						END
					ELSE
						IF cur.zero = NIL THEN 
  	     	 			RETURN 10 
						ELSE
							cur := cur.zero
						END
					END
				END;
				IF dictsize = 8*1024 THEN 
					Distance := SYSTEM.LSH(cur.val, 7)+lowDist
				ELSE
					Distance := SYSTEM.LSH(cur.val, 6)+lowDist
				END;
				(* read and decode Length Value *)
				cur := LengthTree;
				WHILE cur.val = -1 DO
					bit := ReadBitsBuffer(1);
					IF bit = 1 THEN
						IF cur.one = NIL THEN
  	     	 			RETURN 10
						ELSE
	   					cur := cur.one
						END
					ELSE
						IF cur.zero = NIL THEN
		  	     	 	RETURN 10 
						ELSE
	 						cur := cur.zero
						END
					END
				END;
				Length := cur.val;
				Length := Length+minMatch;
				IF Length = 63+minMatch	THEN
					byte := CHR(ReadBitsBuffer(8)); 
					Length := Length+ORD(byte)
				END;
				ReadDict(Distance+1, Length)
			END
		END;
		Files.Register(F2); Files.Close(F2);
		RETURN 0
	END Implode;

	PROCEDURE MakeCodesDynHuff(VAR Codes: ARRAY OF Code; nofCodeLengths: LONGINT; CodeTree: Node): LONGINT;
	(* Build Codes.len with CodeTree *)
		VAR
			k, l, bit, code, times, lastcodelength: LONGINT;
			cur: Node;
	BEGIN
		k := 0;
		WHILE k < nofCodeLengths DO
			cur := CodeTree;
			WHILE cur.val = -1 DO
				bit := ReadBitsBuffer(1);
				IF bit = 1 THEN
					IF cur.one = NIL THEN 
	  	     	 	RETURN 10 
					ELSE
						cur := cur.one
					END
				ELSE
					IF cur.zero = NIL THEN 
	  	     	 	RETURN 10
					ELSE
						cur := cur.zero
					END
				END
			END; (* WHILE *)
			code := cur.val;
			IF (0 <= code) & (code <= 15) THEN 
				Codes[k].len := code;
				lastcodelength := code; INC(k)
			ELSIF code = 16 THEN
				times := ReadBitsBuffer(2); 
				FOR l := 1 TO times+3 DO
					Codes[k].len := lastcodelength; INC(k)
				END
			ELSIF code = 17 THEN 
				times := ReadBitsBuffer(3); 
				FOR l := 1 TO times+3 DO
					Codes[k].len := 0; INC(k)
				END
			ELSIF code = 18 THEN 
				times := ReadBitsBuffer(7);
				FOR l := 1 TO times+11 DO
					Codes[k].len := 0; INC(k)
				END
			ELSE
				RETURN 10 (* Invalid Length Code *)
			END (* IF *)
		END; (* WHILE *)
		RETURN 0
	END MakeCodesDynHuff;

	PROCEDURE DynamicHuff(VAR LitTree, DistTree: Node): LONGINT;
		VAR
			HLIT, HDLIST, HCLEN, nofCodes, res, i: LONGINT;
			Codes:ARRAY 300 OF Code;
			CodeTree:Node; 
	BEGIN
		HLIT :=ReadBitsBuffer(5)+257;
		HDLIST := ReadBitsBuffer(5)+1;
		HCLEN := ReadBitsBuffer(4)+4;
		FOR i := 0 TO HCLEN-1 DO
			Codes[Sequence[i]].len := ReadBitsBuffer(3)
		END;
		FOR i := HCLEN TO 18 DO	(* Others Codes.Length = 0 *)
			Codes[Sequence[i]].len := 0
		END;
		(* Build Codes Code *)
		nofCodes := 19;
		CodeTree := BuildCode(Codes, nofCodes, 1);
		(* Build input for Literal/Length Tree *)
		res := MakeCodesDynHuff(Codes, HLIT, CodeTree);
		IF res # 0 THEN RETURN res END;
		(* Build Literal/Length Tree *)
		nofCodes := HLIT;
		LitTree := BuildCode(Codes, nofCodes, 1);
		(* Build input for Distance Tree *)
		res := MakeCodesDynHuff(Codes, HDLIST, CodeTree);
		IF res # 0 THEN RETURN res END;
		(* Build Distance Tree *)
		nofCodes := HDLIST;
		DistTree := BuildCode(Codes, nofCodes, 1);
		RETURN 0
	END DynamicHuff;

	PROCEDURE Deflate(Flags, unsize: LONGINT): LONGINT;
		VAR
			Codes: ARRAY 300 OF Code;
			cur, DistanceTreeFix, LiteralTreeFix, DistTree, LitTree: Node;
			bit, Distance, Length, dummy, data: LONGINT;
			res, i, blockl, blocklcompl: LONGINT;
			value: CHAR;
			last: BOOLEAN;
	BEGIN
		uncompsize := unsize; dictsize := -32768;
		FOR i := 0 TO 143 DO Codes[i].len := 8 END;
		FOR i := 144 TO 255 DO Codes[i].len := 9  END;
		FOR i := 256 TO 279 DO Codes[i].len := 7  END;
		FOR i := 280 TO 287 DO Codes[i].len := 8  END;
		LiteralTreeFix := BuildCode(Codes, i, 1);
		FOR i := 0 TO 31 DO Codes[i].len := 5 END;
		DistanceTreeFix := BuildCode(Codes, i, 2);
		Files.ReadBytes(r1, Buffer, MaxBuffer);
		bufpos := 0; last := FALSE; 
		WHILE ~last DO 
			data := ReadBitsBuffer(1);
			IF data = 1 THEN last := TRUE END;
			data := ReadBitsBuffer(2);
			IF data = 0 THEN
				dummy := ReadBitsBuffer(5);	(* skip *)
				data := ReadBitsBuffer(8);
				blockl := ReadBitsBuffer(8)+256*data;
				data := ReadBitsBuffer(8);
				blocklcompl := ReadBitsBuffer(8)+256*data;
				WHILE blockl > 0 DO
					DEC(blockl);
					data := ReadBitsBuffer(8);
					InsertDict(CHR(data));
					Files.Write(r2, CHR(data))
				END
			ELSIF data # 3 THEN
				IF data = 2 THEN
					res := DynamicHuff(LitTree, DistTree);
					IF res # 0 THEN RETURN res END
				ELSE 
					(* data=1 Fixed Huffman *);  
					LitTree := LiteralTreeFix;
					DistTree := DistanceTreeFix
				END;
				LOOP 
					cur := LitTree;
					WHILE cur.val = -1 DO
						bit := ReadBitsBuffer(1);	
						IF bit = 1 THEN
							IF cur.one = NIL THEN 
								RETURN 10
							ELSE
								cur := cur.one
							END
						ELSE
							IF cur.zero = NIL THEN 
								RETURN 10
							ELSE
								cur := cur.zero
							END
						END
					END;	(* WHILE *)
					IF cur.val < 256 THEN
						value := CHR(cur.val);
						Files.Write(r2, value);
						InsertDict(value)
					ELSIF cur.val=256 THEN
						EXIT 
					ELSE	(* value = 257...285*)
						Length:=cur.val;
						CASE Length OF
							257..264: Length := Length-254 (* DO NOTHING *)
							|265..268: Length := (Length-265)*2+11+ReadBitsBuffer(1)
							|269..272: Length := (Length-269)*4+19+ReadBitsBuffer(2)
							|273..276: Length := (Length-273)*8+35+ReadBitsBuffer(3)
							|277..280: Length := (Length-277)*16+67+ReadBitsBuffer(4)
							|281..284: Length := (Length-281)*32+131+ReadBitsBuffer(5)
							|285: Length :=258
						ELSE
							RETURN 10
						END; (* CASE *)
						cur := DistTree;
						WHILE cur.val = -1 DO
							bit := ReadBitsBuffer(1);	
							IF bit = 1 THEN
								IF cur.one = NIL THEN 
									RETURN 10
								ELSE
									cur := cur.one
								END
							ELSE
								IF cur.zero = NIL THEN 
									RETURN 10 
								ELSE
									cur := cur.zero
								END;
							END;
						END; (* WHILE *)
						Distance := cur.val;
						CASE Distance OF
							0..3: Distance := cur.val+1
							|4..5: Distance := 5+(Distance-4)*2+ReadBitsBuffer(1)
							|6..7: Distance := 9+(Distance-6)*4+ReadBitsBuffer(2)
							|8..9: Distance := 17+(Distance-8)*8+ReadBitsBuffer(3)
							|10..11: Distance := 33+(Distance-10)*16+ReadBitsBuffer(4)
							|12..13: Distance := 65+(Distance-12)*32+ReadBitsBuffer(5)
							|14..15: Distance := 129+(Distance-14)*64+ReadBitsBuffer(6)
							|16..17: Distance := 257+(Distance-16)*128+ReadBitsBuffer(7)
							|18..19: Distance := 513+(Distance-18)*256+ReadBitsBuffer(8)
							|20..21: Distance := 1025+(Distance-20)*512+ReadBitsBuffer(8)+256*ReadBitsBuffer(1)
							|22..23: Distance := 2049+(Distance-22)*1024+ReadBitsBuffer(8)+256*ReadBitsBuffer(2)
							|24..25: Distance := 4097+(Distance-24)*2048+ReadBitsBuffer(8)+256*ReadBitsBuffer(3)
							|26..27: Distance := 8193+(Distance-26)*4096+ReadBitsBuffer(8)+256*ReadBitsBuffer(4)
							|28..29: Distance := 16385+(Distance-28)*8192+ReadBitsBuffer(8)+256*ReadBitsBuffer(5)
						ELSE
							RETURN 10
						END; (* CASE *)
						ReadDict(Distance, Length)
					END (* IF*)
				END (* LOOP *)
			ELSE 
				RETURN 10
			END;
		END;
		Files.Register(F2); Files.Close(F2);
		RETURN 0
	END Deflate;

	PROCEDURE ReadFileHeader(VAR header: FileHeader; VAR r1: Files.Rider);
		VAR
			i, j: LONGINT;
			ch: CHAR;
	BEGIN
		Files.ReadInt(r1, header.madeby);
		Files.ReadInt(r1, header.version);
		Files.ReadInt(r1, header.flag);
		Files.ReadInt(r1, header.method);
		Files.ReadInt(r1, header.time);
		Files.ReadInt(r1, header.date);
		Files.ReadLInt(r1, header.crc32);
		Files.ReadLInt(r1, header.compsize);
		Files.ReadLInt(r1, header.uncompsize);
		Files.ReadInt(r1, header.namel);
		Files.ReadInt(r1, header.extral);
		Files.ReadInt(r1, header.commentl);
		Files.ReadInt(r1, header.disk);
		Files.ReadInt(r1, header.intattr);
		Files.ReadLInt(r1,header.extattr);
		Files.ReadLInt(r1, header.offset);
		i := header.namel; j := 0;
		Files.Read(r1, ch);
		WHILE ~r1.eof & (i > 0) & (ch # 0X) (* (ch > " ") & (ch < CHR(127)) *) DO
			IF j < (LEN(header.fname)-1) THEN
				header.fname[j] := ch; INC(j)
			END;
			Files.Read(r1, ch); DEC(i)
		END;
		header.fname[j] := 0X
	END ReadFileHeader;

	PROCEDURE OpenArchive*(name: ARRAY OF CHAR; VAR res: LONGINT): Archive;
		VAR
			sig, pos:LONGINT;
			F1: Files.File;
			r1: Files.Rider;
			ThisArchive: Archive;
			header: FileHeader;
			NewEntry, ActEntry: Entry;
			dummy: INTEGER;
			first: BOOLEAN;
	BEGIN   
		sig := 0; first := TRUE; res := 99;
		F1 := Files.Old(name);
		IF F1 # NIL THEN 
			Files.Set(r1, F1, Files.Length(F1)-17);
			WHILE (sig # 06054B50H) & (Files.Pos(r1) > 4) DO
				Files.Set(r1, F1, Files.Pos(r1)-5); 
				 Files.ReadLInt(r1, sig)			
			END;
			IF sig = 06054B50H THEN
				Files.ReadInt(r1, dummy);
				Files.ReadInt(r1, dummy);
				Files.ReadInt(r1, dummy);
				NEW(ThisArchive);
				Files.ReadInt(r1, ThisArchive.nofentries);
				ThisArchive.File := F1; ThisArchive.firstentry := NIL;
				NEW(ActEntry);		
				LOOP 
					sig := 0;
					WHILE (sig # 02014B50H) & (sig # 04034B50H) & (Files.Pos(r1) > 4) DO
						Files.Set(r1, F1, Files.Pos(r1)-5);
						Files.ReadLInt(r1, sig)
					END; (* WHILE *)
					IF sig = 04034B50H THEN 
						IF first THEN
							res := 3
						ELSE
							res := 0
						END;
						EXIT 
					ELSIF sig # 02014B50H THEN
						res := 3
					END;	
					IF first THEN first := FALSE END;				
					pos := Files.Pos(r1); ReadFileHeader(header, r1); Files.Set(r1, F1, pos);
					NEW(NewEntry); NewEntry.next := NIL;
					NewEntry.offsetdir := Files.Pos(r1)-1; NewEntry.offsetlocal := header.offset;
					NewEntry.compsize := header.compsize; NewEntry.uncompsize := header.uncompsize;
					NewEntry.date := header.date; NewEntry.time := header.time;
					NewEntry.method := header.method;
					IF ODD(header.flag) THEN NewEntry.unsupp := 5 END;
					IF (header.method # 0) & (header.method # 6) & (header.method # 8) THEN
						NewEntry.unsupp := 4
					END;
					COPY(header.fname, NewEntry.name);
					IF ThisArchive.firstentry # NIL THEN
						ActEntry.next := NewEntry;
						ActEntry := ActEntry.next
					ELSE
						ThisArchive.firstentry := NewEntry;
						ActEntry := NewEntry
					END;						
				END (* LOOP *)
			ELSE (* sig # 0605.. *)
				res := 3
			END
		ELSE
			res := 1
		END; (* IF *)
		RETURN ThisArchive
	END OpenArchive;

	PROCEDURE ExtractThis*(A: Archive; E: Entry; filename: ARRAY OF CHAR; VAR res: LONGINT);		
(* res=1  file not in archive  res=2 not a valid archive *)
		VAR
			ldummy, compsize, sig, i: LONGINT;
			idummy, flags, method, namel, extral: INTEGER;
			cdummy: CHAR;
	BEGIN
		IF E.unsupp = 0 THEN
			Init(); F1 := A.File;
			IF F1 # NIL THEN
				F2 := Files.New(filename); Files.Set(r2, F2, 0);
				compsize := E.compsize; uncompsize := E.uncompsize;
				Files.Set(r1, F1, E.offsetlocal);
				Files.ReadLInt(r1, sig);
				Files.ReadInt(r1, idummy);
				Files.ReadInt(r1, flags);
				flags := flags MOD 16;
				Files.ReadInt(r1, method);Files.ReadInt(r1, idummy);
				Files.ReadInt(r1, idummy); Files.ReadLInt(r1, ldummy);
				Files.ReadLInt(r1, ldummy); Files.ReadLInt(r1, ldummy);
				Files.ReadInt(r1, namel); Files.ReadInt(r1, extral);
				FOR i := 1 TO namel DO
					Files.Read(r1, cdummy)
				END;
				FOR i := 0 TO extral-1 DO Files.Read(r1, cdummy) END;
				IF flags > 7 THEN
					Files.ReadLInt(r1, ldummy); Files.ReadLInt(r1, ldummy); Files.ReadLInt(r1, ldummy)
				END; 
				CASE method OF		
					0: Copy(uncompsize); res := 0
					|6: res := Implode(flags, uncompsize)
					|8: res := Deflate(flags, uncompsize)
				ELSE
					res := 4
				END (* CASE *)
			ELSE
				res := 2
			END
		ELSE 
			res := E.unsupp
		END
	END ExtractThis;

	PROCEDURE Error(res: LONGINT);
	BEGIN
		CASE res OF
			0: RETURN
			|1: Texts.WriteString(W, "Archive doesnt exist")
			|3: Texts.WriteString(W, "Archive not valid")
			|4: Texts.WriteString(W, "Unsupported compression method")
			|5: Texts.WriteString(W, "Archive is encrypted")
			|10: Texts.WriteString(W, "Archive corrupted")
			|11: Texts.WriteString(W, "Entry not found")
		ELSE
			Texts.WriteString(W, "ERROR")
		END;
		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END Error;

	PROCEDURE do(doc, show: BOOLEAN);
		VAR
			D: Documents.Document;
			S: Attributes.Scanner;
			r: Texts.Reader;
			A: Archive;
			E: Entry;
			text: Texts.Text;
			beg, end, time, res, i: LONGINT;
			suffix, temp: ARRAY 64 OF CHAR;
			F: Files.File;
			R: Files.Rider;
			ch: CHAR;
	BEGIN
		A := NIL; res := MIN(INTEGER);
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF Desktops.IsInMenu(Gadgets.context) THEN
			D := Desktops.CurDoc(Gadgets.context);
			IF D # NIL THEN
				A := OpenArchive(D.name, res);
				text := NIL; time := -1;
				Oberon.GetSelection(text, beg, end, time);
				IF (text # NIL) & (time > 0) THEN
					Texts.OpenReader(r, text, beg);
					Texts.Read(r, ch); i := 0;
					WHILE ~r.eot & (ch # Strings.CR) DO
						S.s[i] := ch; INC(i);
						Texts.Read(r, ch)
					END;
					S.s[i] := 0X; S.class := Attributes.String
				END
			END
		ELSIF S.class IN {Attributes.Name, Attributes.String} THEN
			A := OpenArchive(S.s, res); Attributes.Scan(S)
		END;
		IF (A # NIL) & (res = 0) & (S.class IN {Attributes.Name, Attributes.String}) THEN
			E := A.firstentry;
			WHILE (E # NIL) & (E.name # S.s) DO
				E := E.next
			END;
			IF E # NIL THEN
				IF show THEN
					Strings.GetSuffix(E.name, suffix);
					temp := "Temp.UnZip."; Strings.Append(temp, suffix);
					ExtractThis(A, E, temp, res);
					IF doc THEN
						D := Documents.Open(temp);
						IF (D # NIL) & (D.dsc # NIL) THEN
							COPY(E.name, D.name); Desktops.ShowDoc(D)
						END
					ELSE
						NEW(text); Texts.Open(text, "");
						F := Files.Old(temp); Files.Set(R, F, 0);
						Files.Read(R, ch);
						WHILE ~R.eof DO
							IF ch # Strings.LF THEN
								Texts.Write(W, ch)
							END;
							Files.Read(R, ch)
						END;
						Texts.Append(text, W.buf);
						TextDocs.ShowText(E.name, text, Display.Width DIV 3, Display.Height DIV 2)
					END
				ELSE
					Texts.WriteString(W, "Extracting "); Texts.WriteString(W, E.name); Texts.Append(Oberon.Log, W.buf);
					ExtractThis(A, E, E.name, res);
					IF res = 0 THEN
						Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
					END
				END
			ELSE
				res := 11
			END
		END;
		IF res > 0 THEN
			Error(res)
		END
	END do;

	PROCEDURE Open*;
	BEGIN
		do(TRUE, TRUE)
	END Open;

	PROCEDURE OpenAscii*;
	BEGIN
		do(FALSE, TRUE)
	END OpenAscii;

	PROCEDURE extract*;
	BEGIN
		do(FALSE, FALSE)
	END extract;

	PROCEDURE *DocHandler(D: Objects.Object; VAR M: Objects.ObjMsg);
	BEGIN
		WITH D: Documents.Document DO
			IF M IS Objects.AttrMsg THEN
				WITH M: Objects.AttrMsg DO
					IF M.id = Objects.get THEN
						IF M.name = "Gen" THEN
							M.class := Objects.String;
							M.s := "UnZip.NewDoc";
							M.res := 0
						ELSE
							TextDocs.DocHandler(D, M)
						END
					ELSE
						TextDocs.DocHandler(D, M)
					END
				END
			ELSIF M IS Objects.LinkMsg THEN
				WITH M: Objects.LinkMsg DO
					IF M.id = Objects.get THEN
						IF M.name = "DeskMenu" THEN
							M.obj := Gadgets.CopyPublicObject("UnZip.DeskMenu", TRUE);
							IF M.obj = NIL THEN M.obj := Desktops.NewMenu(Menu) END;
							M.res := 0
						ELSIF M.name = "SystemMenu" THEN
							M.obj := Gadgets.CopyPublicObject("UnZip.SystemMenu", TRUE);
							IF M.obj = NIL THEN M.obj := Desktops.NewMenu(Menu) END;
							M.res := 0
						ELSIF M.name = "UserMenu" THEN
							M.obj := Gadgets.CopyPublicObject("UnZip.UserMenu", TRUE);
							IF M.obj = NIL THEN M.obj := Desktops.NewMenu(Menu) END;
							M.res := 0
						ELSE
							TextDocs.DocHandler(D, M)
						END
					ELSE
						TextDocs.DocHandler(D, M)
					END
				END
			ELSE
				TextDocs.DocHandler(D, M)
			END
		END
	END DocHandler;

	PROCEDURE *LoadDoc(D: Documents.Document);
		VAR
			A: Archive;
			E: Entry;
			res: LONGINT;
	BEGIN
		A := OpenArchive(D.name, res);
		IF (A # NIL) & (A.nofentries > 0) & (res = 0) THEN
			E := A.firstentry;
			WHILE E # NIL DO
				Texts.WriteString(W, E.name);
				Texts.WriteLn(W);
				E := E.next
			END;
			Texts.Append(D.dsc(TextGadgets.Frame).text, W.buf)
		ELSE
			Error(res); D.dsc := NIL
		END
	END LoadDoc;

	PROCEDURE NewDoc*;
		VAR D: Objects.Object;
	BEGIN
		D := Gadgets.CreateObject("TextDocs.NewDoc");
		WITH D: Documents.Document DO
			D.Load := LoadDoc; D.Store := NIL;
			D.handle := DocHandler
		END;
		Objects.NewObj := D
	END NewDoc;

	PROCEDURE Directory*;
		VAR
			S: Attributes.Scanner;
			D: Documents.Document;
	BEGIN
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF S.class IN {Attributes.Name, Attributes.String} THEN
			NewDoc();
			D := Objects.NewObj(Documents.Document);
			IF D.dsc # NIL THEN
				COPY(S.s, D.name);
				D.Load(D);
				Desktops.ShowDoc(D)
			END
		END
	END Directory;

	PROCEDURE Extract*;
		VAR
			S: Attributes.Scanner;
			A: Archive;
			E: Entry;
			res: LONGINT;
	BEGIN
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF S.class IN {Attributes.Name, Attributes.String} THEN
			A := OpenArchive(S.s, res);
			IF (A # NIL) & (res = 0) THEN
				Attributes.Scan(S);
				WHILE S.class IN {Attributes.Name, Attributes.String} DO
					Texts.WriteString(W, S.s); Texts.Write(W, 09X);
					E := A.firstentry;
					WHILE (E # NIL) & (E.name # S.s) DO
						E := E.next
					END;
					Attributes.Scan(S);
					IF E # NIL THEN
						IF (S.class = Attributes.Char) & (S.c = "=") THEN
							Attributes.Scan(S);
							IF (S.class = Attributes.Char) & (S.c = ">") THEN
								Attributes.Scan(S)
							END;
							IF S.class IN {Attributes.Name, Attributes.String} THEN
								ExtractThis(A, E, S.s, res); Attributes.Scan(S)
							END
						ELSE
							ExtractThis(A, E, E.name, res)
						END 
					ELSE
						res := 11
					END;
					IF res > 0 THEN
						Error(res)
					ELSE
						Texts.WriteString(W, "done"); Texts.WriteLn(W)
					END
				END
			ELSE
				Error(res)			
			END;
			Texts.Append(Oberon.Log, W.buf)
		END
	END Extract;

	PROCEDURE ExtractAll*;
		VAR
			S: Attributes.Scanner;
			A: Archive;
			E: Entry;
			res: LONGINT;
	BEGIN
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		IF S.class IN {Attributes.Name, Attributes.String} THEN
			A := OpenArchive(S.s, res);
			IF (A # NIL) & (res = 0) THEN
				E := A.firstentry;
				WHILE (E # NIL) & (res = 0) DO
					Texts.WriteString(W, E.name); Texts.Append(Oberon.Log, W.buf);
					ExtractThis(A, E, E.name, res); Texts.WriteLn(W);
					E := E.next
				END;
				IF res > 0 THEN
					Error(res)
				END;
				Texts.Append(Oberon.Log, W.buf)
			ELSE
				Error(res)			
			END;
			Texts.Append(Oberon.Log, W.buf)
		END	
	END ExtractAll;

BEGIN
	Texts.OpenWriter(W);
	dictpos := 0; bufpos := 0;
	Sequence[0] := 16; Sequence[1] := 17; Sequence[2] := 18; Sequence[3] := 0;
	Sequence[4] := 8; Sequence[5] := 7; Sequence[6] := 9; Sequence[7] := 6;
	Sequence[8] := 10; Sequence[9] := 5; Sequence[10] := 11; Sequence[11] := 4;
	Sequence[12] := 12; Sequence[13] := 3; Sequence[14] := 13; Sequence[15] := 2;
	Sequence[16] := 14; Sequence[17] := 1; Sequence[18] := 15;
	Posinbyte := 0; cycled := FALSE; done := FALSE
END UnZip.

System.Set Documents zip := UnZip.NewDoc ~
