(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE FileDir; (** non-portable / source: Win32.FileDir.Mod *) (* FileDir for Oberon for Windows 95/NT, ejz  *)
	IMPORT S := SYSTEM, Kernel32, Kernel, Registry, Console;

(* Based on FileDir from MH Feb 93 / 2.6.94 jm 6.7.95 *)
(* 18.2.96 - added RelFileName (ejz) *)

(** The FileDir module implements the naming of files in directories. *)

	CONST
		MaxName = 260+1;
		WinPathChar = "\";
		pathChar = "/";

	TYPE
		(** file enumerator *)
		FileEnumerator* = PROCEDURE (path, name: ARRAY OF CHAR; time, date, size: LONGINT; isdir: BOOLEAN);
		(** (search-) path enumerator *)
		PathEnumerator* = PROCEDURE (path: ARRAY OF CHAR);
		FileName* = ARRAY MaxName OF CHAR;

	VAR
		searchPath: ARRAY 4*MaxName OF CHAR;
		workPath, tempPath: FileName;
		PathChar-: CHAR; (** directory separator *)
		moduleCS: Kernel32.CriticalSection;

 (** Replace all occurences of character from in name by to. *)
	PROCEDURE ConvertChar*(VAR name: ARRAY OF CHAR; from, to: CHAR);
		VAR i: LONGINT;
	BEGIN
		i := 0;
		WHILE name[i] # 0X DO
			IF name[i] = from THEN
				name[i] := to
			END;
			INC(i)
		END
	END ConvertChar;

 (** Search the (relative) filename name in the current directory. If it could not be found all directories in the search path
 	are searched for name. fileName returns the full (absolute) name for the file found. *)
	PROCEDURE FindFile*(VAR name, fullname: ARRAY OF CHAR; usepath: BOOLEAN): BOOLEAN;
		VAR ret, i: LONGINT;
	BEGIN
		ConvertChar(name, pathChar, WinPathChar);
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		ret := Kernel32.SearchPath(S.ADR(workPath), S.ADR(name), Kernel32.NULL, LEN(fullname), S.ADR(fullname), i);
		IF (ret <= 0) & usepath THEN
			ret := Kernel32.SearchPath(S.ADR(searchPath), S.ADR(name), Kernel32.NULL, LEN(fullname), S.ADR(fullname), i)
		END;
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
		ConvertChar(fullname, WinPathChar, pathChar);
		RETURN ret > 0
	END FindFile;

	PROCEDURE CheckPath(VAR fullName: ARRAY OF CHAR): BOOLEAN;
		VAR ret, err, i, j, k: LONGINT;
	BEGIN
		i := 0; j := -1;
		WHILE fullName[i] # 0X DO
			IF fullName[i] = WinPathChar THEN
				j := i
			END;
			INC(i)
		END;
		IF j > 0 THEN
			fullName[j] := 0X
		END;
		k := Kernel32.SetCurrentDirectory(S.ADR(fullName));
		IF j > 0 THEN
			fullName[j] := WinPathChar
		END;
		ret := Kernel32.SetCurrentDirectory(S.ADR(workPath));
		IF ret = Kernel32.False THEN
			err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
		END;
		RETURN k # Kernel32.False
	END CheckPath;

 (** Compute the relative filename (relative to the working directory). *)
	PROCEDURE RelFileName*(fileName: ARRAY OF CHAR; VAR relFileName: ARRAY OF CHAR);
		VAR
			ret, err, i, j, k, p: LONGINT;
			fullName: FileName;
	BEGIN
		k := -1; i := 0;
		WHILE fileName[i] # 0X DO
			IF fileName[i] = ":" THEN
				k := i
			END;
			INC(i)
		END;
		IF (k > 1) OR (k = 0) THEN
			COPY(fileName, relFileName); RETURN
		END;
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		IF ~FindFile(fileName, fullName, TRUE) THEN (* file does not exist -> would be created in the current dir *)
			ConvertChar(fileName, pathChar, WinPathChar);
			ret := Kernel32.GetFullPathName(S.ADR(fileName), LEN(fullName), S.ADR(fullName), i);
			IF ret <= 0 THEN
				err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
			ELSIF ~CheckPath(fullName) THEN
				Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
			END
		ELSE
			ConvertChar(fullName, pathChar, WinPathChar)
		END; (* from here on all with WinPathChar and drive letter *)
		IF CAP(workPath[0]) # CAP(fullName[0]) THEN (* different drive letters -> nothing to be done *)
			COPY(fullName, relFileName)
		ELSE
			i := 0; j := -1; p := 0;
			WHILE (fullName[i] # 0X) & (workPath[i] # 0X) & (CAP(fullName[i]) = CAP(workPath[i])) DO
				IF workPath[i] = WinPathChar THEN
					j := i
				END;
				INC(i)
			END;
			IF workPath[i] = 0X THEN
				IF fullName[i] # WinPathChar THEN (* first part of directories do match *)
					relFileName[p] := "."; relFileName[p+1] := "."; relFileName[p+2] := WinPathChar;
					INC(p, 3); INC(j);
					WHILE fullName[j] # 0X DO
						relFileName[p] := fullName[j] ; INC(j); INC(p)
					END
				ELSE (* file is in a subdirectory of the current dir *)
					INC(i);
					WHILE fullName[i] # 0X DO
						relFileName[p] := fullName[i]; INC(i); INC(p)
					END
				END
			ELSIF j > 2 THEN (* first part of directories do match *)
				k := j; i := j+1;
				WHILE workPath[k] # 0X DO
					IF workPath[k] = WinPathChar THEN
						relFileName[p] := "."; relFileName[p+1] := "."; relFileName[p+2] := WinPathChar; INC(p, 3)
					END;
					INC(k)
				END;
				WHILE fullName[i] # 0X DO
					relFileName[p] := fullName[i]; INC(i); INC(p)
				END
			ELSE (* only drive letters match *)
				i := j;
				WHILE fullName[i] # 0X DO
					relFileName[p] := fullName[i]; INC(i); INC(p)
				END
			END;
			relFileName[p] := 0X
		END;
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
		ConvertChar(relFileName, WinPathChar, pathChar)
	END RelFileName;

(** Get the current directory. *)
	PROCEDURE GetWorkingDirectory*(VAR path: ARRAY OF CHAR);
		VAR ret, err: LONGINT;
	BEGIN
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		ret := Kernel32.GetCurrentDirectory(LEN(workPath), S.ADR(workPath));
		IF ret <= 0 THEN
			err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
		END;
		COPY(workPath, path);
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
		ConvertChar(path, WinPathChar, pathChar)
	END GetWorkingDirectory;

(** Change to directory path. *)
	PROCEDURE ChangeDirectory*(path: ARRAY OF CHAR; VAR done: BOOLEAN);
		VAR ret, err: LONGINT;
	BEGIN
		ConvertChar(path, pathChar, WinPathChar);
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		ret := Kernel32.SetCurrentDirectory(S.ADR(path));
		done := ret # Kernel32.False;
		IF ret = Kernel32.False THEN
			err := Kernel32.GetLastError()
		ELSE
			ret := Kernel32.GetCurrentDirectory(LEN(workPath), S.ADR(workPath));
			IF ret <= 0 THEN
				err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
			END
		END;
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
	END ChangeDirectory;

(** Create a new directory. *)
	PROCEDURE CreateDirectory*(path: ARRAY OF CHAR; VAR done: BOOLEAN);
		VAR ret, err: LONGINT;
	BEGIN
		ConvertChar(path, pathChar, WinPathChar);
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		ret := Kernel32.CreateDirectory(S.ADR(path), Kernel32.NULL);
		IF ret = Kernel32.False THEN
			err := Kernel32.GetLastError()
		END;
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
		done := ret # Kernel32.False
	END CreateDirectory;

(** Delete directory path. *)
	PROCEDURE DeleteDirectory*(path: ARRAY OF CHAR; VAR done: BOOLEAN);
		VAR ret, err: LONGINT;
	BEGIN
		ConvertChar(path, pathChar, WinPathChar);
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		ret := Kernel32.RemoveDirectory(S.ADR(path));
		IF ret = Kernel32.False THEN
			err := Kernel32.GetLastError()
		END;
		done := ret # Kernel32.False;
		ret := Kernel32.GetCurrentDirectory(LEN(workPath), S.ADR(workPath));
		IF ret <= 0 THEN
			err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
		END;
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
	END DeleteDirectory;

(** Get the directory for temporary files. *)
	PROCEDURE GetTempDirectory*(VAR path: ARRAY OF CHAR);
	BEGIN
		COPY(tempPath, path);
		ConvertChar(path, WinPathChar, pathChar)
	END GetTempDirectory;

(** Compare two filenames. *)
	PROCEDURE SameName*(VAR a, b: ARRAY OF CHAR): BOOLEAN;
		VAR i, j: LONGINT;
	BEGIN
		i := 0; j := 0;
		WHILE (CAP(a[i]) = CAP(b[j])) & (a[i] # 0X) & (b[j] # 0X) DO
			INC(i); INC(j)
		END;
		RETURN (a[i] = 0X) & (b[j] = 0X)
	END SameName;

(** Enumerate files. The detail flag indicates if time, date and size
must be calculated. When
	path = "."	=> enumerate files in current directory
	path = ""	=> enumerate files in the search path
	path = ?	=> enumerate files in the directory ?
	
	Directories are always returned independent of the pattern specified. The only wildcard allowed is *. *)
	PROCEDURE EnumerateFiles*(path, pattern: ARRAY OF CHAR; detail: BOOLEAN; enum: FileEnumerator);
		VAR
			curPath: FileName;
			ret, err, i, j: LONGINT;
		PROCEDURE EnumeratePath();
			VAR
				i, j, h, t, d: LONGINT;
				FD: Kernel32.FindData;
				ft: Kernel32.FileTime;
				st: Kernel32.SystemTime;
		BEGIN
			i := 0;
			WHILE curPath[i] #  0X DO
				INC(i)
			END;
			IF curPath[i-1] # WinPathChar THEN
				curPath[i] := WinPathChar; INC(i)
			END;
			curPath[i] := 0X; j := i-1;
			h := 0;
			WHILE pattern[h] # 0X DO
				curPath[i] := pattern[h]; INC(i); INC(h)
			END;
			IF h = 0 THEN
				curPath[i] := "*"; INC(i); curPath[i] := "."; INC(i); curPath[i] := "*"; INC(i)
			END;
			curPath[i] := 0X;
			h := Kernel32.FindFirstFile(S.ADR(curPath), S.ADR(FD)); curPath[j] := 0X; ConvertChar(curPath, WinPathChar, pathChar);
			IF h # Kernel32.InvalidHandleValue THEN
				t := 0; d := 0;
				REPEAT
					IF detail THEN
						ret := Kernel32.FileTimeToLocalFileTime(S.ADR(FD.lastWrite), S.ADR(ft));
						ret := Kernel32.FileTimeToSystemTime(S.ADR(ft), S.ADR(st));
						IF ret = Kernel32.False THEN
							err := Kernel32.GetLastError();
							d := 0; t := 0
						ELSE
							d := LONG(st.year-1900)*200H + LONG(st.month)*20H + LONG(st.day);
							t := LONG(st.hour)*1000H + LONG(st.min)*40H + LONG(st.sec)
						END
					END;
					IF (S.VAL(SET, FD.fileAttrs) * S.VAL(SET, Kernel32.FileAttributeDirectory)) # S.VAL(SET, S.VAL(SET, Kernel32.FileAttributeDirectory)) THEN
						enum(curPath, FD.name, t, d, FD.sizeLow, FALSE)
					END;
					i := Kernel32.FindNextFile(h, S.ADR(FD))
				UNTIL i = Kernel32.False;
				i := Kernel32.FindClose(h)
			END;
			curPath[j] := pathChar; i := j+1;
			curPath[i] := "*"; INC(i); curPath[i] := 0X; ConvertChar(curPath, pathChar, WinPathChar);
			h := Kernel32.FindFirstFile(S.ADR(curPath), S.ADR(FD)); curPath[j] := 0X; ConvertChar(curPath, WinPathChar, pathChar);
			IF h # Kernel32.InvalidHandleValue THEN
				t := 0; d := 0;
				REPEAT
					IF detail THEN
						ret := Kernel32.FileTimeToSystemTime(S.ADR(FD.lastWrite), S.ADR(st));
						IF ret = Kernel32.False THEN
							err := Kernel32.GetLastError();
							d := 0; t := 0
						ELSE
							d := LONG(st.year-1900)*200H + LONG(st.month)*20H + LONG(st.day);
							t := LONG(st.hour)*1000H + LONG(st.min)*40H + LONG(st.sec)
						END
					END;
					IF (S.VAL(SET, FD.fileAttrs) * S.VAL(SET, Kernel32.FileAttributeDirectory)) = S.VAL(SET, S.VAL(SET, Kernel32.FileAttributeDirectory)) THEN
						IF (FD.name # "..") & (FD.name # ".") THEN
							enum(curPath, FD.name, t, d, FD.sizeLow, TRUE)
						END
					END;
					i := Kernel32.FindNextFile(h, S.ADR(FD))
				UNTIL i = Kernel32.False;
				i := Kernel32.FindClose(h)
			END
		END EnumeratePath;
	BEGIN
		IF enum = NIL THEN RETURN END;
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		IF path = "." THEN
			COPY(workPath, curPath);
			Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
			EnumeratePath()
		ELSIF path = "" THEN
			COPY(workPath, curPath);
			Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
			EnumeratePath();
			Kernel32.EnterCriticalSection(S.ADR(moduleCS));
			i := 0; j := 0;
			WHILE searchPath[i] # 0X DO
				IF searchPath[i] # ";" THEN
					curPath[j] := searchPath[i]; INC(j)
				ELSE
					curPath[j] := 0X;
					IF (j > 0) & ~SameName(curPath, workPath) THEN
						Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
						EnumeratePath();
						Kernel32.EnterCriticalSection(S.ADR(moduleCS))
					END;
					j := 0
				END;
				INC(i)
			END;
			curPath[j] := 0X;
			IF (j > 0) & ~SameName(curPath, workPath) THEN
				Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
				EnumeratePath()
			ELSE
				Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
			END
		ELSE
			COPY(path, curPath); ConvertChar(curPath, pathChar, WinPathChar);
			Kernel32.LeaveCriticalSection(S.ADR(moduleCS));
			EnumeratePath()
		END
	END EnumerateFiles;

	PROCEDURE EnumerateSearchPaths*(enum: PathEnumerator);
		VAR
			ret, err, j, k: LONGINT;
			path: FileName;
		PROCEDURE EnumDir();
		BEGIN
			IF k > 0 THEN
				path[k] := 0X;
				ret := Kernel32.SetCurrentDirectory(S.ADR(path));
				IF ret # Kernel32.False THEN
					ret := Kernel32.GetCurrentDirectory(LEN(path), S.ADR(path));
					IF ret <= 0 THEN
						err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
					END;
					ConvertChar(path, WinPathChar, pathChar);
					enum(path)
				ELSE
					err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); HALT(99)
				END;
				ret := Kernel32.SetCurrentDirectory(S.ADR(workPath));
				k := 0
			END
		END EnumDir;
	BEGIN
		IF enum = NIL THEN RETURN END;
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		COPY(workPath, path);
		ConvertChar(path, WinPathChar, pathChar);
		enum(path);
		k := 0; j := 0;
		WHILE searchPath[j] # 0X DO
			IF (searchPath[j] = ";") OR (searchPath[j] < " ") THEN
				EnumDir()
			ELSE
				path[k] := searchPath[j]; INC(k)
			END;
			INC(j)
		END;
		EnumDir();
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
	END EnumerateSearchPaths;

	PROCEDURE CheckName*(name: ARRAY OF CHAR): BOOLEAN;
		VAR
			fullName: FileName;
			ret, err, i: LONGINT;
			ch: CHAR;
	BEGIN
		ConvertChar(name, pathChar, WinPathChar);
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		ret := Kernel32.GetFullPathName(S.ADR(name), LEN(fullName), S.ADR(fullName), i);
		IF ret <= 0 THEN
			err := Kernel32.GetLastError(); Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN FALSE
		ELSIF ~CheckPath(fullName) THEN
			Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN FALSE
		ELSIF i # Kernel32.NULL THEN
			i := i-S.ADR(fullName);
			fullName[i-1] := 0X; ch := fullName[i];
			WHILE ch # 0X DO
				IF ~( ((CAP(ch) >= "A") & (CAP(ch) <= "Z"))  OR  ((ch >= "0") & (ch <= "9"))  OR
						(ch = ".") OR (ch = "_") OR (ch = "-") ) THEN Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN FALSE
				END;
				INC(i); ch := fullName[i]
			END;
			Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN TRUE
		ELSE
			Kernel32.LeaveCriticalSection(S.ADR(moduleCS)); RETURN FALSE
		END
	END CheckName;

	PROCEDURE *Shutdown();
	BEGIN
		Kernel32.DeleteCriticalSection(S.ADR(moduleCS))
	END Shutdown;

	PROCEDURE Init();
		VAR
			ret, err, i, j, k: LONGINT;
			dirs: ARRAY 4*MaxName OF CHAR;
			dir, sysPath: FileName;
		PROCEDURE AddDir();
		BEGIN
			IF k > 0 THEN
				dir[k] := 0X; ConvertChar(dir, PathChar, WinPathChar);
				ret := Kernel32.SetCurrentDirectory(S.ADR(sysPath));
				ret := Kernel32.SetCurrentDirectory(S.ADR(dir));
				IF ret # Kernel32.False THEN
					ret := Kernel32.GetCurrentDirectory(LEN(dir), S.ADR(dir));
					IF ret <= 0 THEN
						err := Kernel32.GetLastError(); HALT(99)
					END;
					IF dir # workPath THEN
						searchPath[i] := ";"; INC(i);
						k := 0;
						WHILE dir[k] # 0X DO
							searchPath[i] := dir[k]; INC(i); INC(k)
						END
					END
				ELSE
					Console.Str(dir); Console.Str(" not a vaild directory"); Console.Ln()
				END;
				k := 0
			END
		END AddDir;
	BEGIN
		Kernel32.InitCriticalSection(S.ADR(moduleCS));
		Kernel32.EnterCriticalSection(S.ADR(moduleCS));
		Kernel.InstallQ(Kernel.quitQ, Shutdown);
		PathChar := pathChar;
		ret := Kernel32.GetCurrentDirectory(LEN(workPath), S.ADR(workPath));
		IF ret <= 0 THEN
			err := Kernel32.GetLastError(); HALT(99)
		END;
		Registry.GetKeyValue(Registry.CurrentUser, Registry.oberonSystem, "Files", sysPath);
		IF Registry.res = Registry.Done THEN
			ret := Kernel32.SetCurrentDirectory(S.ADR(sysPath));
			IF ret # Kernel32.False THEN
				ret := Kernel32.GetCurrentDirectory(LEN(sysPath), S.ADR(sysPath))
			END
		ELSE
			ret := Kernel32.False
		END;
		IF ret = Kernel32.False THEN
			ret := Kernel32.GetModuleFileName(0, S.ADR(sysPath), MaxName);
			i := 0; j := -1;
			WHILE sysPath[i] # 0X DO
				IF sysPath[i] = WinPathChar THEN
					j := i
				END;
				INC(i)
			END;
			i := j+1; sysPath[i] := 0X;
			COPY(sysPath, searchPath)
		ELSE
			i := 0;
			WHILE sysPath[i] # 0X DO
				searchPath[i] := sysPath[i]; INC(i)
			END;
			searchPath[i] := 0X
		END;
		Registry.GetKeyValue(Registry.CurrentUser, Registry.oberonSystem, "Directories", dirs);
		IF Registry.res # Registry.Done THEN
			dirs := "system;obj;src;apps;docu;resource"
		END;
		k := 0; j := 0;
		WHILE dirs[j] # 0X DO
			IF (dirs[j] = ";") OR (dirs[j] < " ") THEN
				AddDir()
			ELSE
				dir[k] := dirs[j]; INC(k)
			END;
			INC(j)
		END;
		AddDir();
		searchPath[i] := 0X;
		IF Registry.res # Registry.Done THEN
			Registry.SetKeyValue(Registry.CurrentUser, Registry.oberonSystem, "Directories", searchPath)
		END;
		Registry.GetKeyValue(Registry.CurrentUser, Registry.oberonSystem, "Temp", tempPath);
		IF Registry.res = Registry.Done THEN
			ConvertChar(tempPath, PathChar, WinPathChar);
			ret := Kernel32.SetCurrentDirectory(S.ADR(sysPath));
			ret := Kernel32.SetCurrentDirectory(S.ADR(tempPath));
			IF ret # Kernel32.False THEN
				ret := Kernel32.GetCurrentDirectory(LEN(tempPath), S.ADR(tempPath))
			END
		ELSE
			ret := Kernel32.False
		END;
		IF ret = Kernel32.False THEN
			ret := Kernel32.GetTempPath(LEN(tempPath), S.ADR(tempPath))
		END;
		Registry.GetKeyValue(Registry.CurrentUser, Registry.oberonSystem, "Work", dir);
		IF (Registry.res = Registry.Done) & (dir # "") THEN
			ConvertChar(dir, PathChar, WinPathChar);
			ret := Kernel32.SetCurrentDirectory(S.ADR(sysPath));
			ret := Kernel32.SetCurrentDirectory(S.ADR(dir));
			IF ret # Kernel32.False THEN
				ret := Kernel32.GetCurrentDirectory(LEN(workPath), S.ADR(workPath))
			END
		END;
		ret := Kernel32.SetCurrentDirectory(S.ADR(workPath));
		Registry.OberonPath("SystemInfo", sysPath);
		Registry.SetKeyValue(Registry.CurrentUser, sysPath, "FileSystem", "VFAT/NTFS");
		Registry.SetKeyValue(Registry.CurrentUser, sysPath, "HostFilenamePrefix", "");
		Kernel32.LeaveCriticalSection(S.ADR(moduleCS))
	END Init;

BEGIN
	Init()
END FileDir.

(** Remarks:

1. Newly created files are always written in the working directory when no absolute filename is specified. Opening a file
searches in the current directory, followed by each directory in the path in return.

2. The search path for files is specified by the Directories key in the System section of the Registry. *)