(* OBERON System 3, Release 2.2.

Copyright 1996, 1997 Team of the Institute of Computer Systems of ETH Zürich, ETH Center, CH-8092 Zürich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

or requested from the above mentioned address.

Under the license terms stated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Linker;

IMPORT
	Reals, Files, Display, Objects, Fonts, Texts, Oberon, Attributes, Documents, Resources, Crypt,
	TextGadgets0, TextGadgets, TextDocs, Desktops, Out;

	VAR
		scratch: Files.Rider;
		err: BOOLEAN;

	CONST
		BufferSize = 4*1024;
		WindowSize = 4096;
		RawLookAheadSize = 16;
		BreakEven = 1;
		LookAheadSize = RawLookAheadSize + BreakEven;
		Unused = 0;
		TreeRoot = WindowSize;
		EndOfStream = 0;
		IndexBitCount = 12;
		LengthBitCount = 4;

	TYPE
		Node = RECORD
			parent, smallerChild, largerChild: INTEGER
		END;

	VAR
		Buffer: ARRAY BufferSize OF CHAR;
		BufferPtr, CurBitNr, CurByte: LONGINT;
		Tree: POINTER TO ARRAY WindowSize+1 OF Node;
		Window: ARRAY WindowSize+RawLookAheadSize+1 OF CHAR;
		help: INTEGER;

	VAR
		Read: PROCEDURE(VAR ch: CHAR);
		reof: BOOLEAN;
		fileR: Files.Rider; (* for file rider *)
		
(* -------------- Scanner *)
	CONST
		idLen = 32;
		strLen = 256;

		(* numTyp *)
		char = 1; integer = 2; real = 3; longreal = 4;

		MaxHexDig = 8;
		MaxLongInt = 7FFFFFFFH;
		MaxInt = 7FFFH;
		MaxRealExp = 38;
		MaxLongRealExp = 308;

		quoteA = "'";		quoteB = 022X;
		null = 0;		times = 1; (* * *)		slash = 2; (* / *)		div = 3; (* DIV *)		mod = 4;(* MOD *)
		and = 5; (* & *)		plus = 6; (* + *)		minus = 7; (* - *)		or = 8; (* OR *)		equal = 9; (* = *)
		notequal = 10; (* # *)		less = 11; (* < *)		lessequal = 12; (* <= *)		greater = 13; (* > *)
		greaterequal = 14; (* >= *)		in = 15; (* IN *)		is = 16; (* IS *)		arrow = 17; (* ^ *)
		period = 18; (* . *)		comma = 19; (* , *)		colon = 20; (* : *)		upto = 21; (* .. *)
		rparen = 22; (* ) *)		rbrak = 23;(* ] *)		rbrace = 24; (* } *)		of = 25; (* OF *)
		then = 26; (* THEN *)		do = 27; (* DO *)		to = 28; (* TO *)		by = 29; (* BY *)
		lparen = 30; (* ( *)		lbrak = 31; (* [ *)		lbrace = 32; (* { *)		not = 33; (* ~ *)
		becomes = 34; (* := *)		number = 35; (* <number> *)		nil = 36; (* NIL *)		string = 37; (* <string> *)
		ident = 38; (* <ident> *)		semicolon = 39; (* ; *)		bar = 40; (* | *)		end = 41; (* END *)
		else = 42; (* ELSE *)			elsif = 43; (* ELSIF *)		until = 44; (* UNTIL *)		if = 45; (* IF *)
		case = 46; (* CASE *)		while = 47; (* WHILE *)		repeat = 48; (* REPEAT *)
		for = 49; (* FOR *)		loop = 50; (* LOOP *)		with = 51; (* WITH *)		exit = 52; (* EXIT *)
		return = 53; (* RETURN *)		array = 54; (* ARRAY *)		record = 55; (* RECORD *)		pointer = 56; (* POINTER *)
		begin = 57; (* BEGIN *)		const = 58; (* CONST *)		type = 59; (* TYPE *)		var = 60; (* VAR *)
		procedure = 61; (* PROCEDURE *)		import = 62; (* IMPORT *)		module = 63; (* MODULE *)
		eof = 64; (* <eof> *)

	VAR
		R: Texts.Reader;
		ch: CHAR;
		symPos, rpos: LONGINT;
		Ident: ARRAY idLen OF CHAR;
		String: ARRAY strLen OF CHAR;
		Integer: LONGINT;
		Real: REAL;
		LongReal: LONGREAL;
		numTyp: INTEGER;
		W: Texts.Writer;
		errs*: INTEGER;
		sym: INTEGER;

(* -------------- *)
	TYPE
		TNode = POINTER TO TNodeDesc;
		TNodeDesc = RECORD
			id: ARRAY idLen OF CHAR;
			left, right: TNode;
			ref: INTEGER;
		END;

	VAR
		tokbuf: ARRAY 1024 OF CHAR;
		tokpos, toklen: INTEGER;
		root: TNode;
		theref: INTEGER;

(* -------------- *)
VAR
	username: ARRAY 128 OF CHAR;

(* -------------- *)

	PROCEDURE OutputBit(VAR R: Files.Rider; bit: LONGINT);
	BEGIN
		IF bit = 1 THEN
			CurByte := CurByte+ASH(1, CurBitNr)
		END;
		DEC(CurBitNr);
		IF CurBitNr < 0 THEN
			Buffer[BufferPtr] := CHR(CurByte);
			INC(BufferPtr);
			IF BufferPtr = BufferSize THEN
				Files.WriteBytes(R,  Buffer, BufferSize);
				BufferPtr := 0
			END;
			CurBitNr := 7;
			CurByte := 0
		END
	END OutputBit;

	PROCEDURE OutputBits(VAR R: Files.Rider; bits, count: LONGINT);
		VAR i, h: LONGINT;
	BEGIN
		h := bits;
		i := count-1;
		WHILE i >= 0 DO
			IF ASH(h, -i) MOD 2 = 1 THEN
				CurByte := CurByte+ASH(1, CurBitNr)
			END;
			DEC(CurBitNr);
			IF CurBitNr < 0 THEN
				Buffer[BufferPtr] := CHR(CurByte);
				INC(BufferPtr);
				IF BufferPtr = BufferSize THEN
					Files.WriteBytes(R, Buffer, BufferSize);
					BufferPtr := 0
				END;
				CurBitNr := 7;
				CurByte := 0
			END;
			DEC(i)
		END
	END OutputBits;
	
	PROCEDURE FlushBits(VAR R: Files.Rider);
	BEGIN
		IF CurBitNr # 7 THEN
			Buffer[BufferPtr] := CHR(CurByte);
			INC(BufferPtr)
		END;
		IF BufferPtr > 0 THEN
			Files.WriteBytes(R, Buffer, BufferPtr);
		END
	END FlushBits;

	PROCEDURE Init();
		VAR i: INTEGER;
	BEGIN
		BufferPtr := 0; CurBitNr := 7; CurByte := 0;
		i := 0;
		WHILE i < WindowSize DO
			Tree[i].parent := Unused;
			Tree[i].smallerChild := Unused;
			Tree[i].largerChild := Unused;
			Window[i] := CHR(0);
			INC(i)
		END;
		Tree[i].parent := Unused;
		Tree[i].smallerChild := Unused;
		Tree[i].largerChild := Unused;
		WHILE i < WindowSize+RawLookAheadSize+1 DO
			Window[i] := CHR(0);
			INC(i)
		END
	END Init;

	PROCEDURE InitTree(r: INTEGER);
	BEGIN
		Tree[TreeRoot].largerChild := r;
		Tree[r].parent := TreeRoot;
		Tree[r].largerChild := Unused;
		Tree[r].smallerChild := Unused
	END InitTree;

	PROCEDURE ContractNode(oldNode, newNode: INTEGER);
	BEGIN
		help := Tree[oldNode].parent;
		Tree[newNode].parent := help;
		help := Tree[oldNode].parent;
		IF Tree[help].largerChild = oldNode THEN
			Tree[help].largerChild := newNode
		ELSE
			Tree[help].smallerChild := newNode
		END;
		Tree[oldNode].parent := Unused
	END ContractNode;

	PROCEDURE ReplaceNode(oldNode, newNode: INTEGER);
		VAR parent: INTEGER;
	BEGIN
		parent := Tree[oldNode].parent;
		IF Tree[parent].smallerChild = oldNode THEN
			Tree[parent].smallerChild := newNode
		ELSE
			Tree[parent].largerChild := newNode
		END;
		Tree[newNode] := Tree[oldNode];
		help := Tree[newNode].smallerChild;
		Tree[help].parent := newNode;
		help := Tree[newNode].largerChild;
		Tree[help].parent := newNode;
		Tree[oldNode].parent := Unused
	END ReplaceNode;

	PROCEDURE FindNextNode(node: INTEGER): INTEGER;
		VAR next: INTEGER;
	BEGIN
		next := Tree[node].smallerChild;
		WHILE Tree[next].largerChild # Unused DO
			next := Tree[next].largerChild
		END;
		RETURN next
	END FindNextNode;
	
	PROCEDURE DeleteString(p: INTEGER);
		VAR replacement: INTEGER;
	BEGIN
		IF Tree[p].parent = Unused THEN
			RETURN
		END;
		IF Tree[p].largerChild = Unused THEN
			ContractNode(p, Tree[p].smallerChild)
		ELSIF Tree[p].smallerChild = Unused THEN
			ContractNode(p, Tree[p].largerChild)
		ELSE
			replacement := FindNextNode(p);
			DeleteString(replacement);
			ReplaceNode(p, replacement)
		END
	END DeleteString;

	PROCEDURE AddString(newNode: INTEGER; VAR matchPosition: INTEGER): INTEGER;
		VAR i, testNode, delta, matchLength, child: INTEGER;
	BEGIN
		IF newNode = EndOfStream THEN
			RETURN 0
		END;
		testNode := Tree[TreeRoot].largerChild;
		matchLength := 0;
		LOOP
			i := 0;
			delta := 0;
			WHILE (i < LookAheadSize) & (delta = 0) DO
				delta := ORD(Window[newNode+i]) - ORD(Window[testNode+i]);
				INC(i)
			END;
			IF delta # 0 THEN DEC(i) END;
			IF i >= matchLength THEN
				matchLength := i;
				matchPosition := testNode;
				IF matchLength >= LookAheadSize THEN
					ReplaceNode(testNode, newNode);
					RETURN matchLength
				END;
			END;
			IF delta >= 0 THEN
				child := Tree[testNode].largerChild
			ELSE
				child := Tree[testNode].smallerChild
			END;
			IF child = Unused THEN
				IF delta >= 0 THEN
					Tree[testNode].largerChild := newNode
				ELSE
					Tree[testNode].smallerChild := newNode
				END;
				Tree[newNode].parent := testNode;
				Tree[newNode].largerChild := Unused;
				Tree[newNode].smallerChild := Unused;
				RETURN matchLength
			END;
			testNode := child
		END
	END AddString;

	PROCEDURE Copy(VAR Output: Files.Rider);
	BEGIN Read(ch); WHILE ~reof DO Files.Write(Output, ch); Read(ch) END
	END Copy;

	PROCEDURE Compress*(VAR Output: Files.Rider);
		VAR i, lookAheadBytes, currentPosition, replaceCount, matchLength, matchPosition: INTEGER;
			ch: CHAR;
	BEGIN
		Init();
		currentPosition := 1;
		i := 0;
		WHILE (i < LookAheadSize) & ~reof DO
			Read(ch);
			Window[currentPosition+i] := ch;
			IF currentPosition+i < RawLookAheadSize+1 THEN
				Window[currentPosition+i+WindowSize-1] := ch
			END;
			INC(i)
		END;
		IF reof THEN DEC(i) END;
		lookAheadBytes := i;
		InitTree(currentPosition);
		matchLength := 0;
		matchPosition := 0;
		WHILE lookAheadBytes > 0 DO
			IF matchLength > lookAheadBytes THEN
				matchLength := lookAheadBytes
			END;
			IF matchLength <= BreakEven THEN
				replaceCount := 1;
				OutputBit(Output, 1);
				OutputBits(Output, ORD(Window[currentPosition]), 8)
			ELSE
				OutputBit(Output, 0);
				OutputBits(Output, matchPosition, IndexBitCount);
				OutputBits(Output, matchLength-(BreakEven+1), LengthBitCount);
				replaceCount := matchLength
			END;
			i := 0;
			WHILE i < replaceCount DO
				DeleteString((currentPosition+LookAheadSize) MOD (WindowSize-1));
				Read(ch);
				IF reof THEN
					DEC(lookAheadBytes)
				ELSE
					Window[currentPosition+LookAheadSize] := ch;
					Window[(currentPosition+LookAheadSize) MOD (WindowSize-1)] := ch
				END;
				currentPosition := (currentPosition+1) MOD (WindowSize-1);
				IF lookAheadBytes # 0 THEN
					matchLength := AddString(currentPosition, matchPosition)
				END;
				INC(i)
			END
		END;
		OutputBit(Output, 0);
		OutputBits(Output, EndOfStream, IndexBitCount);
		FlushBits(Output);
	END Compress;

	(* ------------------- Token Rider *)
	
	PROCEDURE nextCh();
	BEGIN
		REPEAT
			Texts.Read(R, ch);
			INC(rpos)
		UNTIL R.eot OR ((R.lib # NIL) & (R.lib IS Fonts.Font))
	END nextCh;

	PROCEDURE Mark(err: INTEGER);
	BEGIN INC(errs);
		Texts.WriteInt(W, err, 0);
		Texts.WriteString(W, " at ");
		Texts.WriteInt(W, symPos, 0);
		Texts.WriteLn(W);
		Texts.Append(Oberon.Log, W.buf)
	END Mark;
	
	PROCEDURE SkipComment();
	BEGIN
		nextCh();
		LOOP
			LOOP
				WHILE ch = "(" DO
					nextCh();
					IF ch = "*" THEN SkipComment() END
				END;
				IF ch = "*" THEN nextCh(); EXIT END;
				IF ch = 0X THEN EXIT END;
				nextCh()
			END;
			IF ch = ")" THEN nextCh(); EXIT
			END;
			IF ch = 0X THEN Mark(5); EXIT END
		END
	END SkipComment;

	PROCEDURE GetIdent();
		VAR i: INTEGER;
	BEGIN
		i := 1; Ident[0] := ch; nextCh();
		WHILE ((ch >= "A") & (ch <= "Z")) OR ((ch >= "a") & (ch <= "z")) OR ((ch >= "0") & (ch <= "9")) DO
			IF i < idLen THEN Ident[i] := ch END;
			nextCh();
			INC(i)
		END;
		IF i >= idLen THEN
			Ident[idLen-1] := 0X; Mark(240)
		ELSE Ident[i] := 0X
		END
	END GetIdent;

	PROCEDURE GetString();
		VAR i: INTEGER; qch: CHAR;
	BEGIN
		qch := ch; i := 0; nextCh();
		WHILE (ch # qch) & (ch # 0X) DO
			IF ch >= " " THEN
				IF i < strLen THEN String[i] := ch END;
				INC(i)
			ELSE
				Mark(3)
			END;
			nextCh()
		END;
		IF ch = 0X THEN String[strLen-1] := 0X; Mark(3)
		ELSIF i >= strLen THEN String[strLen-1] := 0X; Mark(241)
		ELSE String[i] := 0X
		END;
		nextCh()
	END GetString;

	PROCEDURE GetNumber();
		VAR
			i, m, n, d, e: INTEGER;
			dig: ARRAY 24 OF CHAR;
			f: LONGREAL; expCh: CHAR; neg: BOOLEAN;

		PROCEDURE Ten(e: INTEGER): LONGREAL;
			VAR x, p: LONGREAL;
		BEGIN
			x := 1.0; p := 10.0;
			WHILE e > 0 DO
				IF ODD(e) THEN x := x*p END;
				e := e DIV 2;
				IF e > 0 THEN p := p*p END
			END;
			RETURN x
		END Ten;

		PROCEDURE Ord(ch: CHAR; hex: BOOLEAN): INTEGER;
		BEGIN
			IF ch <= "9" THEN RETURN ORD(ch) - ORD("0")
			ELSIF hex THEN RETURN ORD(ch) - ORD("A") + 10
			ELSE Mark(2); RETURN 0
			END
		END Ord;
		
	BEGIN
		i := 0; m := 0; n := 0; d := 0;
		LOOP
			IF ("0" <= ch) & (ch <= "9") OR (d = 0) & ("A" <= ch) & (ch <= "F") THEN
				IF (m > 0) OR (ch # "0") THEN
					IF n < LEN(dig) THEN dig[n] := ch; INC(n) END;
					INC(m)
				END;
				nextCh(); INC(i)
			ELSIF ch = "." THEN
				nextCh();
				IF ch = "." THEN ch := 7FX; EXIT
				ELSIF d = 0 THEN d := i
				ELSE Mark(2)
				END
			ELSE EXIT
			END
		END;
		IF d = 0 THEN
			IF n = m THEN
				Integer := 0; i := 0;
				IF ch = "X" THEN
					nextCh(); numTyp := char;
					IF n <= 2 THEN
						WHILE i < n DO
							Integer := Integer*10H + Ord(dig[i], TRUE);
							INC(i)
						END
					ELSE Mark(2)
					END
				ELSIF ch = "H" THEN
					nextCh(); numTyp := integer;
					IF n <= MaxHexDig THEN
						IF (n = MaxHexDig) & (dig[0] > "7") THEN Integer := -1 END;
						WHILE i < n DO
							Integer := Integer*10H + Ord(dig[i], TRUE);
							INC(i)
						END
					ELSE Mark(2)
					END
				ELSE
					numTyp := integer;
					WHILE i < n DO
						d := Ord(dig[i], FALSE);
						INC(i);
						IF Integer <= (MaxLongInt - d) DIV 10 THEN Integer := Integer*10 + d
						ELSE Mark(2)
						END
					END
				END
			ELSE Mark(2)
			END
		ELSE
			f := 0.0; e := 0; expCh := "E";
			WHILE n > 0 DO
				DEC(n); f := (Ord(dig[n], FALSE) + f) / 10.0
			END;
			IF (ch = "E") OR (ch = "D") THEN
				expCh := ch; nextCh();
				neg := FALSE;
				IF ch = "-" THEN neg := TRUE; nextCh()
				ELSIF ch = "+" THEN nextCh()
				END;
				IF ("0" <= ch) & (ch <= "9") THEN
					REPEAT
						n := Ord(ch, FALSE);
						nextCh();
						IF e <= (MaxInt - n) DIV 10 THEN e := e*10 + n
						ELSE Mark(2)
						END
					UNTIL (ch < "0") OR ("9" < ch);
					IF neg THEN e := -e
					END
				ELSE Mark(2)
				END
			END;
			DEC(e, i-d-m);
			IF expCh = "E" THEN
				numTyp := real;
				IF (1-MaxRealExp < e) & (e <= MaxRealExp) THEN
					IF e < 0 THEN Real := SHORT(f / Ten(-e))
					ELSE Real := SHORT(f * Ten(e))
					END
				ELSE Mark(2)
				END
			ELSE
				numTyp := longreal;
				IF (1-MaxLongRealExp < e) & (e <= MaxLongRealExp) THEN
					IF e < 0 THEN LongReal := f / Ten(-e)
					ELSE LongReal := f * Ten(e)
					END
				ELSE Mark(2)
				END
			END
		END
	END GetNumber;

	PROCEDURE Get(VAR sym: INTEGER);
	BEGIN
		WHILE (ch <= " ") & (ch # 0X) DO nextCh() END;
		symPos := rpos-1;
		CASE ch OF
		 0X: sym := eof
		|"A": GetIdent();
				IF Ident = "ARRAY" THEN sym := array
				ELSE sym := ident
				END
		|"B": GetIdent();
				IF Ident = "BEGIN" THEN sym := begin
				ELSIF Ident = "BY" THEN sym := by
				ELSE sym := ident
				END
		|"C": GetIdent();
				IF Ident = "CONST" THEN sym := const
				ELSIF Ident = "CASE" THEN sym := case
				ELSE sym := ident
				END
		|"D": GetIdent();
				IF Ident = "DO" THEN sym := do
				ELSIF Ident = "DIV" THEN sym := div
				ELSE sym := ident
				END
		|"E": GetIdent();
				IF Ident = "END" THEN sym := end
				ELSIF Ident = "ELSE" THEN sym := else
				ELSIF Ident = "ELSIF" THEN sym := elsif
				ELSIF Ident = "EXIT" THEN sym := exit
				ELSE sym := ident
				END
		|"F": GetIdent();
				IF Ident = "FOR" THEN sym := for
				ELSE sym := ident
				END
		|"I": GetIdent();
				IF Ident = "IF" THEN sym := if
				ELSIF Ident = "IMPORT" THEN sym := import
				ELSIF Ident = "IN" THEN sym := in
				ELSIF Ident = "IS" THEN sym := is
				ELSE sym := ident
				END
		|"L": GetIdent();
				IF Ident = "LOOP" THEN sym := loop
				ELSE sym := ident
				END
		|"M": GetIdent();
				IF Ident = "MOD" THEN sym := mod
				ELSIF Ident = "MODULE" THEN sym := module
				ELSE sym := ident
				END
		|"N": GetIdent();
				IF Ident = "NIL" THEN sym := nil
				ELSE sym := ident
				END
		|"O": GetIdent();
				IF Ident = "OF" THEN sym := of
				ELSIF Ident = "OR" THEN sym := or
				ELSE sym := ident
				END
		|"P": GetIdent();
				IF Ident = "PROCEDURE" THEN sym := procedure
				ELSIF Ident = "POINTER" THEN sym := pointer
				ELSE sym := ident
				END
		|"R": GetIdent();
				IF Ident = "RECORD" THEN sym := record
				ELSIF Ident = "RETURN" THEN sym := return
				ELSIF Ident = "REPEAT" THEN sym := repeat
				ELSE sym := ident
				END
		|"T": GetIdent();
				IF Ident = "THEN" THEN sym := then
				ELSIF Ident = "TYPE" THEN sym := type
				ELSIF Ident = "TO" THEN sym := to
				ELSE sym := ident
				END
		|"U": GetIdent();
				IF Ident = "UNTIL" THEN sym := until
				ELSE sym := ident
				END
		|"V": GetIdent();
				IF Ident = "VAR" THEN sym := var
				ELSE sym := ident
				END
		|"W": GetIdent();
				IF Ident = "WHILE" THEN sym := while
				ELSIF Ident = "WITH" THEN sym := with
				ELSE sym := ident
				END
		|"a".."z": GetIdent(); sym := ident
		|"G", "H", "J", "K", "Q", "S", "X", "Y", "Z": GetIdent(); sym := ident
		|"+": sym := plus; nextCh()
		|"-": sym := minus; nextCh()
		|"*": sym := times; nextCh()
		|"/": sym := slash; nextCh()
		|"~": sym := not; nextCh()
		|"&": sym := and; nextCh()
		|".": nextCh();
				IF ch = "." THEN sym := upto; nextCh()
				ELSE sym := period
				END
		|",": sym := comma; nextCh()
		|";": sym := semicolon; nextCh()
		|"|": sym := bar; nextCh()
		|"(": nextCh();
				IF ch = "*" THEN SkipComment(); Get(sym)
				ELSE sym := lparen
				END
		|")": sym := rparen; nextCh()
		|"[": sym := lbrak; nextCh()
		|"]": sym := rbrak; nextCh()
		|"{": sym := lbrace; nextCh()
		|"}": sym := rbrace; nextCh()
		|":": nextCh();
				IF ch = "=" THEN sym := becomes; nextCh()
				ELSE sym := colon
				END
		|"^": sym := arrow; nextCh()
		|"=": sym := equal; nextCh()
		|"#": sym := notequal; nextCh()
		|"<": nextCh();
				IF ch = "=" THEN sym := lessequal; nextCh()
				ELSIF ch = ">" THEN sym := notequal; nextCh()
				ELSE sym := less
				END
		|">": nextCh();
				IF ch = "=" THEN sym := greaterequal; nextCh()
				ELSE sym := greater
				END
		|"0" .. "9": GetNumber(); sym := number
		|quoteA, quoteB: GetString(); sym := string
		|07FX: sym := upto; nextCh()
		ELSE
			sym := null; nextCh()
		END
	END Get;

(* ------------------------------------------------------------- *)

	PROCEDURE WriteString(VAR str: ARRAY OF CHAR);
		VAR i: INTEGER;
	BEGIN
		i := -1;
		REPEAT
			INC(i);
			tokbuf[toklen] := str[i];
			INC(toklen)
		UNTIL str[i] = 0X
	END WriteString;

	PROCEDURE WriteNum(i: LONGINT);
	BEGIN
		WHILE (i < -64) OR (i > 63) DO
			tokbuf[toklen] := CHR(i MOD 128 + 128);
			INC(toklen);
			i := i DIV 128
		END;
		tokbuf[toklen] := CHR(i MOD 128);
		INC(toklen)
	END WriteNum;

	PROCEDURE WriteReal(x: REAL);
	BEGIN
		WriteNum(Reals.Int(x))
	END WriteReal;

	PROCEDURE WriteLReal(y: LONGREAL);
		VAR h, l: LONGINT;
	BEGIN
		Reals.IntL(y, h, l);
		WriteNum(h); WriteNum(l);
	END WriteLReal;
	
	PROCEDURE WriteChar(ch: CHAR);
	BEGIN tokbuf[toklen] := ch; INC(toklen)
	END WriteChar;

	PROCEDURE Insert(VAR n: TNode; VAR s: ARRAY OF CHAR; VAR res: TNode);
	BEGIN
		IF n = NIL THEN NEW(n); COPY(s, n.id); res := n
		ELSE
			IF n.id = s THEN res := n
			ELSIF s < n.id THEN Insert(n.left, s, res)
			ELSE Insert(n.right, s, res)
			END
		END
	END Insert;

	PROCEDURE WriteIdent(VAR s: ARRAY OF CHAR);
	VAR res: TNode;
	BEGIN
		Insert(root, s, res);
		IF res.ref = 0 THEN (* new *)
			res.ref := theref; WriteNum(res.ref); WriteString(s);
			INC(theref)
		ELSE WriteNum(res.ref)
		END
	END WriteIdent;

	PROCEDURE ReadToken(VAR ch: CHAR);
	BEGIN
		IF tokpos < toklen THEN
			ch := tokbuf[tokpos]; INC(tokpos);
		ELSIF sym = eof THEN reof := TRUE
		ELSE tokpos := 0;
			toklen := 0;
			WHILE (sym # eof) & (toklen <  LEN(tokbuf) - 256) DO
				IF sym = ident THEN WriteIdent(Ident); Get(sym)
				ELSE
					WriteNum(sym);
					CASE sym OF
						|number: WriteNum(numTyp);
							CASE numTyp OF
								char: WriteChar(CHR(Integer));
								|integer: WriteNum(Integer)
								|real: WriteReal(Real)
								|longreal: WriteLReal(LongReal)
							END;
							Get(sym)
						|string: WriteString(String); Get(sym)
					ELSE Get(sym)
					END
				END
			END;
			IF toklen > 0 THEN ch := tokbuf[tokpos]; INC(tokpos) ELSE reof := TRUE END
		END
	END ReadToken;

	(* ------------------- Module Rider *)

	PROCEDURE SetModule*(T: Texts.Text);
	BEGIN
		root := NIL; theref := eof + 1;
		Read := ReadToken;
		reof := FALSE; Texts.OpenReader(R, T, 0);
		symPos := -1; rpos := 0; errs := 0; nextCh();
		Get(sym)
	END SetModule;
	
	(* ------------------- File Rider *)
	
	PROCEDURE FileRead(VAR ch: CHAR);
	BEGIN Files.Read(fileR, ch); reof := fileR.eof
	END FileRead;
	
	PROCEDURE SetFile*(F: Files.File; pos: LONGINT);
	BEGIN reof := FALSE; Files.Set(fileR, F, pos); Read := FileRead
	END SetFile;


(* =============================================================== *)

PROCEDURE GetExt(name: ARRAY OF CHAR; VAR base, ext: ARRAY OF CHAR);
VAR i, j, k, l: INTEGER;
BEGIN 
	j := -1; i := 0;
	WHILE (name[i] # 0X) DO
		base[i] := name[i];
		IF name[i] = "." THEN j := i END;
		INC(i)
	END;
	ext[0] := 0X;
	IF j # -1 THEN (* get extension *)
		base[j] := 0X; k := j + 1; l := 0;
		WHILE name[k] # 0X DO ext[l] := name[k]; INC(l); INC(k) END;
		ext[l] := 0X;
	END;
END GetExt;

PROCEDURE Check(obj: Resources.Obj; VAR last: Resources.Resource; name: ARRAY OF CHAR; version: LONGINT);
VAR r: Resources.Resource; F: Files.File; base, ext: ARRAY 64 OF CHAR; T: Texts.Text; in: Files.Rider;
BEGIN
	Out.String("    "); Out.String(name); Out.String("  ");
	r := obj.res;
	WHILE (r # NIL) & (r.name # name) DO r := r.next END;
	IF r = NIL THEN
		GetExt(name, base, ext);
		IF ext = "Mod" THEN
			NEW(T); Texts.Open(T, name);
			IF T.len > 0 THEN
				NEW(r); COPY(name, r.name); r.version := version;
				r.F := Files.Base(scratch); r.pos := Files.Pos(scratch);
				SetModule(T);
				Compress(scratch);
				IF errs # 0 THEN r := NIL
				ELSE r.len := Files.Pos(scratch) - r.pos;
					Out.Real(r.len * 100.0 / T.len, 5); Out.String("% ("); Out.Int(r.len, 0); Out.String(" bytes) ");
				END
			ELSE Out.String("file not found")
			END
		ELSIF ext = "Obj" THEN
			F := Files.Old(name);
			IF F # NIL THEN
				Files.Set(in, F, 0); Files.Read(in, ch);
				IF ch = 0BBX THEN
					Files.Read(in, ch);
					IF ch = 088X THEN
						NEW(r); COPY(name, r.name); r.version := version;
						r.F := Files.Base(scratch); r.pos := Files.Pos(scratch);
						SetFile(F, 0); Copy(scratch);
						r.len := Files.Pos(scratch) - r.pos;
						Out.Int(r.len, 0); Out.String(" bytes")
					ELSE Out.String("object file is not portable")
					END
				ELSE Out.String("file is not a object file")
				END
			ELSE Out.String("file not found")
			END
		ELSE
			F := Files.Old(name);
			IF F # NIL THEN
				NEW(r); COPY(name, r.name); r.version := version;
				r.F := Files.Base(scratch); r.pos := Files.Pos(scratch);
				SetFile(F, 0); Compress(scratch);
				r.len := Files.Pos(scratch) - r.pos;
				Out.Real(r.len * 100.0 / Files.Length(F), 5); Out.String("% ("); Out.Int(r.len, 0); Out.String(" bytes) ");
			ELSE Out.String("file not found")
			END
		END;
		IF r # NIL THEN
			IF last = NIL THEN obj.res := r ELSE last.next := r END;
			last := r;
			Out.String("ok"); Out.Ln
		ELSE err := TRUE
		END
	ELSE err := TRUE;
		Out.String("duplicate entry"); Out.Ln
	END
END Check;

PROCEDURE Sign(obj: Resources.Obj; user: ARRAY OF CHAR): BOOLEAN;
VAR digest: Crypt.CipherKey; r: Resources.Resource;
	pubR, R: Crypt.Keyring; K, pubK: Crypt.Key;
	pw: ARRAY 128 OF CHAR;
	res: INTEGER;

	PROCEDURE Digest(F: Files.File; beg, end: LONGINT);
	VAR R: Files.Rider; ch: CHAR;
	BEGIN
		Files.Set(R, F, beg);
		WHILE beg < end DO
			Files.Read(R, ch);
			Crypt.MD5Write(ch);
			INC(beg)
		END;
	END Digest;

BEGIN
	Crypt.MD5Init;
	r := obj.res;
	WHILE r # NIL DO
		Crypt.MD5WriteString(r.name);
		Crypt.MD5WriteLInt(r.version);
		Digest(r.F, r.pos, r.pos + r.len);
		r := r.next
	END;
	Crypt.MD5Close(digest);
	R := Crypt.OpenKeyring("Private.Ring"); pubR := Crypt.OpenKeyring("Public.Ring");
	IF R # NIL THEN
		Crypt.FindKey(R, user, K); Crypt.FindKey(pubR, user, pubK);
		IF K = NIL THEN
			Out.String("  [no matching private key]"); Out.Ln
		ELSIF pubK = NIL THEN
			Out.String("  [no matching public key found for for private key]"); Out.Ln
		ELSIF pubK.private THEN
			Out.String(" [ERROR: user key on public keyring is a private key]"); Out.Ln
		ELSIF (K # NIL) & K.private THEN
			Crypt.GetPassword("Please enter the password", "to unlock the private key of", user,
				Fonts.This("Syntax12b.Scn.Fnt"), pw, FALSE);
			Crypt.RSASignDigest(K, pw, digest, obj.signature, res);
			IF res # 0 THEN Out.String(" wrong password")
			ELSE
				obj.key := pubK;
				RETURN TRUE
			END
		END
	ELSE Out.String(" [could not locate Private.Ring]"); Out.Ln;
	END;
	RETURN FALSE
END Sign;

PROCEDURE Link*;
VAR D: Documents.Document; S: Attributes.Scanner;
	name: ARRAY 128 OF CHAR; version: LONGINT;
	obj: Resources.Obj; lr: Resources.Resource;
	M: Objects.LinkMsg; F: Files.File;
BEGIN
	IF username = "" THEN Out.String("  user name not set "); Out.Ln; RETURN END;
	
	Out.String("Linker.Link  "); Out.Ln;
	D := Documents.MarkedDoc();
	IF D # NIL THEN
		NEW(obj); Resources.Init(obj);
		lr := NIL; err := FALSE;
		
		F := Files.New(""); Files.Set(scratch, F, 0); (* create a scratch file for code *)
		
		Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
		Attributes.Scan(S);
		WHILE S.class IN {Attributes.Name, Attributes.String} DO
			COPY(S.s, name);
			Attributes.Scan(S);
			IF S.class = Attributes.Int THEN
				version := S.i;
				Check(obj, lr, name, version);
				Attributes.Scan(S)
			ELSE err := TRUE; Out.String(name); Out.String(" version # expected"); Out.Ln
			END
		END;
		IF ~err & (lr # NIL) THEN
			IF Sign(obj, username) THEN
				M.id := Objects.set; M.name := "Resources"; M.obj := obj; M.res := -1;
				D.handle(D, M); Out.Ln
			ELSE
				Out.String(" nothing linked"); Out.Ln
			END
		ELSE Out.String(" nothing linked"); Out.Ln
		END
	ELSE Out.String(" no marked document"); Out.Ln
	END
END Link;

PROCEDURE Directory*;
VAR D: Documents.Document; M: Objects.LinkMsg; r: Resources.Resource;
BEGIN	Out.String("Linker.Directory"); Out.Ln;
	D := Documents.MarkedDoc();
	IF D # NIL THEN
		M.id := Objects.get; M.name := "Resources"; M.obj := NIL; M.res := -1;
		D.handle(D, M);
		IF (M.obj # NIL) & (M.obj IS Resources.Obj) THEN
			IF M.obj(Resources.Obj).key # NIL THEN
				Out.String("Signed by "); Out.String(M.obj(Resources.Obj).key.name)
			ELSE
				Out.String("No signature");
			END;
			Out.Ln;
			r := M.obj(Resources.Obj).res;
			WHILE r # NIL DO
				Out.String(r.name); Out.Int(r.version, 5); Out.String("  ("); Out.Int(r.len, 0); Out.String(" bytes)"); Out.Ln;
				r := r.next
			END
		ELSE Out.String(" nothing attached"); Out.Ln
		END
	ELSE Out.String(" no marked document"); Out.Ln
	END
END Directory;

PROCEDURE SetUser*;
VAR S: Attributes.Scanner;
BEGIN Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF S.class = Attributes.String THEN
		COPY(S.s, username);
	ELSE Out.String(" not set "); Out.Ln
	END
END SetUser;

PROCEDURE OpenLog*;
VAR D: Documents.Document; f: TextGadgets.Frame;
BEGIN
	NEW(D); TextDocs.InitDoc(D); (* make document wrapper *)
	NEW(f); TextGadgets.Init(f, Resources.log, FALSE);	(* create content *)
	INCL(f.state0, TextGadgets0.autoscroll); D.name := "Resources.Log";
	Documents.Init(D, f); (* and merge together *)
	D.W := Display.Width DIV 8 * 3 - 20;
	Desktops.ShowDoc(D)
END OpenLog;

BEGIN NEW(Tree); username := "";
	Texts.OpenWriter(W)
END Linker.

System.Free Linker Resources ~

