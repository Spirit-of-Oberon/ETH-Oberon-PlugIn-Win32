(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE WinPrinter; (** non-portable / source: Win32.WinPrinter.Mod *)	(* ejz  *)
	IMPORT SYSTEM, Kernel32, Kernel, Registry, User32, GDI32, COMDLG32, Win32, FileDir, Files, Objects, Display, Fonts,
		Pictures, Printers := Printer, Strings, Texts, Oberon;

	(** Installable printer for Windows GDI printing.
		21.9.98 new implementation *)

	CONST
		Bold = 0; Italics = 1; Medium = 2; Underline = 3; Strikeout = 4; Thin = 5; Light = 6;
		FontCacheSize = 8;

	TYPE
		Printer* = POINTER TO PrinterDesc;
		PrinterDesc* = RECORD (Printers.PrinterDesc)
			job, hDC, hdcMem: LONGINT;
			devMode, devNames: LONGINT;
			margin: User32.Rect;
			dpi, psdUnit: LONGINT;
			color, bkColor, textColor: LONGINT;
			page, from, to: LONGINT;
			textX, textY: LONGINT;
			pageW, pageH: INTEGER;
			offsX, offsY: INTEGER;
			newPage, showPage, setup: BOOLEAN
		END;

		Font = POINTER TO FontDesc;
		FontDesc = RECORD (Fonts.FontDesc)
			printer: BOOLEAN
		END;

	VAR
		W: Texts.Writer;
		default: FileDir.FileName;
		curUnit, curType: LONGINT;
		fontCache: ARRAY FontCacheSize OF Fonts.Font;
		curCache: LONGINT;
		printer: BOOLEAN;

	PROCEDURE ^ Finalize(F: PTR);

	PROCEDURE ClearFontCache(reload: BOOLEAN);
		VAR
			F: Fonts.Font;
			i: LONGINT;
	BEGIN
		curCache := 0; i := 0;
		WHILE i < FontCacheSize DO
			F := fontCache[i];
			IF reload & (F # NIL) & F(Font).printer THEN
				Finalize(F); F.Load(F)
			END;
			fontCache[i] := NIL; INC(i)
		END;
		Kernel.GC()
	END ClearFontCache;

	PROCEDURE CacheFont(F: Fonts.Font);
	BEGIN
		fontCache[curCache] := F;
		curCache := (curCache+1) MOD FontCacheSize
	END CacheFont;

	PROCEDURE ParseName(VAR name, family: ARRAY OF CHAR; VAR size: LONGINT; VAR style: SET; VAR class: ARRAY OF CHAR);
		VAR i, j: LONGINT;
	BEGIN
		size := 0; style := {};
		i := Strings.Length(name)-7; j := 0;
		WHILE j < 3 DO
			class[j] := name[i]; INC(i); INC(j)
		END;
		class[j] := 0X; i := i-5;
		LOOP
			CASE CAP(name[i]) OF
				"B": INCL(style, Bold); name[i] := "b"; DEC(i)
				|"M": INCL(style, Medium); name[i] := "m"; DEC(i)
				|"L": INCL(style, Light); name[i] := "l"; DEC(i)
				|"T": INCL(style, Thin); name[i] := "t"; DEC(i)
				|"I": INCL(style, Italics); name[i] := "i"; DEC(i)
				|"U": INCL(style, Underline); name[i] := "u"; DEC(i)
				|"S": INCL(style, Strikeout); name[i] := "s"; DEC(i)
			ELSE
				EXIT
			END
		END;
		WHILE (name[i] >= "0") & (name[i] <= "9") DO
			DEC(i)
		END;
		j := i+1;
		WHILE (name[j] >= "0") & (name[j] <= "9") DO
			size := 10*size + (ORD(name[j])-ORD("0")); INC(j)
		END;
		j := i; i := 0;
		WHILE i <= j DO
			family[i] := name[i]; INC(i)
		END;
		family[i] := 0X
	END ParseName;

	PROCEDURE BuildName(VAR name: ARRAY OF CHAR; family: ARRAY OF CHAR; size: LONGINT; style: SET; class: ARRAY OF CHAR);
		VAR str: ARRAY 8 OF CHAR;
	BEGIN
		COPY(family, name);
		IF size > 0 THEN
			Strings.IntToStr(size, str);
			Strings.Append(name, str)
		END;
		IF Bold IN style THEN
			Strings.AppendCh(name, "b")
		ELSIF Medium IN style THEN
			Strings.AppendCh(name, "m")
		ELSIF Light IN style THEN
			Strings.AppendCh(name, "l")
		ELSIF Thin IN style THEN
			Strings.AppendCh(name, "t")
		END;
		IF Italics IN style THEN
			Strings.AppendCh(name, "i")
		END;
		IF Underline IN style THEN
			Strings.AppendCh(name, "u")
		END;
		IF Strikeout IN style THEN
			Strings.AppendCh(name, "s")
		END;
		Strings.AppendCh(name, ".");
		Strings.Append(name, class);
		Strings.Append(name, ".Fnt")
	END BuildName;

	PROCEDURE FontInstaller(VAR lf: GDI32.LOGFONT; font: Win32.Font);
		VAR style: SET;
	BEGIN
		style := SYSTEM.VAL(SET, font.style);
		IF Bold IN style THEN
			lf.weight := GDI32.FWBold
		ELSIF Medium IN style THEN
			lf.weight := GDI32.FWMedium
		ELSIF Light IN style THEN
			lf.weight := GDI32.FWLight
		ELSIF Thin IN style THEN
			lf.weight := GDI32.FWThin
		ELSE
			lf.weight := GDI32.FWNormal
		END;
		IF Italics IN style THEN
			lf.italic := Kernel32.True
		ELSE
			lf.italic := Kernel32.False
		END;
		IF Underline IN style THEN
			lf.underline := Kernel32.True
		ELSE
			lf.underline := Kernel32.False
		END;
		IF Strikeout IN style THEN
			lf.strikeout := Kernel32.True
		ELSE
			lf.strikeout := Kernel32.False
		END;
		lf.height := -ENTIER(0.5 + font.size*curUnit / 91.4); lf.width := 0
	END FontInstaller;

	PROCEDURE [stdcall] *WinTTFontInstaller(lpelf, lpntm, type, data: LONGINT): LONGINT;
		VAR
			font: Win32.Font; F: Fonts.Font;
			lf: GDI32.ENUMLOGFONT;
			res: LONGINT;
	BEGIN
		res := 1;
		IF Kernel32.Includes(type, GDI32.TrueTypeFontType) THEN
			F := SYSTEM.VAL(Fonts.Font, data); font := SYSTEM.VAL(Win32.Font, F.ind);
			SYSTEM.MOVE(lpelf, SYSTEM.ADR(lf), SIZE(GDI32.ENUMLOGFONT));
			IF FileDir.SameName(font.family, lf.facename) THEN
				FontInstaller(lf, font);
				SYSTEM.MOVE(SYSTEM.ADR(lf), lpelf, SIZE(GDI32.ENUMLOGFONT));
				font.hfont := GDI32.CreateFontIndirect(lpelf);
				IF font.hfont # Kernel32.NULL THEN
					curType := GDI32.TrueTypeFontType; res := 0
				END
			END
		END;
		RETURN res
	END WinTTFontInstaller;

	PROCEDURE [stdcall] *WinRasterFontInstaller(lplf, lptm, type, data: LONGINT): LONGINT;
		VAR
			font: Win32.Font; F: Fonts.Font;
			lf: GDI32.LOGFONT;
			res: LONGINT;
	BEGIN
		res := 1;
		F := SYSTEM.VAL(Fonts.Font, data); font := SYSTEM.VAL(Win32.Font, F.ind);
		SYSTEM.MOVE(lplf, SYSTEM.ADR(lf), SIZE(GDI32.LOGFONT));
		IF FileDir.SameName(font.family, lf.facename) THEN
			FontInstaller(lf, font);
			SYSTEM.MOVE(SYSTEM.ADR(lf), lplf, SIZE(GDI32.LOGFONT));
			font.hfont := GDI32.CreateFontIndirect(lplf);
			IF font.hfont # Kernel32.NULL THEN
				curType := GDI32.RasterFontType; res := 0
			END
		END;
		RETURN res
	END WinRasterFontInstaller;

	PROCEDURE InitPrintDlg(P: Printer; VAR print: COMDLG32.PRINTDLG; flags: LONGINT);
		VAR i: LONGINT;
	BEGIN
		print.size := 66 (*SIZE(COMDLG32.PRINTDLG)*);
		print.hwndOwner := Win32.Display;
		IF P # NIL THEN
			print.devMode := P.devMode; print.devNames := P.devNames
		ELSE
			print.devMode := Kernel32.NULL; print.devNames := Kernel32.NULL
		END;
		print.hDC := Kernel32.NULL; print.flags := flags;
		print.from := 1; print.to := 1;
		print.min := 1; print.max := MAX(INTEGER);
		FOR i := 0 TO 2+8*4-1 DO
			print.fill[i] := 0X
		END;
		SYSTEM.PUT(SYSTEM.ADR(print.fill[2]), Kernel.hInstance)
	END InitPrintDlg;

	PROCEDURE PrinterDC(P: Printer): LONGINT;
		VAR
			print: COMDLG32.PRINTDLG;
			adrMode, adrNames: LONGINT;
			device, driver, hdc: LONGINT;
			offs: INTEGER;
	BEGIN
		IF (P # NIL) & (P.devMode # Kernel32.NULL) & (P.devNames # Kernel32.NULL) THEN
			adrNames := Kernel32.GlobalLock(P.devNames);
			adrMode := Kernel32.GlobalLock(P.devMode);
			SYSTEM.GET(adrNames, offs);
			driver := adrNames+offs;
			SYSTEM.GET(adrNames+2, offs);
			device := adrNames+offs;
			hdc := GDI32.CreateDC(driver, device, Kernel32.NULL, adrMode);
			Kernel32.GlobalUnlock(P.devMode);
			Kernel32.GlobalUnlock(P.devNames);
			RETURN hdc
		ELSE
			InitPrintDlg(NIL, print, Kernel32.LongOr(COMDLG32.PDReturnDC, COMDLG32.PDReturnDefault));
			COMDLG32.PrintDlg(SYSTEM.ADR(print));
			RETURN print.hDC
		END
	END PrinterDC;

	PROCEDURE WinLoadFont(F: Fonts.Font; family: ARRAY OF CHAR; size: LONGINT; style: SET; class: ARRAY OF CHAR);
		VAR
			raster: Win32.Font;
			tm: GDI32.TEXTMETRIC;
			abc: RECORD a, b, c: LONGINT END;
			oldFont, hDC, i: LONGINT;
	BEGIN
		i := 0;
		WHILE family[i] # 0X DO
			IF family[i] = "_" THEN family[i] := " " END; INC(i)
		END;
		raster := SYSTEM.VAL(Win32.Font, F.ind); raster.oberon := FALSE;
		COPY(family, raster.family); raster.size := size; raster.style := style;
		hDC := PrinterDC(NIL); curUnit := GDI32.GetDeviceCaps(hDC, GDI32.LOGPIXELSY); curType := -1;
		GDI32.EnumFontFamilies(hDC, SYSTEM.ADR(family), WinTTFontInstaller, SYSTEM.VAL(LONGINT, F));
		IF raster.hfont = Kernel32.NULL THEN
			COPY(family, raster.file); Strings.Append(raster.file, ".FON");
			IF GDI32.AddFontResource(SYSTEM.ADR(raster.file)) = 1 THEN
				GDI32.EnumFonts(hDC, Kernel32.NULL, WinRasterFontInstaller, SYSTEM.VAL(LONGINT, F))
			END
		END;
		IF (class[0] = "M") & (class[1] = "d") THEN F.type := Fonts.metric ELSE F.type := Fonts.font END;
		IF raster.hfont # Kernel32.NULL THEN
			oldFont := GDI32.SelectObject(hDC, raster.hfont);
			GDI32.GetTextMetrics(hDC, SYSTEM.ADR(tm));
			F.height := SHORT(tm.height-tm.extLead);
			F.minX := MAX(INTEGER); F.maxX := MIN(INTEGER);
			F.minY := -SHORT(tm.descent); F.maxY := SHORT(tm.ascent);
			i := 0;
			WHILE i < 256 DO
				IF (i >= ORD(tm.firstCh)) & (i <= ORD(tm.lastCh)) THEN
					IF curType = GDI32.TrueTypeFontType THEN
						GDI32.GetCharABCWidths(hDC, i, i, SYSTEM.ADR(abc))
					ELSE
						GDI32.GetCharWidth32(hDC, i, i, SYSTEM.ADR(abc.b));
						abc.a := 0; abc.c := 0
					END
				ELSE
					abc.a := 0; abc.b := 0; abc.c := 0;
				END;
				raster.metrics[i].dx := SHORT(abc.a + abc.b + abc.c);
				IF raster.metrics[i].dx < F.minX THEN
					F.minX := raster.metrics[i].dx
				END;
				IF raster.metrics[i].dx > F.maxX THEN
					F.maxX := raster.metrics[i].dx
				END;
				raster.metrics[i].x := SHORT(abc.a); raster.metrics[i].y := -SHORT(tm.descent);
				raster.metrics[i].p.w := SHORT(abc.b); raster.metrics[i].p.h := SHORT(tm.height);
				raster.metrics[i].p.bitmap := Kernel32.NULL;
				INC(i)
			END;
			raster.metrics[9].dx := raster.metrics[32].dx * 4;
			raster.metrics[9].x := 0; raster.metrics[9].p.w := 0;
			GDI32.SelectObject(hDC, oldFont)
		ELSE
			F.type := -2
		END;
		GDI32.DeleteDC(hDC)
	END WinLoadFont;

	PROCEDURE Substitute(F: Fonts.Font);
	BEGIN
		F.type := Fonts.substitute;
		F.height := Fonts.Default.height;
		F.minX := Fonts.Default.minX; F.maxX := Fonts.Default.maxX;
		F.minY := Fonts.Default.minY; F.maxY := Fonts.Default.maxY;
		F.ind := Fonts.Default.ind
	END Substitute;

	PROCEDURE Load(F: Fonts.Font; VAR R: Files.Rider; type: SHORTINT);
		TYPE
			RunRec = RECORD beg, end: INTEGER END;
			BoxRec = RECORD dx, x, y, w, h: INTEGER END;
		VAR
			raster: Win32.Font;
			bitmap, bitmapX, bitmapDX, bitmapW, bitmapH, RasterBase: LONGINT;
			b, n, a, k, l, m, w, h: LONGINT;
			nofBoxes: LONGINT;
			nofRuns: INTEGER;
			ch: CHAR;
			run: ARRAY 16 OF RunRec;
			box: ARRAY 256 OF BoxRec;
		PROCEDURE DummyCh(m: LONGINT);
			VAR raster: Win32.Font;
		BEGIN
			raster := SYSTEM.VAL(Win32.Font, F.ind);
			raster.metrics[m].dx := 0;
			raster.metrics[m].x := 0; raster.metrics[m].y := 0;
			raster.metrics[m].p.x := 0; raster.metrics[m].p.y := 0;
			raster.metrics[m].p.w := 0; raster.metrics[m].p.h := 0
		END DummyCh;
	BEGIN
		F.type := type; F(Font).printer := printer;
		Files.Read(R, ch); (*family*) Files.Read(R, ch); (*variant*)
		raster := SYSTEM.VAL(Win32.Font, F.ind); raster.oberon := TRUE;
		Files.ReadInt(R, F.height);
		Files.ReadInt(R, F.minX); Files.ReadInt(R, F.maxX);
		Files.ReadInt(R, F.minY); Files.ReadInt(R, F.maxY);
		Files.ReadInt(R, nofRuns);
		nofBoxes := 0; k := 0;
		WHILE k # nofRuns DO
			Files.ReadInt(R, run[k].beg); Files.ReadInt(R, run[k].end);
			nofBoxes := nofBoxes + run[k].end - run[k].beg;
			INC(k)
		END;
		IF F.type # Fonts.metric THEN
			bitmapW := 0; l := 0;
			WHILE l # nofBoxes DO
				Files.ReadInt(R, box[l].dx);
				Files.ReadInt(R, box[l].x); Files.ReadInt(R, box[l].y);
				Files.ReadInt(R, box[l].w); Files.ReadInt(R, box[l].h);
				bitmapW := bitmapW + (box[l].w + 7) DIV 8;
				INC(l)
			END;
			bitmapW := bitmapW + (-bitmapW) MOD 4; bitmapH := F.maxY - F.minY;
			SYSTEM.NEW(SYSTEM.VAL(Fonts.Font, RasterBase), bitmapW * bitmapH); (* temporary *)
			bitmapX := 0; k := 0; l := 0; m := 0;
			WHILE k < nofRuns DO
				WHILE m < run[k].beg DO DummyCh(m); INC(m) END;
				WHILE m < run[k].end DO
					raster.metrics[m].dx := box[l].dx;
					raster.metrics[m].x := box[l].x;
					raster.metrics[m].y := box[l].y;
					raster.metrics[m].p.x := bitmapX;
					raster.metrics[m].p.y := 0;
					w := box[l].w;
					raster.metrics[m].p.w := SHORT(w);
					h := box[l].h; raster.metrics[m].p.h := SHORT(h);
					bitmapDX := (w + 7) DIV 8;
					n := bitmapDX * h;
					a := RasterBase + bitmapX DIV 8;
					b := 0;
					WHILE b < n DO
						Files.Read(R, ch);
						IF ~printer THEN
							SYSTEM.PUT(a + (h - 1 - (b DIV bitmapDX)) * bitmapW + (b MOD bitmapDX), GDI32.T[ORD(ch)])
						ELSE
							SYSTEM.PUT(a + (h - 1 - (b DIV bitmapDX)) * bitmapW + (b MOD bitmapDX), GDI32.iT[ORD(ch)])
						END;
						INC(b)
					END;
					INC(l); INC(m);
					INC(bitmapX, 8*bitmapDX)
				END;
				INC(k)
			END;
			WHILE m < 256 DO DummyCh(m); INC(m) END;
			bitmap := GDI32.CreateBitmap(8*bitmapW, bitmapH, 1, 1, RasterBase);
			ASSERT(bitmap # Kernel32.NULL);
			m := 0;
			WHILE m < 256 DO raster.metrics[m].p.bitmap := bitmap; INC(m) END
		ELSE (* metric *)
			l := 0;
			WHILE l # nofBoxes DO
				Files.ReadInt(R, box[l].dx);
				Files.ReadInt(R, box[l].x); Files.ReadInt(R, box[l].y);
				Files.ReadInt(R, box[l].w); Files.ReadInt(R, box[l].h);
				INC(l)
			END;
			k := 0; l := 0; m := 0;
			WHILE k < nofRuns DO
				WHILE m < run[k].beg DO DummyCh(m); INC(m) END;
				WHILE m < run[k].end DO
					raster.metrics[m].dx := box[l].dx;
					raster.metrics[m].x := box[l].x;
					raster.metrics[m].y := box[l].y;
					raster.metrics[m].p.x := 0;
					raster.metrics[m].p.y := 0;
					INC(l); INC(m)
				END;
				INC(k)
			END;
			WHILE m < 256 DO DummyCh(m); INC(m) END;
			m := 0;
			WHILE m < 256 DO raster.metrics[m].p.bitmap := Kernel32.NULL; INC(m) END
		END
	END Load;

	PROCEDURE *Finalize(F: PTR);
		VAR f0: Win32.Font; bitmap: LONGINT;
	BEGIN
		WITH F: Fonts.Font DO
			f0 := SYSTEM.VAL(Win32.Font, F.ind);
			bitmap := f0.metrics[65].p.bitmap;
			IF bitmap # Kernel32.NULL THEN
				GDI32.DeleteObject(bitmap);
				f0.metrics[65].p.bitmap := Kernel32.NULL
			END;
			IF f0.hfont # Kernel32.NULL THEN
				GDI32.DeleteObject(f0.hfont);
				f0.hfont := Kernel32.NULL
			END;
			IF f0.file # "" THEN
				GDI32.RemoveFontResource(SYSTEM.ADR(f0.file));
				f0.file := ""
			END
		END
	END Finalize;

	PROCEDURE *OpenFont(F: Objects.Library);
		VAR
			tmp: FileDir.FileName;
			family: ARRAY 64 OF CHAR;
			class: ARRAY 8 OF CHAR;
			raster: Win32.Font;
			size: LONGINT;
			style: SET;
			f: Files.File;
			R: Files.Rider;
			id: CHAR;
	BEGIN
		WITH F: Fonts.Font DO
			NEW(raster); F.ind := SYSTEM.VAL(Objects.Index, raster);
			raster.hfont := Kernel32.NULL; raster.file := "";
			ParseName(F.name, family, size, style, class);
			IF family = "Default" THEN
				COPY(default, family)
			END;
			Registry.OberonPath("Fonts", tmp);
			Registry.GetKeyValue(Registry.CurrentUser, tmp, family, tmp);
			IF Registry.res = Registry.Done THEN
				COPY(tmp, family)
			END;
			BuildName(F.name, family, size, style, class);
			IF (class[0] = "M") & (class[1] = "d") THEN
				class[0] := "P"; class[1] := "r";
				BuildName(tmp, family, size, style, class);
				class[0] := "M"; class[1] := "d";
				f := Files.Old(tmp);
				IF f # NIL THEN
					Files.Set(R, f, 0); Files.Read(R, id);
					IF id = Fonts.FontId THEN
						Files.Read(R, F.type);
						IF F.type = Fonts.font THEN
							Load(F, R, Fonts.metric);
							Kernel.RegisterObject(F, Finalize, FALSE);
							RETURN
						END
					END
				END
			END;
			f := Files.Old(F.name);
			IF f # NIL THEN
				Files.Set(R, f, 0); Files.Read(R, id);
				IF id = Fonts.FontId THEN
					Files.Read(R, F.type);
					IF F.type = Fonts.metric THEN Load(F, R, F.type)
					ELSIF F.type = Fonts.font THEN Load(F, R, F.type)
					ELSE Substitute(F)
					END
				ELSE Substitute(F)
				END
			ELSE
				WinLoadFont(F, family, size, style, class);
				IF F.type = -2 THEN
					Substitute(F)
				END
			END;
			IF F.type # Fonts.substitute THEN
				Kernel.RegisterObject(F, Finalize, FALSE)
			END
		END
	END OpenFont;

	PROCEDURE *NewFont(): Objects.Library;
		VAR F: Font;
	BEGIN
		NEW(F); CacheFont(F);
		F.Load := OpenFont; F.GetObj := Fonts.Default.GetObj;
		RETURN F
	END NewFont;

	PROCEDURE SetupFrame(P: Printer);
	BEGIN
		IF P.margin.left < P.offsX THEN
			P.margin.left := P.offsX
		END;
		P.FrameX := SHORT(P.margin.left);
		IF P.margin.bottom < P.offsY THEN
			P.margin.bottom := P.offsY
		END;
		P.FrameY := SHORT(P.margin.bottom);
		P.FrameW := SHORT(P.Width-P.margin.left-P.margin.right);
		IF (P.FrameX+P.FrameW) > (P.offsX+P.pageW) THEN
			P.margin.right := P.Width-P.pageW-P.margin.left;
			P.FrameW := SHORT(P.Width-P.margin.left-P.margin.right)
		END;
		P.FrameH := SHORT(P.Height-P.margin.top-P.margin.bottom);
		IF (P.FrameY+P.FrameH) > (P.offsY+P.pageH) THEN
			P.margin.top := P.Height-P.pageH-P.margin.bottom;
			P.FrameH := SHORT(P.Height-P.margin.top-P.margin.bottom)
		END
	END SetupFrame;

	PROCEDURE InitMetrics*(P: Printers.Printer);
		VAR
			M: Display.ControlMsg; N: Oberon.ControlMsg;
			str: ARRAY 8 OF CHAR;
			oldDPI: LONGINT;
			def: BOOLEAN;
	BEGIN
		WITH P: Printer DO
			oldDPI := P.dpi;
			IF P.hDC = Kernel32.NULL THEN
				P.hDC := PrinterDC(P); def := P.hDC # Kernel32.NULL
			ELSE
				def := FALSE
			END;
			IF P.hDC # Kernel32.NULL THEN
				P.Width := SHORT(GDI32.GetDeviceCaps(P.hDC, GDI32.PHYSICALWIDTH));
				P.Height := SHORT(GDI32.GetDeviceCaps(P.hDC, GDI32.PHYSICALHEIGHT));
				P.pageW := SHORT(GDI32.GetDeviceCaps(P.hDC, GDI32.HORZRES));
				P.pageH := SHORT(GDI32.GetDeviceCaps(P.hDC, GDI32.VERTRES));
				P.offsX := SHORT(GDI32.GetDeviceCaps(P.hDC, GDI32.PHYSICALOFFSETX));
				P.offsY := SHORT(GDI32.GetDeviceCaps(P.hDC, GDI32.PHYSICALOFFSETY));
				P.offsY := P.Height-P.offsY-P.pageH;
				P.dpi := GDI32.GetDeviceCaps(P.hDC, GDI32.LOGPIXELSX);
				P.Depth := SHORT(GDI32.GetDeviceCaps(P.hDC, GDI32.BitsPixel))
			ELSE
				P.Width := 2480; P.Height := 3508;
				P.pageW := P.Width; P.pageH := P.Height;
				P.offsX := 0; P.offsY := 0;
				P.dpi := 300; P.Depth := 24
			END;
			P.Unit := 914400 DIV P.dpi;
			SetupFrame(P);
			IF def THEN
				GDI32.DeleteDC(P.hDC); P.hDC := Kernel32.NULL
			END;
			IF P.dpi # oldDPI THEN
				ClearFontCache(FALSE);
				str := "Md?.Fnt";
				str[2] := CHR(ORD("0") + P.dpi DIV 100 MOD 10);
				Objects.Register(str, NewFont); (* e.g. Md3.Fnt *)
				str[0] := "P"; str[1] := "r";
				Objects.Register(str, NewFont); (* e.g. Pr3.Fnt *)
				N.id := Oberon.neutralize; M.F := NIL; Display.Broadcast(N);
				M.id := Display.newprinter; M.F := NIL; Display.Broadcast(M);
				M.id := Display.suspend; M.F := NIL; Display.Broadcast(M);
				M.id := Display.restore; M.F := NIL; Display.Broadcast(M)
			END
		END
	END InitMetrics;

	PROCEDURE ^ Setup*;

	PROCEDURE Open*(P: Printers.Printer; printer, options: ARRAY OF CHAR);
		VAR
			ret, i, j: LONGINT;
			docname: ARRAY 128 OF CHAR;
			print: COMDLG32.PRINTDLG;
			doc: GDI32.DocInfo;
	BEGIN
		WITH P: Printer DO
			P.res := 1; (* no such printer *) ClearFontCache(FALSE);
			IF ~P.setup & (Printers.current = P) THEN
				Setup();
				IF ~P.setup THEN RETURN END
			END;
			InitPrintDlg(P, print, COMDLG32.PDReturnDC);
			ret := COMDLG32.PrintDlg(SYSTEM.ADR(print));
			P.hDC := print.hDC;
			IF (ret # Kernel32.False) & (P.hDC # Kernel32.NULL) THEN
				i := 0; j := -1;
				WHILE options[i] # 0X DO
					IF options[i] = Oberon.OptionChar THEN
						j := i
					END;
					INC(i)
				END;
				IF j >= 0 THEN
					INC(j); i := 0;
					WHILE options[j] # 0X DO
						docname[i] := options[j]; INC(i); INC(j)
					END;
					docname[i] := 0X
				ELSE
					docname := "Oberon Document"
				END;
				doc.size := SIZE(GDI32.DocInfo); doc.output := Kernel32.NULL;
				doc.docName := SYSTEM.ADR(docname);
				P.job := GDI32.StartDoc(P.hDC, SYSTEM.ADR(doc));
				IF P.job > 0 THEN
					P.devMode := print.devMode; P.devNames := print.devNames;
					InitMetrics(P);
					P.newPage := TRUE; P.showPage := FALSE;
					P.color := 0; P.bkColor := 0FFFFFFH; P.textColor := 0; P.page := 0;
					IF Kernel32.Includes(print.flags, COMDLG32.PDPageNums) THEN
						P.from := print.from; P.to := print.to
					ELSE
						P.from := 0; P.to := MAX(INTEGER)
					END;
					P.hdcMem := GDI32.CreateCompatibleDC(P.hDC);
					P.res := 0 (* done *)
				END
			END
		END
	END Open;

	PROCEDURE Close*(P: Printers.Printer);
	BEGIN
		WITH P: Printer DO
			IF P.hdcMem # Kernel32.NULL THEN
				GDI32.DeleteDC(P.hdcMem); P.hdcMem := Kernel32.NULL
			END;
			IF P.hDC # Kernel32.NULL THEN
				IF P.job > 0 THEN
					GDI32.EndDoc(P.hDC)
				END;
				GDI32.DeleteDC(P.hDC); P.hDC := Kernel32.NULL
			END;
			P.res := Printers.res; ClearFontCache(TRUE)
		END
	END Close;

	PROCEDURE NewPage(P: Printer);
	BEGIN
		INC(P.page);
		IF (P.page >= P.from) & (P.page <= P.to) THEN
			GDI32.StartPage(P.hDC);
			GDI32.SetMapMode(P.hDC, GDI32.MMText);
			GDI32.SetTextAlign(P.hDC, GDI32.TABaseline + GDI32.TALeft);
			GDI32.SetBkMode(P.hDC, GDI32.Transparent);
			GDI32.SetBkColor(P.hDC, P.bkColor); GDI32.SetTextColor(P.hDC, P.textColor);
			P.textX := P.FrameX; P.textY := P.FrameY;
			P.showPage := TRUE
		ELSE
			P.showPage := FALSE
		END;
		P.newPage := FALSE
	END NewPage;

	PROCEDURE Page*(P: Printers.Printer; nofcopies: INTEGER);
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				GDI32.EndPage(P.hDC)
			END;
			P.newPage := TRUE
		END
	END Page;

	PROCEDURE ReplConst*(P: Printers.Printer; x, y, w, h: INTEGER);
		VAR hBr, oldBr: LONGINT;
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				DEC(x, P.offsX); DEC(y, P.offsY);
				hBr := GDI32.CreateSolidBrush(P.color);
				oldBr := GDI32.SelectObject(P.hDC, hBr);
				GDI32.PatBlt(P.hDC, x, P.pageH-y-h, w, h, GDI32.PATCOPY);
				GDI32.SelectObject(P.hDC, oldBr);
				GDI32.DeleteObject(hBr)
			END
		END
	END ReplConst;

	PROCEDURE SetTextColor(P: Printers.Printer; bkColor, textColor: LONGINT);
	BEGIN
		WITH P: Printer DO
			IF bkColor # P.bkColor THEN
				GDI32.SetBkColor(P.hDC, bkColor); P.bkColor := bkColor
			END;
			IF textColor # P.textColor THEN
				GDI32.SetTextColor(P.hDC, textColor); P.textColor := textColor
			END
		END
	END SetTextColor;

	PROCEDURE ReplPattern*(P: Printers.Printer; x, y, w, h, patno: INTEGER);
		VAR hPat, oldPat: LONGINT;
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				DEC(x, P.offsX); DEC(y, P.offsY);
				SetTextColor(P, 0FFFFFFH, P.color);
				CASE patno OF
					2: hPat := GDI32.GetStockObject(1);
					|3: hPat := GDI32.GetStockObject(2);
					|4: hPat := GDI32.GetStockObject(3);
					|5: hPat := GDI32.GetStockObject(4);
					|6: hPat := GDI32.CreateHatchBrush(3, 0);
					|7: hPat := GDI32.CreateHatchBrush(2, 0);
					|8: hPat := GDI32.CreateHatchBrush(1, 0);
					|9: hPat := GDI32.CreateHatchBrush(0, 0);
				ELSE
					hPat := GDI32.GetStockObject(0);
				END;
				oldPat := GDI32.SelectObject(P.hDC, hPat);
				GDI32.PatBlt(P.hDC, x, P.pageH-y-h, w, h, GDI32.PATCOPY);
				GDI32.SelectObject(P.hDC, oldPat);
				GDI32.DeleteObject(hPat)
			END
		END
	END ReplPattern;

	PROCEDURE Line*(P: Printers.Printer; x0, y0, x1, y1: INTEGER);
		VAR hPen, oldPen: LONGINT;
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				DEC(x0, P.offsX); DEC(y0, P.offsY);
				DEC(x1, P.offsX); DEC(y1, P.offsY);
				hPen := GDI32.CreatePen(GDI32.PSSolid, 0, P.color);
				oldPen := GDI32.SelectObject(P.hDC, hPen);
				GDI32.MoveToEx(P.hDC, x0, P.pageH-y0, Kernel32.NULL);
				GDI32.LineTo(P.hDC, x1, P.pageH-y1);
				GDI32.SelectObject(P.hDC, oldPen);
				GDI32.DeleteObject(hPen)
			END
		END
	END Line;

	PROCEDURE Circle*(P: Printers.Printer; x0, y0, r: INTEGER);
		VAR hBr, oldBr, hPen, oldPen: LONGINT;
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				DEC(x0, P.offsX); DEC(y0, P.offsY);
				hPen := GDI32.CreatePen(GDI32.PSSolid, 0, P.color);
				hBr := GDI32.GetStockObject(5);
				oldPen := GDI32.SelectObject(P.hDC, hPen);
				oldBr := GDI32.SelectObject(P.hDC, hBr);
				GDI32.Ellipse(P.hDC, x0-r, P.pageH-(y0+r), x0+r, P.pageH-(y0-r));
				GDI32.SelectObject(P.hDC, oldPen);
				GDI32.SelectObject(P.hDC, oldBr);
				GDI32.DeleteObject(hPen);
				GDI32.DeleteObject(hBr)
			END
		END
	END Circle;

	PROCEDURE Ellipse*(P: Printers.Printer; x0, y0, a, b: INTEGER);
		VAR hBr, oldBr, hPen, oldPen: LONGINT;
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				DEC(x0, P.offsX); DEC(y0, P.offsY);
				hPen := GDI32.CreatePen(GDI32.PSSolid, 0, P.color);
				hBr := GDI32.GetStockObject(5);
				oldPen := GDI32.SelectObject(P.hDC, hPen);
				oldBr := GDI32.SelectObject(P.hDC, hBr);
				GDI32.Ellipse(P.hDC, x0-a, P.pageH-(y0+b), x0+a, P.pageH-(y0-b));
				GDI32.SelectObject(P.hDC, oldPen);
				GDI32.SelectObject(P.hDC, oldBr);
				GDI32.DeleteObject(hPen);
				GDI32.DeleteObject(hBr)
			END
		END
	END Ellipse;

	PROCEDURE Spline*(P: Printers.Printer; x0, y0, n, open: INTEGER; VAR X, Y: ARRAY OF INTEGER);
	BEGIN
HALT(99)
	END Spline;

	PROCEDURE Picture*(P: Printers.Printer; pict: Pictures.Picture; sx, sy, sw, sh, dx, dy, dw, dh, mode: INTEGER);
		VAR bmi: RECORD head: GDI32.BITMAPINFOHEADER; color: ARRAY 256 OF LONGINT END;
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				DEC(dx, P.offsX); DEC(dy, P.offsY);
				SYSTEM.MOVE(SYSTEM.ADR(pict.bmi.head), SYSTEM.ADR(bmi.head), SIZE(GDI32.BITMAPINFOHEADER));
				SYSTEM.MOVE(SYSTEM.ADR(pict.bmi.color), SYSTEM.ADR(bmi.color), 256*4);
				GDI32.StretchDIBits(P.hDC, dx, P.pageH-(dy+dh), dw, dh, sx, sy, sw, sh, SYSTEM.ADR(pict.bits^),
					SYSTEM.ADR(bmi), GDI32.DIBRGBColors, GDI32.SRCCOPY)
			END
		END
	END Picture;

	PROCEDURE UseListFont*(P: Printers.Printer; name: ARRAY OF CHAR);
	BEGIN
HALT(99)
	END UseListFont;

	PROCEDURE LoadFont(P: Printer; fname: ARRAY OF CHAR; VAR F: Fonts.Font; VAR oberon: BOOLEAN);
		VAR
			family, class, tmp: FileDir.FileName;
			size: LONGINT;
			style: SET;
			f0: Win32.Font;
	BEGIN
		printer := TRUE;
		ParseName(fname, family, size, style, class);
		class := "Pr?"; class[2] := CHR(ORD("0") + P.dpi DIV 100 MOD 10);
		BuildName(tmp, family, size, style, class);
		F := Fonts.This(tmp);
		f0 := SYSTEM.VAL(Win32.Font, F.ind);
		oberon := f0.oberon & (f0.hfont = Kernel32.NULL);
		IF oberon & ~F(Font).printer THEN
			Finalize(F); F.Load(F)
		END;
		f0 := SYSTEM.VAL(Win32.Font, F.ind);
		oberon := f0.oberon & (f0.hfont = Kernel32.NULL);
		printer := FALSE
	END LoadFont;

	PROCEDURE TranslateString(VAR s: ARRAY OF CHAR; VAR len: LONGINT);
	BEGIN
		len := 0;
		WHILE s[len] # 0X DO
			s[len] := Strings.OberonToISO[ORD(s[len])]; INC(len)
		END
	END TranslateString;

	PROCEDURE SpecialString(P: Printer; X, Y: LONGINT; VAR s: ARRAY OF CHAR; f: Fonts.Font; VAR width: LONGINT);
		VAR
			p: Win32.PatternPtr;
			pat: LONGINT;
			i, dx, xp, yp, w, h: INTEGER;
	BEGIN
		i := 0; width := 0;
		WHILE s[i] # 0X DO
			Fonts.GetChar(f, s[i], dx, xp, yp, w, h, pat);
			p := SYSTEM.VAL(Win32.PatternPtr, pat);
			GDI32.SelectObject(P.hdcMem, p.bitmap);
			IF P.color # 0FFFFFFH THEN (* needed for correct B&W printing *)
				SetTextColor(P, 0FFFFFFH, P.color);
				GDI32.BitBlt(P.hDC, X+xp, Y-yp-p.h, w, h, P.hdcMem, p.x, p.y, GDI32.SRCAND)
			END;
			IF P.color # 0 THEN (* correct color printing here? *)
				SetTextColor(P, 0H, P.color);
				GDI32.BitBlt(P.hDC, X+xp, Y-yp-p.h, w, h, P.hdcMem, p.x, p.y, GDI32.SRCPAINT)
			END;
			INC(X, LONG(dx)); INC(width, LONG(dx));
			INC(i)
		END
	END SpecialString;

	PROCEDURE contString*(P: Printer; VAR s: ARRAY OF CHAR; fnt: Fonts.Font);
		VAR
			F: Fonts.Font;
			f0: Win32.Font;
			size: User32.Size;
			len, W, oldfont: LONGINT;
			oberon: BOOLEAN;
	BEGIN
		LoadFont(P, fnt.name, F, oberon);
		IF oberon THEN
			SpecialString(P, P.textX, P.textY, s, F, W); 
			INC(P.textX, W)
		ELSE
			TranslateString(s, len);
			f0 := SYSTEM.VAL(Win32.Font, F.ind);
			oldfont := GDI32.SelectObject(P.hDC, f0.hfont);
			SetTextColor(P, 0FFFFFFH, P.color);
			GDI32.TextOut(P.hDC, P.textX, P.textY, SYSTEM.ADR(s), len);
			GDI32.GetTextExtentPoint(P.hDC, SYSTEM.ADR(s), len, SYSTEM.ADR(size));
			GDI32.SelectObject(P.hDC, oldfont);
			INC(P.textX, size.w)
		END
	END contString;

	PROCEDURE String*(P: Printers.Printer; x, y: INTEGER; s: ARRAY OF CHAR; fnt: Fonts.Font);
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				DEC(x, P.offsX); DEC(y, P.offsY);
				P.textX := x; P.textY := P.pageH-y;
				contString(P, s, fnt)
			END
		END
	END String;

	PROCEDURE ContString*(P: Printers.Printer; s: ARRAY OF CHAR; fnt: Fonts.Font);
	BEGIN
		WITH P: Printer DO
			IF P.newPage THEN NewPage(P) END;
			IF P.showPage THEN
				contString(P, s, fnt)
			END
		END
	END ContString;

	PROCEDURE UseColor*(P: Printers.Printer; red, green, blue: INTEGER);
	BEGIN
		WITH P: Printer DO
			P.color := LONG(red)+256*(LONG(green)+256*LONG(blue))
		END
	END UseColor;

	PROCEDURE GetMetric*(P: Printers.Printer; fnt: Fonts.Font): Fonts.Font;
		VAR
			name: FileDir.FileName;
			metric: Fonts.Font;
			i: LONGINT;
	BEGIN
		WITH P: Printer DO
			COPY(fnt.name, name);
			i := 0; WHILE (name[i] # ".") & (name[i] # 0X) DO INC(i) END;
			name[i] := "."; name[i+1] := "M"; name[i+2] := "d";
			name[i+3] := CHR(ORD("0") + P.dpi DIV 100 MOD 10);
			name[i+4] := "."; name[i+5] := "F"; name[i+6] := "n"; name[i+7] := "t";
			name[i+8] := 0X;
			metric := Fonts.This(name);
			IF metric.type = Fonts.substitute THEN metric := NIL END
		END;
		RETURN metric
	END GetMetric;

	PROCEDURE LoadConfig(P: Printer);
		VAR
			path, str: ARRAY 256 OF CHAR;
			adr: LONGINT; offs: INTEGER;
	BEGIN
		Registry.OberonPath("WinPrinter", path);
		Registry.GetKeyValue(Registry.CurrentUser, path, "Driver", str);
		IF Registry.res # Registry.Done THEN RETURN END;
		P.devNames := Kernel32.GlobalAlloc(Kernel32.GMemMoveable, 1024);
		adr := Kernel32.GlobalLock(P.devNames);
		SYSTEM.MOVE(SYSTEM.ADR(str), adr+8, 256);
		offs := 8; SYSTEM.PUT(adr, offs);
		Registry.GetKeyValue(Registry.CurrentUser, path, "Device", str);
		SYSTEM.MOVE(SYSTEM.ADR(str), adr+8+256, 256);
		offs := 8+256; SYSTEM.PUT(adr+2, offs);
		offs := 0; SYSTEM.PUT(adr+4, offs);
		offs := 0; SYSTEM.PUT(adr+6, offs);
		Kernel32.GlobalUnlock(P.devNames);
		Registry.GetKeyValue(Registry.CurrentUser, path, "Unit", str);
		IF str = "ThousendthsOfInches" THEN
			P.psdUnit := COMDLG32.PSDInThousendthsOfInches
		ELSIF str = "HundredthsOfMillimeters" THEN
			P.psdUnit := COMDLG32.PSDInHundredthsOfMillimeters
		ELSE
			HALT(99)
		END;
		Registry.GetKeyValue(Registry.CurrentUser, path, "Left", str); Strings.StrToInt(str, P.margin.left);
		Registry.GetKeyValue(Registry.CurrentUser, path, "Right", str); Strings.StrToInt(str, P.margin.right);
		Registry.GetKeyValue(Registry.CurrentUser, path, "Top", str); Strings.StrToInt(str, P.margin.top);
		Registry.GetKeyValue(Registry.CurrentUser, path, "Bottom", str); Strings.StrToInt(str, P.margin.bottom)
	END LoadConfig;

	PROCEDURE Init*(P: Printer);
	BEGIN
		P.gen := "WinPrinter.Install";
		P.InitMetrics := InitMetrics;
		P.Open := Open;
		P.Close := Close;
		P.Page := Page;
		P.ReplConst := ReplConst; 
		P.ReplPattern := ReplPattern;
		P.Line := Line;
		P.Circle := Circle;
		P.Ellipse := Ellipse;
		P.Spline := Spline;
		P.Picture := Picture;
		P.UseListFont := UseListFont;
		P.String := String;
		P.ContString := ContString;
		P.UseColor := UseColor;
		P.GetMetric := GetMetric;
		P.hDC := Kernel32.NULL; P.hdcMem := Kernel32.NULL;
		P.job := 0; P.dpi := 0; P.psdUnit := 0;
		P.devMode := Kernel32.NULL; P.devNames := Kernel32.NULL;
		P.margin.left := 0; P.margin.right := 0;
		P.margin.top := 0; P.margin.bottom := 0;
		P.newPage := FALSE; P.showPage := FALSE;
		P.color := 0; P.setup := FALSE;
		P.page := 0; P.from := 0; P.to := MAX(INTEGER);
		P.textX := 0; P.textY := 0;
		P.pageW := 0; P.pageH := 0;
		P.offsX := 0; P.offsY := 0;
		LoadConfig(P)
	END Init;

	PROCEDURE Install*;
		VAR P: Printer;
	BEGIN
		NEW(P); Init(P);
		Printers.Install(P);
	END Install;

	PROCEDURE InitPageSetupDlg(P: Printer; VAR page: COMDLG32.PAGESETUPDLG);
	BEGIN
		page.size := SIZE(COMDLG32.PAGESETUPDLG);
		page.hwndOwner := Win32.Display;
		IF P # NIL THEN
			page.devMode := P.devMode; page.devNames := P.devNames
		ELSE
			page.devMode := Kernel32.NULL; page.devNames := Kernel32.NULL
		END;
		page.paperSize.x := 0; page.paperSize.y := 0;
		page.minMargin.left := 0; page.minMargin.right := 0;
		page.minMargin.top := 0; page.minMargin.bottom := 0;
		IF (P # NIL) & (P.psdUnit # 0) THEN
			page.flags := Kernel32.LongOr(P.psdUnit, COMDLG32.PSDMargins);
			IF P.psdUnit = COMDLG32.PSDInThousendthsOfInches THEN
				page.margin.left := (P.margin.left*1000+(P.dpi DIV 2)) DIV P.dpi;
				page.margin.right := (P.margin.right*1000+(P.dpi DIV 2)) DIV P.dpi;
				page.margin.top := (P.margin.top*1000+(P.dpi DIV 2)) DIV P.dpi;
				page.margin.bottom := (P.margin.bottom*1000+(P.dpi DIV 2)) DIV P.dpi
			ELSIF P.psdUnit = COMDLG32.PSDInHundredthsOfMillimeters THEN
				page.margin.left := (P.margin.left*2540+(P.dpi DIV 2)) DIV P.dpi;
				page.margin.right := (P.margin.right*2540+(P.dpi DIV 2)) DIV P.dpi;
				page.margin.top := (P.margin.top*2540+(P.dpi DIV 2)) DIV P.dpi;
				page.margin.bottom := (P.margin.bottom*2540+(P.dpi DIV 2)) DIV P.dpi
			ELSE
				HALT(99)
			END
		ELSE
			page.flags := 0;
			page.margin.left := 0; page.margin.right := 0;
			page.margin.top := 0; page.margin.bottom := 0
		END;
		page.hInstance := Kernel.hInstance;
		page.custData := 0;
		page.pageSetupHook := Kernel.hInstance;
		page.pagePaintHook := Kernel.hInstance;
		page.pageSetupTemplateName := Kernel.hInstance;
		page.pageSetupTemplate := Kernel.hInstance
	END InitPageSetupDlg;

	PROCEDURE CopyString(lpString: LONGINT; VAR str: ARRAY OF CHAR);
		VAR i: LONGINT; ch: CHAR;
	BEGIN
		i := 0;
		SYSTEM.GET(lpString, ch);
		WHILE ch # 0X DO
			str[i] := ch; INC(i);
			INC(lpString); SYSTEM.GET(lpString, ch)
		END;
		str[i] := 0X
	END CopyString;

	PROCEDURE StoreConfig(P: Printer);
		VAR
			path, str: ARRAY 256 OF CHAR;
			adrNames: LONGINT; offs: INTEGER;
	BEGIN
		Registry.OberonPath("WinPrinter", path);
		adrNames := Kernel32.GlobalLock(P.devNames);
		SYSTEM.GET(adrNames, offs);
		CopyString(adrNames+offs, str);
		Registry.SetKeyValue(Registry.CurrentUser, path, "Driver", str);
		SYSTEM.GET(adrNames+2, offs);
		CopyString(adrNames+offs, str);
		Registry.SetKeyValue(Registry.CurrentUser, path, "Device", str);
		IF P.psdUnit = COMDLG32.PSDInThousendthsOfInches THEN
			Registry.SetKeyValue(Registry.CurrentUser, path, "Unit", "ThousendthsOfInches")
		ELSIF P.psdUnit = COMDLG32.PSDInHundredthsOfMillimeters THEN
			Registry.SetKeyValue(Registry.CurrentUser, path, "Unit", "HundredthsOfMillimeters")
		ELSE
			HALT(99)
		END;
		Strings.IntToStr(P.margin.left, str); Registry.SetKeyValue(Registry.CurrentUser, path, "Left", str);
		Strings.IntToStr(P.margin.right, str); Registry.SetKeyValue(Registry.CurrentUser, path, "Right", str);
		Strings.IntToStr(P.margin.top, str); Registry.SetKeyValue(Registry.CurrentUser, path, "Top", str);
		Strings.IntToStr(P.margin.bottom, str); Registry.SetKeyValue(Registry.CurrentUser, path, "Bottom", str)
	END StoreConfig;

	(** Page Setup dialog *)
	PROCEDURE Setup*;
		VAR
			P: Printer;
			page: COMDLG32.PAGESETUPDLG;
	BEGIN
		IF (Printers.current # NIL) & (Printers.current IS Printer) THEN
			P := Printers.current(Printer)
		ELSE
			RETURN
		END;
		InitPageSetupDlg(P, page);
		IF COMDLG32.PageSetupDlg(SYSTEM.ADR(page)) = 0 THEN
			RETURN
		END;
		IF Kernel32.Includes(page.flags, COMDLG32.PSDInThousendthsOfInches) THEN
			P.margin.left := (page.margin.left*P.dpi + 500) DIV 1000;
			P.margin.right := (page.margin.right*P.dpi + 500) DIV 1000;
			P.margin.top := (page.margin.top*P.dpi + 500) DIV 1000;
			P.margin.bottom := (page.margin.bottom*P.dpi + 500) DIV 1000;
			P.psdUnit := COMDLG32.PSDInThousendthsOfInches
		ELSIF Kernel32.Includes(page.flags, COMDLG32.PSDInHundredthsOfMillimeters) THEN
			P.margin.left := (page.margin.left*P.dpi + 1270) DIV 2540;
			P.margin.right := (page.margin.right*P.dpi + 1270) DIV 2540;
			P.margin.top := (page.margin.top*P.dpi + 1270) DIV 2540;
			P.margin.bottom := (page.margin.bottom*P.dpi + 1270) DIV 2540;
			P.psdUnit := COMDLG32.PSDInHundredthsOfMillimeters
		ELSE
			HALT(99)
		END;
		P.devMode := page.devMode; P.devNames := page.devNames;
		InitMetrics(P); P.setup := TRUE;
		StoreConfig(P); Printers.Install(P)
	END Setup;

	PROCEDURE [stdcall] *WinFontEnum(lpelf, lpntm, type, data: LONGINT): LONGINT;
		VAR lf: GDI32.ENUMLOGFONT;
	BEGIN
		IF Kernel32.Includes(type, GDI32.TrueTypeFontType) THEN
			SYSTEM.MOVE(lpelf, SYSTEM.ADR(lf), SIZE(GDI32.ENUMLOGFONT));
			Texts.WriteString(W, lf.facename); Texts.WriteLn(W)
		END;
		RETURN 1
	END WinFontEnum;

	(** list available font families *)
	PROCEDURE ListFonts*;
		VAR hDC: LONGINT;
	BEGIN
		hDC := PrinterDC(NIL);
		GDI32.EnumFontFamilies(hDC, Kernel32.NULL, WinFontEnum, Kernel32.NULL);
		GDI32.DeleteDC(hDC);
		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END ListFonts;

	PROCEDURE init();
		VAR
			class: FileDir.FileName;
			style: SET;
			size: LONGINT;
	BEGIN
		ClearFontCache(FALSE); printer := FALSE;
		ParseName(Fonts.Default.name, default, size, style, class);
		Texts.OpenWriter(W)
	END init;

BEGIN
	init()
END WinPrinter.

PrinterInfo.Panel

WinPrinter.Install
WinPrinter.Setup
WinPrinter.ListFonts

System.Set Fonts Syntax := Tahoma ~
System.Set Fonts Oberon := Arial ~
System.Set Fonts Courier := "Courier New" ~
