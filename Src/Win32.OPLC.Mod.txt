(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE OPLC; (** non-portable / source: Win32.OPLC.Mod *)	(* NM 19.6.94 *)
(*
	code generator for Intel i386, i387/ i486 - Diplomarbeit ETH-Zürich WS 92/93
	by Niklaus Mannhart, 87-913-117I
	author's address: 	Himmelrich 22
		6340 Baar, Switzerland
		e-mail: mannhart@inf.ethz.ch	phone: +41 (0)42 31 40 33

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

	March the 2nd 1993
	Release 12.12.93 / Release 1.0
	Release 12.1.94 / Release 1.1 (fixed: bugs in OPLL.LoadProc and floating point compare (OPLL.FloadCmp))
	Release 13.3.94 / Release 1.2 (fixed: bug in index function (dynArray[0,0]))
	Release 23.6.94  / Release 1.3 (fixed: bug in OPLL.Load, iOPC.SYSgetputReg, floating point problem in OPLL.PushRegs);
	Release 30.8.94 / 1.4 (mh fixed: indexing dynArray[const, const]; SYSTEM.NEW(p, int); PushDynArrLen)
*)

	IMPORT Kernel, PLT := OPLT, PLL := OPLL, PLO := OPLO, SYSTEM;

	CONST
		(* structure forms *)
		Undef = 0; Byte = 1; Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6;
		Real = 7; LReal = 8; Set = 9; String = 10; NilTyp = 11; NoTyp = 12;
		Pointer = 13; ProcTyp = 14; Comp = 15;
		intSet = {SInt..LInt}; realSet = {Real, LReal};

		(* composite structure forms *)
		Basic = 1; Array = 2; DynArr = 3; Record = 4;
		
		(* item base modes (=object modes) *)
		Var = 1; Par = 2; VarPar = 3; Con = 4; LProc = 6; XProc = 7; CProc = 9; TProc = 14;
		
		(* item modes for Intel i386 (must not overlap item basemodes,  > 13) *)
		Reg = PLO.Reg; Abs = PLO.Abs; RegRel = PLO.RegRel; Coc = PLO.Coc;

		(* base type and method offset *)
		BaseTypeOffs = -8;

		(* POINTER TO ARRAY offset *)
		PtrToArrOffs* = 8; (* len descriptor start *)

		(* static link address *)
		StaticLinkAdr = 8;

		(* relations *)
		eql = 9; neq = 10; lss = 11; leq = 12; gtr = 13; geq = 14;
		
		false = 0; true = 1; nil = 0;

		(* conditions: the same as opcodes je, jne,....  *)
		EQ = PLL.je; NE = PLL.jne; LT = PLL.jl; LE = PLL.jle; GT = PLL.jg; GE = PLL.jge; 
		AB = PLL.ja; AE = PLL.jae; BL = PLL.jb; BE = PLL.jbe;
		CS = PLL.jc; CC = PLL.jnc; always = PLL.jmp; never = -1;

	(* opcode of pseudo RISC processor *)
	(* integer operations *)
	ld = PLL.ld; 	store = PLL.store; 	lea = PLL.lea; 	push = PLL.push; 
	pop = PLL.pop; 	ldProc = PLL.ldProc;	ldbdw = PLL.ldbdw; 
	ldwdw = PLL.ldwdw; 	ldbw = PLL.ldbw; (* sign extended load; b: byte; w: word; dw: dword *)
	ldbdwu = PLL.ldbdwu;	ldbwu = PLL.ldbwu; (* zero extended load *)
	getReg = PLL.getReg;
	add = PLL.add; 	sub = PLL.sub; 	mul = PLL.mul; 	div = PLL.div; 
	mod = PLL.mod ; 	neg = PLL.neg; 	abs = PLL.abs;	cmp = PLL.cmp; 
	je = PLL.je; 	jne = PLL.jne; 	jl = PLL.jl;	jg = PLL.jg;	ja = PLL.ja; 
	jmp = PLL.jmp; 	jmpReg = PLL.jmpReg;	sete = PLL.sete; 
	tne = PLL.tne;	tle = PLL.tle;	tae = PLL.tae;	to =  PLL.to;
	trap = PLL.trap;	or = PLL.or; 	xor = PLL.xor; 
	and = PLL.and; 	not = PLL.not;	bt = PLL.bt; 	btr = PLL.btr; 
	bts = PLL.bts;	call = PLL.call; 	callReg = PLL.callReg; 	xcall = PLL.xcall; 
	ret = PLL.ret; 	enter = PLL.enter; 	leave = PLL.leave;	sal = PLL.sal; 
	sar = PLL.sar ; 	shr = PLL.shr; 	rol = PLL.rol;	cld = PLL.cld; 
	repMovs = PLL.repMovs; 	cmpString = PLL.cmpString;

	(* floating point operations *)
	fload = PLL.fload; 	fstore = PLL.fstore; 	fild = PLL.fild;
	fadd = PLL.fadd; 	fsub = PLL.fsub; 	fmul = PLL.fmul;	fdiv = PLL.fdiv; 
	fabs = PLL.fabs; 	fchs = PLL.fchs; 	fcmp = PLL.fcmp;

	(* special *)
	phi = PLL.phi; 	pushReg = PLL.pushReg;	popReg = PLL.popReg; 	case = PLL.case;
	entier = PLL.entier;	short = PLL.short;	label = PLL.label;

	(* predefined registers of the pseudo RISC machine *)
	ESP = PLL.RiscESP; FP = PLL.RiscFP; none = PLL.none;
	
	(* scale factor *)
	noScale = PLO.noScale;
	
	TYPE 
		Item* = RECORD
			mode*, mnolev*, scale*: SHORTINT;	(* mnolev < 0 -> mno (module number) = -mnolev *)
			typ*: PLT.Struct; node*: PLL.Node;
			adr*, offs*, inx*, descReg*, descOffs*: LONGINT
		END;
(*
	mode:	item mode
	mnolev: 	module number or nesting level
	typ: 	type of item
	node: 	link to node -> used for PLL.AbsAccess and alias analysis
	adr, offs, inx:	see below
	descReg: 	descriptor register (dynamic array)
	descOffs: 	descriptor offset (dynamic array)
*)

(* Items: 

	the fields mnolev and typ are set for all modes in OPV.
	mnolev is not valid for non-allocated constants.

Intel i386 :
   mode  | adr    offs     inx
---------------------------------
 1 Var   | vadr	(adr will be stored in obj.linkadr too. 
         |	Local variables)
 2 VarPar| vadr   	
 3 Con   | val    	(adr: Boolean, Byte..LInt)
         | adr    len(of string)
         | adr   	(LReal, Real)
 6 LProc | adr            
 7 XProc | pno    LinkAdr 	(LinkAdr will be stored in obj.linkadr too)
 9 CProc |     	
13 TProc | TagAdr Off
         |
15 Reg   | reg          
16 Abs   | vadr            reg	(inx = none: no index register)
17 RegRel| reg    off      reg	(inx = none: no index register)
18 Coc   | CC     Tjmp     Fjmp
*)

		Label* = LONGINT;
		
	CONST
		nilval = 0;	(* value of constant NIL *)
		Nil* = -1;	  (* label nil *)
		BUG = 40;      (* Trap code for Bugs in iOP2 *)
		
	MaxSet = 31;	(* must be >= 15, else the bootstraped compiler cannot run (IN-tests) *)
	MinLInt = 80000000H;	(* i386: -2147483648*)
	MaxLInt =  7FFFFFFFH;	(* i386: 2147483647*)

	VAR
	level*: SHORTINT; 	(* nesting level *)
	pc*: INTEGER; 	(* pc of pseudo RISC machine *)
	RiscCodeErr*: BOOLEAN; 	(* risc code error -> out of risc code space *)
	inxchk, ovflchk, typchk: BOOLEAN;	(* index, overflow, range and type checks *)
	True, False, Stack: Item; 	(* constant items True, False and Stack *)
	formTab: ARRAY 16 OF SHORTINT; 
	CCtab: ARRAY 2, (geq-eql+1) OF INTEGER;	(* condition code table, CCtab[0] = integer; CCtab[1] = char *)
	InvCCtab: ARRAY (CC-EQ) DIV 32 + 1 OF INTEGER; (* inverted conditon code table*)
	newRec: PROCEDURE(tag: Kernel.Tag; VAR p: LONGINT);
	newSys: PROCEDURE(size: LONGINT; VAR p: LONGINT);
	newArr: PROCEDURE(nofdim, nofelem: LONGINT; eltag: Kernel.Tag; VAR p: LONGINT);
	KernelRoutines: ARRAY 3 OF LONGINT;


PROCEDURE Init* (opt: SET);
	CONST
		inx = 0; ovfl = 1; typ = 3; ptr = 5;
BEGIN
	pc := 0; level := 0;
	inxchk:= inx IN opt; ovflchk:= ovfl IN opt; typchk:= typ IN opt; PLL.ptrinit := ptr IN opt;
END Init;

PROCEDURE IncReg (pReg: LONGINT);
(* increments field used in the pseudo code where reg was first used *)
BEGIN
	IF ~RiscCodeErr & (pReg >= 0) THEN INC (PLL.Instr[pReg].used) END (* pReg < 0: special registers  *)
END IncReg;

PROCEDURE InitInstr (op: INTEGER; mode, form: SHORTINT; node: PLL.Node);
(* initialize the pseudo instruction at position pc *)
BEGIN
	IF pc >= PLL.RiscCodeLen THEN
		IF ~RiscCodeErr THEN
			PLO.Err(211);
			RiscCodeErr := TRUE
		END;
		pc := 0
	END;
	ASSERT ((mode >= 0) & (mode <= 3));
	ASSERT ((op MOD 32 = 0) & (op > 0));
	PLL.Instr [pc].op := op + formTab[form] + mode * 8; PLL.Instr [pc].node := SYSTEM.VAL (PLL.WeakNode, node);
	PLL.Instr [pc].src1 := none; PLL.Instr [pc].src2 := none; PLL.Instr [pc].inx := none;
	PLL.Instr [pc].dest := pc; PLL.Instr [pc].used := 0; PLL.Instr [pc].hint := PLL.noHint;
	PLL.Instr [pc].pc := PLL.Nil; PLL.Instr [pc].reg := PLL.Nil
END InitInstr;

PROCEDURE GenLoad (op: INTEGER; VAR z, x: Item);
(* loads x into register; used for: ld, ldbdw, ldwdw, ldbw, lea, fload, fild, ldbdwu, ldwdwu, lbdwu *)
BEGIN
	CASE x.mode OF
		Abs:
			InitInstr (op, PLO.MemReg, x.typ.form, x.node);
			PLL.Instr[pc].src2 := x.adr; PLL.Instr[pc].inx := x.inx; 
			PLL.Instr[pc].scale := x.scale; PLL.Instr[pc].src1 := none;
			IncReg (x.inx)
	  | Var, Par:
			ASSERT (x.mnolev > 0);
			InitInstr (op, PLO.MemReg, x.typ.form, x.node);
			PLL.Instr[pc].src2 := x.adr; PLL.Instr[pc].inx := none;
			PLL.Instr[pc].scale := x.scale;
			PLL.Instr[pc].src1 := FP
	  | Con:
			ASSERT ( (op # lea) & (op # fload) & (op # fild) & (op # pop) );
			ASSERT ( (op < ldbdw) OR (op > ldbwu) ); 
			InitInstr (op, PLO.ImmReg, x.typ.form, x.node);
			PLL.Instr[pc].src2 := x.adr
	  | Reg:
			ASSERT ((op # lea) & (op # fild));
			InitInstr (op, PLO.RegReg, x.typ.form, x.node);
			PLL.Instr[pc].src1 := x.adr;
			IF op # pop THEN IncReg (x.adr) END
	  | RegRel:
			InitInstr (op, PLO.MemReg, x.typ.form, x.node);
			PLL.Instr[pc].src1 := x.adr; PLL.Instr[pc].src2 := x.offs; PLL.Instr[pc].inx := x.inx;
			PLL.Instr[pc].scale := x.scale;
			IncReg (x.adr); IncReg (x.inx)
	ELSE HALT (BUG)
	END;
	z.adr := pc; z.mode := Reg;
	INC (pc)
END GenLoad;

PROCEDURE GenPush (VAR x: Item); 
(* push x *)
	VAR dummy: Item;
BEGIN
	ASSERT ((x.mode = Reg) OR (x.mode = Con));
	dummy.node := NIL;
	GenLoad (push, dummy, x)
END GenPush;

		PROCEDURE GenPop (VAR x: Item); 
	(* pop x *)
		VAR dummy: Item;
	BEGIN
		(* x.typ is initialized by the caller *)
		dummy.node := NIL;
		x.mode := Reg; x.adr := pc; x.node := NIL;
		GenLoad (pop, dummy, x);
	END GenPop;

	PROCEDURE GenLoadProc (op: INTEGER; VAR z: Item; val: LONGINT; node: PLL.Node);
	(* ldProc, ldXProc *)
	BEGIN
		InitInstr (op, PLO.ImmReg, LInt, node);
		z.mode := Reg; z.typ := PLT.sysptrtyp; z.adr := pc; 
		PLL.Instr [pc].src1 := val;
		INC (pc)
	END GenLoadProc;

PROCEDURE GenStore (op: INTEGER; VAR z, x: Item); 
(* z := x; used for: store, fstore, fist *)
BEGIN
	ASSERT (x.mode = Reg);
	CASE z.mode OF
		Abs:
			InitInstr (op, PLO.RegMem, z.typ.form, z.node); PLL.Instr[pc].dest := x.adr;
			PLL.Instr[pc].src2 := z.adr; PLL.Instr[pc].inx := z.inx; PLL.Instr[pc].scale := z.scale;
			PLL.Instr[pc].src1 := none;
			IncReg (z.inx)
	  | Var, Par:
			ASSERT (z.mnolev > 0);
			InitInstr (op, PLO.RegMem, z.typ.form, z.node); PLL.Instr[pc].dest := x.adr;
			PLL.Instr[pc].src2 := z.adr; PLL.Instr[pc].inx := none;
			PLL.Instr[pc].src1 := FP
	  | RegRel:
			InitInstr (op, PLO.RegMem, z.typ.form, z.node); PLL.Instr[pc].dest := x.adr;
			PLL.Instr[pc].src1 := z.adr; PLL.Instr[pc].src2 := z.offs; PLL.Instr[pc].inx := z.inx;
			PLL.Instr[pc].scale := z.scale;
			IncReg (z.adr); IncReg (z.inx)
	ELSE HALT (BUG)
	END;
	IF op # getReg THEN IncReg (x.adr) END;
	INC (pc)
END GenStore;


	PROCEDURE GenPopReg (hint, form: SHORTINT); 
	(* popReg *)
	BEGIN
		IF hint = PLL.noHint THEN InitInstr (popReg, 0, 0, NIL)
		ELSE
			InitInstr (popReg, PLO.RegReg, form, NIL);
			PLL.Instr [pc].hint := hint;
		END;
		INC (pc)
	END GenPopReg;


PROCEDURE Gen0 (op: INTEGER);
(* used for: cld, pushReg, label *)
BEGIN
	InitInstr (op, 0, 0, NIL);
	INC (pc)
END Gen0;

PROCEDURE Gen1 (op: INTEGER; adr: LONGINT; node: PLL.Node);
(* used for: je, jne, jl, jle, jg, jge, ja, jae, jb, jbe, jc, jnc, jmp, jmpReg, trap, te, tne, ta, tae, to, ret, enter, leave *)
BEGIN
	IF op = jmpReg THEN 
		InitInstr (op, PLO.RegReg, LInt, node); IncReg (adr)
	ELSE InitInstr (op, 0, 0, node)
	END;
	PLL.Instr[pc].src2 := adr;
	INC (pc)
END Gen1;

PROCEDURE Gen2 (op: INTEGER; VAR z, x: Item);
(* z := op (x); used for: neg, not, abs, fabs, fchs, short, entier *)
BEGIN
	ASSERT (x.mode = Reg);
	InitInstr (op, PLO.RegReg, x.typ.form, x.node);
	PLL.Instr[pc].src1 := x.adr;
	IncReg (x.adr);
	z.adr := pc; z.mode := Reg;
	INC (pc)
END Gen2;

PROCEDURE Gen3 (op: INTEGER; VAR z, x, y: Item);
(* z := op (x, y); used for: add, sub, mul, div, mod, or, xor, and, btr, bts, sal,sar, shr, rol, fadd, fsub, fmul, fdiv *)
BEGIN
	IF y.mode = Con THEN InitInstr (op, PLO.ImmReg, x.typ.form, x.node)
	ELSE 
		InitInstr (op, PLO.RegReg, x.typ.form, x.node); IncReg (y.adr)
	END;
	PLL.Instr[pc].src1 := x.adr; PLL.Instr[pc].src2 := y.adr;
	IncReg (x.adr);
	IF (op = div) OR (op = mod) THEN PLL.Instr[x.adr].hint := PLL.tryEAX
	ELSIF (op >= sal) & (op <= rol) & (y.mode # Con) THEN PLL.Instr[y.adr].hint := PLL.useECX
	ELSIF (op = mul) & (x.typ.form = SInt) THEN PLL.Instr [x.adr].hint := PLL.tryEAX
	END;
	z.adr := pc; z.mode := Reg;
	INC (pc)
END Gen3;


	PROCEDURE PushRegs*;
	(* pushReg *)
	BEGIN
		Gen0 (pushReg)
	END PushRegs;

	PROCEDURE GenCall (op: INTEGER; adr, parSize: LONGINT; node: PLL.Node);
	(* used for call, xcall, callReg *)
	BEGIN
		IF op = callReg THEN
			InitInstr (op, PLO.RegReg, LInt, node); IncReg (adr)
		ELSE
			InitInstr (op, 0, 0, node)
		END;
		PLL.Instr [pc].src1 := parSize; PLL.Instr[pc].src2 := adr;
		INC (pc)
	END GenCall;


PROCEDURE GenFlags (op: INTEGER; VAR x, y: Item);
(* x op y; used for: cmp, bt, fcmp, cmpString *)
BEGIN
	IF y.mode = Con THEN InitInstr (op, PLO.ImmReg, x.typ.form, x.node)
	ELSE
		InitInstr (op, PLO.RegReg, x.typ.form, x.node); IncReg (y.adr)
	END;
	PLL.Instr[pc].src1 := x.adr; PLL.Instr[pc].src2 := y.adr;
	IncReg (x.adr);
	INC (pc)
END GenFlags;

PROCEDURE GenSetC (op: INTEGER; VAR z: Item); (* set condition *)
(* used for: sete, setne, setl, setle, setg, setge, seta, setae, setb, setbe, setc, setne *)
BEGIN
	InitInstr (op, PLO.RegReg, SInt, z.node);
	z.adr := pc; z.mode := Reg;
	INC (pc)
END GenSetC;

PROCEDURE GenRepMovs (VAR z, x, nofElem: Item; moveSize: SHORTINT); (* z := x; block copy *)
(* used for: repMovs *)
BEGIN
	InitInstr (repMovs, 0, 0, NIL);
	PLL.Instr [pc].dest := z.adr; (* destination address *)
	PLL.Instr [pc].src1 := x.adr; (* source address *)
	PLL.Instr [pc].src2 := nofElem.adr; (* nofelements *)
	PLL.Instr [pc].inx := moveSize; (* move size: 8, 16 or 32 bit *)
	INC (pc)
END GenRepMovs;

PROCEDURE GenPhi (reg0, reg1: LONGINT); 
(* phi *)
BEGIN
	InitInstr (phi, 0, 0, NIL);
	PLL.Instr [pc].src1 := reg0; PLL.Instr [pc].src2 := reg1;
	PLL.Instr [reg1].hint := SHORT (-1 - reg0);
	INC (pc)
END GenPhi;

PROCEDURE  MakeCon (VAR cons: Item; typ: PLT.Struct; val: LONGINT);
(* makes a constant item cons *)
BEGIN
	cons.mode := Con; cons.adr := val; cons.offs := 0; cons.typ := typ; cons.node := NIL
END MakeCon;

PROCEDURE SetCC (VAR x: Item; cc: LONGINT); 
(* set condition code *)
BEGIN
	x.typ := PLT.booltyp; x.mode := Coc; x.adr := cc; x.offs := Nil; x.inx := Nil; x.node := NIL
END SetCC;

PROCEDURE DefLabel* (VAR L: Label);
BEGIN
	L := pc;
	Gen0 (label)
END DefLabel;

PROCEDURE FixLinkWith (L, val: Label);
	VAR L1: Label;
(* -2 - Label = position in the pseudo code *)
BEGIN
	IF ~RiscCodeErr THEN
		ASSERT ((L < 0) & (val >= 0));
		L := -2 - L;
		WHILE L # Nil DO
			L1 := -2 - PLL.Instr[L].src2;
			PLL.Instr[L].src2 := val;
			L := L1
		END
	END
END FixLinkWith;

PROCEDURE FixLink* (L: Label);
	VAR L1: Label;
(* -2 - Label = position in the pseudo code *)
BEGIN
	IF ~RiscCodeErr THEN
		ASSERT (L < 0);
		L := -2 - L;
		IF L # Nil THEN
			REPEAT
				L1 := -2 - PLL.Instr[L].src2;
				PLL.Instr[L].src2 := pc;
				L := L1
			UNTIL L = Nil;
			Gen0 (label)
		END
	END
END FixLink;


	PROCEDURE MergedLinks (L0, L1: Label): Label;
		VAR L2, L3: Label;
	(* -2 - Label = position in the pseudo code *)
	BEGIN
		L2 := -2 - L0;
		IF ~RiscCodeErr & (L2 # Nil) THEN
			LOOP 
				L3 := -2 - PLL.Instr[L2].src2;
				IF L3 = Nil THEN EXIT END;
				L2 := L3
			END;
			PLL.Instr[L2].src2 := L1;
			RETURN L0
		ELSE 
			RETURN L1
		END
	END MergedLinks;


PROCEDURE Jmp* (VAR loc: Label; node: PLL.Node);
(* jump ; forward jumps are encoded as -2-pc, where pc is the address of the last jump -> fixup chain *)
	VAR pos: Label;
BEGIN
	IF loc < 0 THEN (* forward jump *)
		pos := loc; loc := -2-pc;
		Gen1 (jmp, pos, node)
	ELSE (* backward jump *)
		Gen1 (jmp, loc, node)
	END
END Jmp;

PROCEDURE^ load (VAR x: Item);

	
PROCEDURE Jcc* (VAR x: Item; VAR loc: Label; node: PLL.Node); 
(* conditional jump ; forward jumps are encoded as -2-pc, where pc is the address of the last jump -> fixup chain *)
BEGIN
	IF x.mode # Coc THEN
		ASSERT (x.typ.form = Bool);
		load (x); GenFlags (cmp, x, True);
		SetCC (x, EQ)
	END;
	IF loc < 0 THEN (* forward jump *)
		Gen1 (SHORT (x.adr), x.offs, node); (* Tjmp *)
		loc := -2-(pc-1)
	ELSE (* backward jump *)
		Gen1 (SHORT (x.adr), loc, node); FixLinkWith (x.offs, loc)
	END;
	FixLink (x.inx) (* Fjmp *)
END Jcc;	
	

PROCEDURE Jncc* (VAR x: Item; VAR loc: Label; node: PLL.Node); 
(* conditional jump on false *)
	VAR j: INTEGER;
BEGIN
	IF x.mode # Coc THEN
		ASSERT (x.typ.form = Bool);
		load (x); GenFlags (cmp, x, True);
		SetCC (x, EQ)
	END;
	IF x.adr # always THEN
		IF x.adr = never THEN j := always ELSE j := InvCCtab [(x.adr - EQ) DIV 32] END;		(* jncc bug *)
		IF loc < 0 THEN (* forward jump *)
			Gen1 (j, x.inx, node); (* Fjmp *)
			loc := -2-(pc-1)
		ELSE (* backward jump *)
			Gen1 (j, loc, node);
			FixLinkWith (x.inx, loc) (* Fjmp *)
		END;
	ELSIF loc>=0 THEN FixLinkWith (x.inx, loc) (* Fjmp *)
	END;
	FixLink (x.offs) (* Tjmp *)
END Jncc;

PROCEDURE CompleteSL (VAR x: Item); 
(* complete static link *)
	VAR n: INTEGER; sl: Item;
BEGIN
	IF x.mnolev > 0 THEN
		n := level - x.mnolev;
		IF (x.mode IN {Var, Par, VarPar}) & (n > 0) THEN
			sl.mode := RegRel; sl.typ := PLT.sysptrtyp; sl.mnolev := level; sl.inx := none; 
			sl.adr := FP; sl.offs := StaticLinkAdr; sl.node := NIL;
			IF n > 1 THEN
				load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
				WHILE n > 2 DO
					load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
					DEC (n)
				END
			END;
			load (sl);
			x.mode := RegRel; x.offs := x.adr; x.adr := sl.adr; x.inx := none
		END
	END
	END CompleteSL;			

PROCEDURE loadAdr (VAR x: Item); 
(* load address *)
	VAR typ: PLT.Struct;
BEGIN
	ASSERT (x.mode IN {Abs, Var, Par, VarPar, RegRel});
	typ := x.typ;
	IF (x.mode = VarPar) OR ((x.typ.comp = DynArr) & ((x.mode = Var) OR (x.mode = Par))) THEN
		CompleteSL (x);
		x.typ := PLT.sysptrtyp;
		IF x.mode = VarPar THEN (* x is from the own procedure *)
			x.mode := RegRel; x.offs := x.adr; x.adr := FP; x.inx := none
		END;
		GenLoad (ld, x, x)
	ELSE (* Abs, Var, VarPar, RegRel *)
		CompleteSL (x);
		x.typ := PLT.sysptrtyp;
	(* IF (x.mode = RegRel) & (x.offs = 0) THEN x.mode := Reg ELSE *) GenLoad (lea, x, x) (* END*)	(* << mb 16.2.94 *)
	END;
	x.offs := 0; x.inx := none; x.scale := noScale; x.typ := typ
END loadAdr;

PROCEDURE loadf (VAR x: Item); 
(* load floating point *)
BEGIN
	IF x.mode # Reg THEN
		IF x.mode = VarPar THEN
			loadAdr (x); x.mode := RegRel
		ELSE CompleteSL (x)
		END;
		GenLoad (fload, x, x)
	END
END loadf;

PROCEDURE load (VAR x: Item);
BEGIN
	IF x.mode # Reg THEN
		IF x.mode = VarPar THEN
			loadAdr (x); x.mode := RegRel
		ELSE CompleteSL (x)
		END;
		GenLoad (ld, x, x)
	END
END load;
	
	PROCEDURE DeRef* (VAR x: Item);
		VAR btyp: PLT.Struct;
	BEGIN
		load (x);
		x.mode := RegRel; x.offs := 0; x.inx := none; x.scale := noScale;
		btyp := x.typ.BaseTyp;
		IF (btyp # NIL) & (btyp.comp = Array) THEN 
			REPEAT btyp := btyp.BaseTyp UNTIL btyp.comp # Array;
			IF (btyp.comp = Record) OR (btyp.form = Pointer) THEN x.offs := 16 END 
			(* offset 16 = first element  -> used in types like POINTER TO ARRAY n OF {Record, Pointer} *)
		END
	END DeRef;

	PROCEDURE GetTdAdr (VAR typ: PLT.Struct; VAR tag: Item);
	(* returns the typedescriptor address (absolute address) *)
	BEGIN
		ASSERT (typ # NIL);
		tag.mode := Con; tag.typ := PLT.sysptrtyp; tag.inx := none; tag.node := NIL;
		tag.adr := typ.tdadr		
	END GetTdAdr;


	PROCEDURE TypeTest* (VAR x: Item; testtyp: PLT.Struct; guard, equal, varRec: BOOLEAN);
	(*
		equal = TRUE: the two types must be the same
		guard = TRUE: trap is generated if test fails
		equal, guard = FALSE: only condition codes are set
	*)
		VAR testTag, z: Item;
	BEGIN
		ASSERT (testtyp # NIL);
		IF ~guard OR typchk THEN
			z := x;
			IF varRec THEN (* type descriptor is on the stack *)
				CompleteSL (z);
				IF z.mode IN {Var, Par, VarPar} THEN
					INC (z.adr, 4); z.mode := Var  (* type descriptor is on the stack (hidden parameter) *)
				ELSE
					ASSERT (z.mode = RegRel);
					INC (z.offs, 4)
				END
			ELSE (* pointer *)
				IF testtyp.form = Pointer THEN
					testtyp := testtyp.BaseTyp;
					DeRef (z)
				END;
				z.offs := -4
			END;
			IF ~equal THEN
				DeRef (z);
				z.offs := z.offs + BaseTypeOffs - 4 * testtyp.extlev
			END;
			load (z);
			GetTdAdr (testtyp, testTag); load (testTag);
			GenFlags (cmp, z, testTag);
			IF equal THEN Gen1 (tne, PLL.EqualGuardTrap, NIL)
			ELSIF guard THEN Gen1 (tne, PLL.GuardTrap, NIL)
			ELSE SetCC (x, EQ)
			END
		END
	END TypeTest;

	PROCEDURE CheckOverflow (VAR x: Item);
	BEGIN
		IF ovflchk THEN Gen1 (to, PLL.OverflowTrap, NIL) END
	END CheckOverflow;
			
	PROCEDURE CheckIndex (VAR index, len: Item);
		VAR t: Item;
	BEGIN
		t := index;
		IF index.mode = Con THEN (* DynArr with constant index *)
			load (t)
		END;
		GenFlags (cmp, t, len);
		Gen1 (tae, PLL.RangeTrap, NIL)
	END CheckIndex;


PROCEDURE ChangeType (VAR item: Item; form: SHORTINT);
BEGIN
	CASE form OF
	  | Bool: item.typ:= PLT.booltyp
	  | Char: item.typ:= PLT.chartyp
	  | SInt: item.typ:= PLT.sinttyp
	  | Int: item.typ:= PLT.inttyp
	  | LInt: item.typ:= PLT.linttyp
	  | Real: item.typ:= PLT.realtyp
	  | LReal: item.typ:= PLT.lrltyp
	  | Set: item.typ:= PLT.settyp
	  | Pointer: item.typ:= PLT.sysptrtyp
	  | ProcTyp: item.typ:= PLT.notyp
	ELSE HALT (BUG)
	END
END ChangeType;


		PROCEDURE^ Convert* (VAR x: Item; form: SHORTINT);
	

		PROCEDURE SetElem* (VAR z, x: Item); (* z := {x} *)
	BEGIN
		MakeCon (z, PLT.settyp, 0);
		load (z);
		IF x.typ.form # LInt THEN Convert (x, LInt)
		ELSE load (x)
		END;
		Gen3 (bts, z, z, x)
	END SetElem;


PROCEDURE Convert* (VAR x: Item; form: SHORTINT);
	VAR 
		t: Item; 
		xform: SHORTINT;

	PROCEDURE IntToInt (VAR z, x: Item; xform, zform: SHORTINT);
	(* integer to integer convertion *)
	BEGIN
		ASSERT ((xform IN intSet) & (zform IN intSet) & (x.typ.form IN intSet) & (z.typ.form IN intSet));
		IF xform < zform THEN (* smaller to bigger *)
			IF x.mode = VarPar THEN
				loadAdr (x); x.mode := RegRel;
			ELSE CompleteSL (x)
			END;
			ChangeType (x, zform);
			IF zform = Int THEN GenLoad (ldbw, z, x)
			ELSIF xform = Int THEN GenLoad (ldwdw, z, x)
			ELSE GenLoad (ldbdw, z, x)
			END
		ELSE (* bigger to smaller *)
			IF x.mode = Reg THEN
				ChangeType (x, zform);
				Gen2 (short, z, x)
			END
		END
		(* z.typ will be changed by Convert *)
	END IntToInt;
	
	PROCEDURE IntToReal (VAR z, x: Item; xform, zform: SHORTINT);
	(* integer to real convertion *)
		VAR  temp, cons: Item;
	BEGIN
		IF x.mode = VarPar THEN
			loadAdr (x); x.mode := RegRel;
		ELSE CompleteSL (x)
		END;
		ChangeType (x, LInt);
		IF xform = SInt THEN GenLoad (ldbdw, x, x)
		ELSIF xform = Int THEN GenLoad (ldwdw, x, x)
		ELSE load (x)
		END;
		GenPush (x); (* store x on the stack as a temporary variable *)
		temp.mode := RegRel; temp.typ := PLT.linttyp; 
		temp.adr := ESP; temp.offs := 0; temp.inx := none; temp.node := NIL;
		ChangeType (z, zform);
		ChangeType (temp, zform);
		GenLoad (fild, z, temp);
		MakeCon (cons, PLT.linttyp, 4);
		temp := Stack; Gen3 (add, temp, Stack, cons) (* free temporary variable space *)
		(* z.typ will be changed by Convert *)
	END IntToReal;
	
	PROCEDURE IntToCharByte (VAR z, x: Item; form: SHORTINT);
	BEGIN
		IF (x.typ.form # SInt) & (x.mode = Reg) THEN
			ChangeType (x, form);
			Gen2 (short, z, x)
		END;
		(* z.typ will be changed by Convert *)
	END IntToCharByte;
	
	PROCEDURE RealToReal (VAR z, x: Item; xform, zform: SHORTINT);
	(* real to real convertion *)
	BEGIN
		IF xform < zform THEN (* smaller to bigger *)
			z := x; loadf (z)
		ELSE (* bigger to smaller *)
			z := x; loadf (z)
		END
		(* z.typ will be changed by Convert *)
	END RealToReal;
	
	PROCEDURE RealToInt (VAR z, x: Item);
	(* real to integer convertion *)
	BEGIN
		loadf (x); ChangeType (x, LInt);
		Gen2 (entier, z, x)
		(* z.typ will be changed by Convert *) 
	END RealToInt;
	
	PROCEDURE CharToInt (VAR z, x: Item; zform: SHORTINT);
	(* character to integer convertion *)
	BEGIN
		IF x.mode = VarPar THEN
			loadAdr (x); x.mode := RegRel
		ELSE CompleteSL (x)
		END;
		ChangeType (x, zform);
		IF zform = Int THEN GenLoad (ldbwu, z, x)
		ELSIF zform = LInt THEN GenLoad (ldbdwu, z, x)
		ELSE (* ok, char or byte to shortint *)
		END
		(* z.typ will be changed by Convert *)
	END CharToInt;

	PROCEDURE ByteToInt (VAR z, x: Item; zform: SHORTINT);
	(* byte to integer convertion *)
	BEGIN
		IF x.mode = VarPar THEN
			loadAdr (x); x.mode := RegRel
		ELSE CompleteSL (x)
		END;
		ChangeType (x, zform);
		IF zform = Int THEN GenLoad (ldbw, z, x)
		ELSIF zform = LInt THEN GenLoad (ldbdw, z, x)
		ELSE (* ok, char or byte to shortint *)
		END
		(* z.typ will be changed by convert *)
	END ByteToInt;
	
BEGIN (* Convert *)
	t := x; xform := x.typ.form;
	IF xform IN intSet THEN
		IF form IN intSet THEN IntToInt (x, t, xform, form)
		ELSIF form IN realSet THEN IntToReal (x, t, xform, form)
		ELSIF form IN {Char, Byte} THEN IntToCharByte (x, t, form)
		ELSE HALT (BUG)
		END
	ELSIF xform IN realSet THEN
		IF form IN realSet THEN RealToReal (x, t, xform, form)
		ELSIF form = LInt THEN RealToInt (x, t)
		ELSIF form IN {Int, SInt} THEN
			RealToInt (x, t); ChangeType (x, LInt); t := x; IntToInt (x, t, LInt, form)
		ELSIF form IN {Char, Byte} THEN
			RealToInt (x, t); ChangeType (x, LInt); t := x; IntToCharByte (x, t, form)
		ELSE HALT (BUG)
		END
	ELSIF (xform IN {Byte, Char}) & (form IN {Byte,Char}) THEN (* ok, type is changed by OPV *)
	ELSIF xform = Char THEN
		ASSERT (form IN intSet + realSet);
			IF form IN intSet THEN CharToInt (x, t, form)
			ELSE	(* form IN realSet *)
				CharToInt(x, t, LInt); t:=x; IntToReal(x, t, LInt, form)
			END
	ELSIF xform = Byte THEN
		IF form IN intSet THEN ByteToInt (x, t, form)
		ELSIF form IN realSet THEN RealToInt (x, t)
		ELSE HALT (BUG)
		END
	ELSIF (form = ProcTyp) & (xform # NoTyp) THEN HALT (BUG)
	END;
	ChangeType (x, form)
END Convert;


	PROCEDURE Include* (VAR z, x: Item; incl: BOOLEAN); (* INCL / EXCL (z, x) *)
		VAR y, v: Item;

		PROCEDURE exp2 (x: LONGINT): LONGINT;
		(* returns 2^x *)
			VAR i: LONGINT;
		BEGIN
			ASSERT (x >= 0);
			i := 1;
			WHILE x > 0 DO
				i := i * 2;
				DEC  (x)
			END;
			RETURN i
		END exp2;

	BEGIN
		v := z;
		load (v); y := v;
		IF incl THEN
			IF x.mode = Con THEN
				IF x.adr = MaxSet THEN x.adr := MinLInt
				ELSE x.adr := exp2 (x.adr)
				END;
				Gen3 (or, v, y, x)
			ELSE
				IF x.typ.form # LInt THEN Convert (x, LInt) END;
				load (x);
				Gen3 (bts, v, y, x)
			END
		ELSE
			IF x.mode = Con THEN
				IF x.adr = MaxSet THEN x.adr := MaxLInt
				ELSE x.adr := -1 - exp2 (x.adr)
				END;
				Gen3 (and, v, y, x)
			ELSE
				IF x.typ.form # LInt THEN Convert (x, LInt) END;
				load (x);
				Gen3 (btr, v, y, x)
			END
		END;
		IF z.mode = VarPar THEN
			loadAdr (z); z.mode := RegRel
		ELSE CompleteSL (z)
		END;
		GenStore (store, z, v)
	END Include;

PROCEDURE MoveCoc (VAR z, y: Item); (* z := Coc (y) *)
	VAR L: Label; phiItem: Item;
BEGIN
	ASSERT (y.mode = Coc);
	IF (y.offs = Nil) & (y.inx = Nil) THEN (* no jump links *)
		GenSetC (SHORT (sete + y.adr - EQ), z)
	ELSE
		Jncc (y, y.inx, NIL);
		GenLoad (ld, z, True);
		phiItem := z;
		L := Nil;
		Jmp (L, NIL);
		FixLink (y.inx); (* Fjmp fixup *)
		GenLoad (ld, z, False);
		GenPhi (phiItem.adr, z.adr); (* registers in z and phiItem must be the same when generating Intel code *)
		FixLink (L)
	END
END MoveCoc;

	PROCEDURE Relation* (VAR x: Item);
		VAR y: Item;
	BEGIN 
		IF x.mode = Coc THEN 
			y := x; MoveCoc (x, y) 
		END
	END Relation;

	PROCEDURE Cmp* (VAR z, x, y: Item; rel: INTEGER); (* z := cmp (x, y) *)
		VAR xform: INTEGER;
	BEGIN
		xform := x.typ.form;
		IF xform IN {Byte, Char..LInt, Set, NilTyp, Pointer, ProcTyp} THEN
			load (x);
			IF y.mode # Con THEN load (y) END;
			GenFlags (cmp, x, y)
		ELSIF xform IN realSet THEN
			loadf (y); loadf (x); GenFlags (fcmp, x, y)
		ELSIF xform = Bool THEN (* only eq or neq *)
			load (x);
			IF y.mode = Coc THEN
				z := y; MoveCoc (y, z) 
			ELSIF y.mode # Con THEN load (y)
			END;
			GenFlags (cmp, x, y)
		ELSE (* strings *)
			ASSERT ((xform = String) OR (x.typ.comp = Array) OR (x.typ.comp = DynArr));
			loadAdr (x); loadAdr (y);
			GenFlags (cmpString, x, y);
			xform := String;
		END;
		ASSERT (rel IN {eql, neq, lss, leq, gtr, geq});
		IF xform IN {Char, String, Real, LReal} THEN SetCC (z, CCtab [1, rel-eql])
		ELSE SetCC (z, CCtab [0, rel-eql])
		END;
	END Cmp;

	PROCEDURE In* (VAR z, x, y: Item); (* z := x IN y *)
		VAR t: Item;
	BEGIN
		IF (y.mode # Con) & (y.typ.form # Set) THEN
			t := y; SetElem (y, t)
		ELSE load (y)
		END;
		IF x.mode # Con THEN
			IF x.typ.form # LInt THEN Convert (x, LInt)
			ELSE load (x) 
			END
		END;
		GenFlags (bt, y, x);
		SetCC (z, CS)
	END In;

	PROCEDURE SetRange* (VAR z, x, y: Item); (* z := {x..y} *)
		VAR t, xShifted, yShifted, maxSet, fullSet: Item; val: LONGINT;
	BEGIN
		z.typ := PLT.settyp;
		MakeCon (fullSet, PLT.linttyp, -1);
		MakeCon (maxSet, PLT.linttyp, MaxSet);
		IF x.mode = Con THEN
			ASSERT (y.mode # Con);
			load (y);
			maxSet.typ := y.typ; load (maxSet);
			t := y; Gen3 (sub, y, maxSet, t);
			load (fullSet);
			Gen3 (shr, z, fullSet,  y);
			IF x.adr # 0 THEN
				IF x.adr = MaxSet THEN x.adr := MIN (LONGINT)
				ELSE
					val := 2;
					WHILE x.adr > 1 DO
						val := val*2;
						DEC (x.adr)
					END;
					x.adr := -val
				END;
				t := z; Gen3 (and, z, t, x)
			END
		ELSIF y.mode = Con THEN
			load (x);
			load (fullSet);
			Gen3 (sal, z, fullSet, x);
			IF y.adr # MaxSet THEN
				IF y.adr = MaxSet-1 THEN y.adr := MAX (LONGINT)
				ELSE
					val := 2;
					WHILE y.adr > 0 DO
						val := val*2;
						DEC (y.adr)
					END;
					y.adr := val-1
				END;
				t := z; Gen3 (and, z, t, y)
			END
		ELSE (* x, y # constant *)
			load (x);
			t := fullSet; load (t);
			xShifted.typ := PLT.linttyp; xShifted.node := NIL;
			Gen3 (sal, xShifted, t, x);
			load (y);
			maxSet.typ := y.typ; load (maxSet);
			t := y; Gen3 (sub, y, maxSet, t);
			load (fullSet);
			yShifted.typ := PLT.linttyp; yShifted.node := NIL;
			Gen3 (shr, yShifted, fullSet, y);
			Gen3 (and, z, xShifted, yShifted)
		END
	END SetRange;

	PROCEDURE Not* (VAR z, x: Item); (* z := NOT (x) *)
		VAR temp: LONGINT;
	BEGIN
		IF x.mode = Coc THEN
			z := x; z.adr := InvCCtab [(z.adr - EQ) DIV 32];
			temp := z.offs; z.offs := z.inx; z.inx := temp; (* permute Fjmp and Tjmp *)
		ELSE
			load (x);
			GenFlags (cmp, x, False);
			SetCC (z, EQ)
		END
	END Not;
	
	PROCEDURE Neg* (VAR z, x: Item); (* z := -x *)
	BEGIN
		ASSERT ( (x.typ.form = Set) OR (x.typ.form IN intSet) OR (x.typ.form IN realSet) );
		IF x.typ.form = Set THEN 
			load (x); Gen2 (not, z, x)
		ELSIF x.typ.form IN intSet THEN
			load (x); Gen2 (neg, z, x)
		ELSE (* x.typ.form = realSet *)
			loadf (x);  Gen2 (fchs, z, x)
		END
	END Neg;
	
	PROCEDURE AbsVal* (VAR z, x: Item); (* z := ABS (x) *)
	BEGIN
		ASSERT ( (x.typ.form IN intSet) OR (x.typ.form IN realSet) );
		IF x.typ.form IN intSet THEN
			load (x);
			Gen2 (abs, z, x);
			IF x.typ.form IN {Int, LInt} THEN PLL.Instr [pc-1].hint := PLL.useEAX END;
		ELSE (* x.typ.form IN realSet *)
			loadf (x);
			Gen2 (fabs, z, x)
		END
	END AbsVal;
	
	PROCEDURE Cap* (VAR z, x: Item); (* z := CAP (x) *)
		VAR c: Item;
	BEGIN
		MakeCon (c, PLT.chartyp, 5FH);
		load (x);
		Gen3 (and, z, x, c)
	END Cap;
	
	PROCEDURE Odd* (VAR z, x: Item); (* z := ODD (x) *)
		VAR c: Item;
	BEGIN
		MakeCon (c, PLT.sinttyp, 1);
		load (x);
		Gen3 (and, z, x, c)
	END Odd;

	PROCEDURE Ash* (VAR z, x, y: Item); (* z := ASH (x, y) *)
		VAR L, Lc: Label; t, phiItem: Item;
	BEGIN
		IF y.mode = Con THEN
			IF x.mode = Con THEN
				MakeCon (z, PLT.linttyp, ASH (x.adr, y.adr));
			ELSIF y.adr > 0 THEN
				load (x); Gen3 (sal, z, x, y) 
			ELSIF y.adr < 0 THEN
				y.adr := ABS (y.adr);
				load (x); Gen3 (sar, z, x, y)
			END
		ELSE
			load (x); load (y); z.typ := PLT.linttyp;
			MakeCon (t, PLT.linttyp, 0);
			GenFlags (cmp, y, t);
			Lc := -2-pc; Gen1 (jl, Nil, NIL);
			Gen3 (sal, z, x, y);
			L := -2-pc; Gen1 (jmp, Nil, NIL); 
			phiItem := z;
			FixLink (Lc);
			Gen2 (neg, t, y);
			Gen3 (sar, z, x, t);
			GenPhi (phiItem.adr, z.adr); (* z and phiItem must be in the same register when generating target code *)
			FixLink (L)
		END
	END Ash;
	

	PROCEDURE Add* (VAR z, x, y: Item; f: INTEGER); (* z := x + y *)
	BEGIN
		ASSERT ( (f IN realSet) OR (f = Set) OR (f IN intSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y); Gen3 (fadd, z, x, y)
		ELSIF f = Set THEN 
			IF x.mode = Con THEN 
				load (y); Gen3 (or, z, y, x)
			ELSE
				load (x);
				IF y.mode # Con THEN load (y) END;
				Gen3 (or, z, x, y)
			END
		ELSE (* f IN intSet *)
			IF x.mode = Con THEN
				load (y); Gen3 (add, z, y, x)
			ELSE
				load (x);
				IF y.mode # Con THEN load (y) END;
				Gen3 (add, z, x, y)
			END;
			CheckOverflow (z)
		END
	END Add;

	PROCEDURE Sub* (VAR z, x, y: Item; f: INTEGER); (* z := x - y *)
		VAR t: Item;
	BEGIN
		ASSERT ( (f IN realSet) OR (f = Set) OR (f IN intSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y);  Gen3 (fsub, z, x, y)
		ELSIF f = Set THEN 
			load (x);
			IF y.mode # Con THEN
				load (y); Gen2 (not, t, y)
			ELSE
				y.adr := -1- y.adr; t := y
			END;
			z := x; Gen3 (and, z, x, t)
		ELSE (* f IN intSet *)
			load (x);
			IF y.mode # Con THEN load (y) END;
			Gen3 (sub, z, x, y);
			CheckOverflow (z)
		END
	END Sub;
	
	PROCEDURE Mul* (VAR z, x, y: Item; f: INTEGER); (* z := x * y *)
		VAR val, exp: LONGINT; shift: Item;
	BEGIN
		ASSERT ( (f = Set) OR (f IN intSet) OR (f IN realSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y); Gen3 (fmul, z, x, y)
		ELSIF f = Set THEN
			IF x.mode = Con THEN
				load (y); Gen3 (and, z, y, x)
			ELSE
				load (x);
				IF (y.mode # Reg) & (y.mode # Con) THEN load (y) END;
				Gen3 (and, z, x, y)
			END
		ELSE (* f IN intSet *) 
		(*  The shift-left check is necessary because several procedures in OPC call Mul directly. *)
			MakeCon (shift, PLT.linttyp, 0);
			IF x.mode = Con THEN
				val := x.adr; exp := 0;
				ASSERT (val # 0);
				WHILE ~ODD (val) DO 
					val := val DIV 2;
					INC (exp)
				END;
				load (y);
				IF val = 1 THEN (* shift *)
					IF exp # 0 THEN
						shift.adr := exp; Gen3 (sal, z, y, shift)
					ELSE z := y
					END
				ELSE Gen3 (mul, z, y, x)
				END
			ELSIF y.mode = Con THEN
				val := y.adr; exp := 0;
				ASSERT (val # 0);
				WHILE ~ODD (val) DO
					val := val DIV 2;
					INC (exp)
				END;
				load (x);
				IF val = 1 THEN (* shift *)
					IF exp # 0 THEN
						shift.adr := exp; Gen3 (sal, z, x, shift)
					ELSE z := x
					END
				ELSE Gen3 (mul, z, x, y)
				END
			ELSE
				load (x); load (y);
				Gen3  (mul, z, x, y)
			END;
			CheckOverflow (z)
		END
	END Mul;

	
	PROCEDURE Div* (VAR z, x, y: Item; f: INTEGER); (* z := x DIV y; z := x / y *)
	BEGIN
		ASSERT ( (f IN realSet) OR (f = Set) OR (f IN intSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y); Gen3 (fdiv, z, x, y)
		ELSIF f = Set THEN
			IF x.mode = Con THEN 
				load (y); Gen3 (xor, z, y, x) 
			ELSE
				load (x);
				IF (y.mode # Reg) & (y.mode # Con) THEN load (y) END;
				Gen3 (xor, z, x, y)
			END
		ELSE (* f IN intSet *) (* front end checks for shift right possibilities *)
			load (x);
			IF y.mode # Con THEN load (y) END;
			Gen3 (div, z, x, y)
			(* no overflow check necessary *)
		END
	END Div;

	PROCEDURE Mod* (VAR z, x, y: Item); (* z := x MOD y *)
	BEGIN 
		load (x);
		IF y.mode # Con THEN load (y) END; (* front end checks for shift left possibilities *)
		Gen3 (mod, z, x, y)
		(* no overflow check necessary *)
	END Mod;
	

	PROCEDURE CondAnd* (VAR x: Item); (* prepares conditional and *)
		VAR jcc: INTEGER;
	BEGIN
		IF x.mode = Coc THEN jcc := InvCCtab [(x.adr - EQ) DIV 32]
		ELSE (* form = Bool, mode # Con *)
			ASSERT ( (x.typ.form = Bool) & (x.mode # Con) );
			load (x); GenFlags (cmp, x, True);
			SetCC (x, NE);
			jcc := jne
		END;
		Gen1 (jcc, x.inx, NIL); (* ... Fjmp *) 
		x.inx := -2-(pc-1);
		FixLink (x.offs) (* Tjmp here *)
	END CondAnd;

	PROCEDURE And* (VAR z, x, y: Item); (* conditional and *)
	BEGIN
		z := x;
		IF y.mode # Coc THEN
			IF y.mode = Con THEN
				IF y.adr = true THEN SetCC (y, always) 
				ELSE SetCC (y, never) 
				END
			ELSE
				load (y); GenFlags (cmp, y, True); 
				SetCC (y, EQ)
			END
		END;
		IF y.inx # Nil THEN z.inx := MergedLinks (z.inx, y.inx) END; (* merge Fjmp *)
		z.adr := y.adr; z.offs := y.offs (* Tjmp *)
	END And;

	PROCEDURE CondOr* (VAR x: Item); (* prepares conditional or *)
		VAR jcc: INTEGER;
	BEGIN
		IF x.mode = Coc THEN jcc := SHORT (x.adr)
		ELSE (* form = Bool, mode # Con *)
			ASSERT ( (x.typ.form = Bool) & (x.mode # Con) );
			load (x); GenFlags (cmp, x, True);
			SetCC (x, EQ);
			jcc := je
		END;
		Gen1 (jcc, x.offs, NIL); (* ... Tjmp *)
		x.offs := -2-(pc-1);
		FixLink (x.inx) (* Fjmp here *)
	END CondOr;

	PROCEDURE Or* (VAR z, x, y: Item); (* conditional or *)
	BEGIN
		z := x;
		IF y.mode # Coc THEN
			IF y.mode = Con THEN
				IF y.adr = true THEN SetCC (y, always) 
				ELSE SetCC (y, never) 
				END
			ELSE
				load (y); GenFlags (cmp, y, True); 
				SetCC (y, EQ)
			END
		END;
		IF y.offs # Nil THEN z.offs := MergedLinks (x.offs, y.offs) END; (* merge Tjmp *)
		z.adr := y.adr; z.inx := y.inx (* Fjmp *)
	END Or;

	PROCEDURE Msk* (VAR z, x, y: Item); (* z := x AND y *)
	BEGIN
		y.adr := -1 - y.adr; (* invert y.adr *)
		load (x);
		Gen3 (and, z, x, y)
	END Msk;

	PROCEDURE Field* (VAR x: Item; offset: LONGINT); (* Record.field *)
	BEGIN
		ASSERT (x.mode IN {Var, Par, VarPar, Abs, RegRel});
		IF x.mode IN {Var, Par, Abs} THEN
			INC(x.adr, offset)
		ELSIF x.mode = VarPar THEN
			loadAdr (x); x.mode := RegRel; x.offs := offset
		ELSE (* RegRel *)
			INC (x.offs, offset)
		END;
	END Field;


PROCEDURE DynArrLen (VAR len, arr: Item; offs: LONGINT);
(* returns the length in the offs DIV 4 -th dimension of a dynamic array *)
BEGIN
	IF arr.descReg = FP THEN
		 len.mode := Var; len.adr := arr.descOffs + offs; len.offs := 0 
	ELSE
		len.mode := RegRel; len.adr := arr.descReg; len.offs := arr.descOffs + offs
	END;
	len.typ := PLT.linttyp; len.node := NIL; len.mnolev := arr.mnolev; len.inx := none 
END DynArrLen;


	PROCEDURE Len* (VAR len, x, y: Item); 	(* len := LEN (x, y), where x is a dynamic array and y the dimension *)
	BEGIN
		DynArrLen (len, x, (x.typ.n - y.adr+1) * 4)
	END Len;


		PROCEDURE Length (VAR len, x: Item); (* len := LEN (x) *)
	BEGIN
		IF x.typ.form = String THEN MakeCon (len, PLT.linttyp, x.offs);
		ELSIF x.typ.comp = Array THEN MakeCon (len, PLT.linttyp, x.typ.n)
		ELSE (* x.typ.comp = DynArr *)
			ASSERT (x.typ.comp = DynArr);
			DynArrLen (len, x, x.typ.offset)
		END
	END Length;


PROCEDURE BaseTypSize (VAR sizeItem, arr: Item; VAR size: LONGINT);
(* 
	returns the size of the basetyp of the array arr: sizeItem * size = basetyp size, measured in bytes
	size = 1 -> byte; size = 2 -> word (2 bytes); size = 4 -> dword (4 bytes); size = 8 -> qword (8 bytes)
*)
	VAR
		disp: LONGINT;
		typ: PLT.Struct;
		len, t: Item;
BEGIN
	typ := arr.typ.BaseTyp;
	WHILE typ.comp = DynArr DO typ := typ.BaseTyp END;
	IF (typ.size = 1) OR (typ.size = 2) OR (typ.size = 4) OR (typ.size = 8) THEN
		size := typ.size;
		DynArrLen (sizeItem, arr, arr.typ.BaseTyp.offset)
	ELSE
		size := 1;
		MakeCon (t, PLT.linttyp, typ.size);
		DynArrLen (len, arr, arr.typ.BaseTyp.offset); 
		sizeItem.node := NIL; sizeItem.typ := PLT.linttyp;
		Mul (sizeItem, t, len, LInt);
	END;
	disp := arr.typ.BaseTyp.offset - 4;
	WHILE disp > 0 DO
		DynArrLen (len, arr, disp); 
		t := sizeItem; Mul (sizeItem, t, len, LInt);
		disp := disp - 4
	END
END BaseTypSize;

PROCEDURE DynArrSize (VAR sizeItem, arr: Item; VAR size: LONGINT);
(* returns the size of array arr. sizeItem * size = array size, measured in bytes *)
	VAR len, t: Item;
BEGIN
	DynArrLen (sizeItem, arr, (arr.typ.n + 1) * 4);
	IF arr.typ.n > 0 THEN
		BaseTypSize (t, arr, size);
		len := sizeItem;
		Mul (sizeItem, t, len, LInt)
	ELSE size := arr.typ.BaseTyp.size
	END
END DynArrSize;


	PROCEDURE Index* (VAR z, index: Item); (* z := z[index] *)
		VAR
			size, scale: LONGINT;
			t, cons, sizeItem, len: Item;
			basetyp: PLT.Struct;
			comp: SHORTINT;
	BEGIN
		comp := z.typ.comp;
		IF (comp = DynArr) & (z.mode IN {Var, Par, VarPar}) THEN (* open array *)
			z.mode := VarPar; loadAdr (z); z.mode := RegRel
		END;
		basetyp := z.typ.BaseTyp; size := basetyp.size;
		IF (comp # DynArr) & (index.mode = Con) THEN Field (z, index.adr * size)
		ELSE
			IF index.typ.form # LInt THEN
				IF index.mode = Con THEN index.typ := PLT.linttyp
				ELSE Convert (index, LInt)
				END
			ELSE load (index)
			END;
			IF inxchk THEN (* index check *)
				IF comp = DynArr THEN
					DynArrLen (len, z, z.typ.offset);
					load (len)
				ELSE MakeCon (len, PLT.linttyp, z.typ.n)
				END;
				CheckIndex (index, len)
			END;
			IF basetyp.comp = DynArr THEN
				IF (index.mode # Con) OR (index.adr # 0) THEN
					BaseTypSize (sizeItem, z, scale);
					ASSERT (sizeItem.mode # Con);
				(*IF (index.mode # Con) OR (index.adr # 0) THEN*)
					t := index; Mul (index, sizeItem, t, LInt)
				END
			ELSIF (basetyp.comp # Basic) & ~((size = 1) OR (size = 2) OR (size = 4) OR (size = 8)) THEN
				scale := 1;
				IF (index.mode # Con) OR (index.adr # 0) THEN
					MakeCon (cons, PLT.linttyp, size);
					t := index; Mul (index, t, cons, LInt)
				END
			ELSE scale := size
			END;
			IF ((z.mode = Var) OR (z.mode = Par)) & (level - z.mnolev > 0 ) THEN (* we need static link *)
				CompleteSL (z);
			END;
			IF (z.mode = Abs) & (z.inx = none) THEN (* Abs with no index yet *)
				ASSERT (index.mode # Con);
				z.inx := index.adr
			ELSIF (z.mode = Var) OR (z.mode = Par) THEN (* local variable *)
				ASSERT (index.mode # Con);
				z.mode := RegRel; z.offs := z.adr; z.adr := FP; z.inx := index.adr
			ELSIF z.mode = VarPar THEN
				ASSERT (index.mode # Con);
				loadAdr (z); z.mode := RegRel; z.inx := index.adr
			ELSIF (z.mode = RegRel) & (z.inx = none) THEN
				IF index.mode = Con THEN (* dynamic array with constant index *)
					z.offs := z.offs + index.adr * scale; scale := z.scale
				ELSE z.inx := index.adr
				END
			ELSE (* z.mode IN {RegRel, Abs} with index *)
				ASSERT ((z.mode IN {RegRel, Abs}) & (z.inx # none));
				IF index.mode = Con THEN (* dynamic array with constant index *)
					z.offs := z.offs + index.adr * scale; scale := z.scale	(* << mh 30.8.94 *)
				ELSE
					GenLoad (lea, z, z);
					z.mode := RegRel; z.inx := index.adr; z.offs := 0
				END
			END;
			IF index.mode # Con THEN
				CASE scale OF
					1: z.scale := PLO.Scale1
				  | 2: z.scale := PLO.Scale2
				  | 4: z.scale := PLO.Scale4
				  | 8: z.scale := PLO.Scale8
				ELSE HALT (BUG)
				END
			END
		END
	END Index;

PROCEDURE MoveBlock (VAR z, x, size: Item; moveSize: SHORTINT);
(* move 'size' element from x to z, where 'element' has the size 'moveSize' (byte, word, dword *)
BEGIN
	ASSERT (moveSize IN {PLO.Bit8, PLO.Bit16, PLO.Bit32});
	IF (size.mode = Con) & (moveSize IN {PLO.Bit16, PLO.Bit8})  THEN (* try to optimize *)
		IF (size.adr MOD 4 = 0) & (moveSize = PLO.Bit8) THEN
			size.adr := size.adr DIV 4; moveSize := PLO.Bit32
		ELSIF size.adr MOD 2 = 0 THEN
			size.adr := size.adr DIV 2; DEC (moveSize, 8) (* 8 bit -> 16 bit; 16  bit -> 32 bit *)
		END
	END;
	IF (size.typ.form # LInt) & (size.mode # Con) THEN
		Convert (size, LInt); PLL.Instr [size.adr].hint := PLL.useECX;
	ELSE
		IF size.mode # Reg THEN
			size.typ := PLT.linttyp; load (size); PLL.Instr [size.adr].hint := PLL.useECX
		ELSIF (size.adr > 0) & (PLL.Instr [size.adr].hint = PLL.noHint)  THEN PLL.Instr [size.adr].hint := PLL.tryECX
		END
	END;
	IF x.mode # Reg THEN
		loadAdr (x); PLL.Instr [x.adr].hint := PLL.useESI
	ELSIF (x.adr >= 0) & (PLL.Instr [x.adr].hint = PLL.noHint) THEN PLL.Instr [x.adr].hint := PLL.tryESI
	END;
	IF z.mode # Reg THEN
		loadAdr (z); PLL.Instr [z.adr].hint := PLL.useEDI
	ELSIF (z.adr >= 0) & (PLL.Instr [z.adr].hint = PLL.noHint) THEN PLL.Instr [z.adr].hint := PLL.tryEDI
	END;
	Gen0 (cld);
	GenRepMovs (z, x, size, moveSize);
	IncReg (size.adr); IncReg (x.adr); IncReg (z.adr)
END MoveBlock;

PROCEDURE Move (VAR z, x: Item); (* z := x, where the size of x is byte, word or dword *)
BEGIN
	IF z.mode = VarPar THEN
		loadAdr (z); z.mode := RegRel
	ELSE CompleteSL (z)
	END;
	load (x);
	GenStore (store, z, x)
END Move;
	
	PROCEDURE Copy* (VAR z, x: Item);	(* COPY (x, z) *)
		VAR 
			zLen, xLen, zLen0, xLen0, char0X, len, z0, x0, t: Item;
			Lfix, L: Label;
	BEGIN
		MakeCon (char0X, PLT.chartyp, 0);
		Length (zLen, z); Length (xLen, x);
		IF (zLen.mode = Con) & (xLen.mode = Con) THEN
			IF zLen.adr >= xLen.adr THEN MoveBlock (z, x, xLen, PLO.Bit8)
			ELSE
				DEC (zLen.adr); (* last char is always 0X *)
				MoveBlock (z, x, zLen, PLO.Bit8);
				t.adr := z.adr; t.mode := RegRel; t.offs := 0; t.inx := none; t.typ := PLT.chartyp; t.node := NIL;
				Move (t, char0X) (* write 0X at the end of z *)
			END
		ELSE 
			IF zLen.mode = Con THEN 
				xLen0 := xLen;
				IF xLen.typ.form # LInt THEN Convert (xLen0, LInt)
				ELSE load (xLen0)
				END;
				PLL.Instr [xLen0.adr].hint := PLL.tryECX;
				GenFlags (cmp, xLen0, zLen);
				Lfix := -2-pc;
				Gen1 (jg, Nil, NIL)
			ELSE
				zLen0 := zLen;
				IF zLen0.typ.form # LInt THEN Convert (zLen0, LInt)
				ELSE load (zLen0)
				END;
				PLL.Instr [zLen0.adr].hint := PLL.tryECX;
				xLen0 := xLen;
				IF xLen0.mode # Con THEN
					IF xLen0.typ.form # LInt THEN Convert (xLen0, LInt)
					ELSE load (xLen0)
					END
				END;
				GenFlags (cmp, zLen0, xLen0);
				Lfix := -2-pc;
				Gen1 (jl, Nil, NIL)
			END;
			z0 := z; x0 := x; MoveBlock (z0, x0, xLen, PLO.Bit8);
			L := -2-pc; Gen1 (jmp, Nil, NIL);
			FixLink (Lfix);
			IF zLen.mode = Con THEN DEC (zLen.adr)
			ELSE
				MakeCon (len, PLT.linttyp, 1);
				load (zLen); PLL.Instr [zLen.adr].hint := PLL.useECX;
				t := zLen; Sub (zLen, t, len, LInt)
			END;
			MoveBlock (z, x, zLen, PLO.Bit8);
			t.mode := RegRel; t.adr := z.adr; t.offs := 0; t.inx := none; t.typ := PLT.chartyp; t.node := NIL;
			Move (t, char0X); (* last char is 0X *)
			FixLink (L)
		END 
	END Copy;


PROCEDURE Assign* (VAR z, x: Item);	(* z  := x *) (* ejz *)
	VAR 
		zform, xform: SHORTINT; 
		temp, size, zero: Item;
		proc: PLT.Object;
BEGIN
	zform := z.typ.form; xform := x.typ.form;
	IF (zform IN {Int, LInt, Real, LReal}) & (zform # xform) THEN Convert (x, zform) END;
	CASE zform OF
	| Bool:
		IF x.mode = Coc THEN
			temp := x; MoveCoc (x, temp) 
		ELSE load (x) 
		END;
		IF z.mode = VarPar THEN
			loadAdr (z); z.mode := RegRel;
		ELSE CompleteSL (z) 
		END;
		GenStore (store, z, x)
	| Byte, Char, SInt, Set, Int, LInt:
		Move (z, x)
	| Real:
		loadf (x);
		IF z.mode = VarPar THEN
			loadAdr (z); z.mode := RegRel
		ELSE CompleteSL (z) 
		END;
		GenStore (fstore, z, x)
	| LReal:
		loadf (x);
		IF z.mode = VarPar THEN
			loadAdr (z); z.mode := RegRel
		ELSE CompleteSL (z) 
		END;
		GenStore (fstore, z, x)
	| Pointer:
		IF xform = NilTyp THEN
			MakeCon (zero, PLT.linttyp, nil);
			load (zero);
			IF z.mode = VarPar THEN
				loadAdr (z); z.mode := RegRel
			ELSE CompleteSL (z) 
			END;
			GenStore (store, z, zero)
		ELSE
			load (x);
			IF z.mode = VarPar THEN
				loadAdr (z); z.mode := RegRel
			ELSE CompleteSL (z) 
			END;
			GenStore (store, z, x)
		END
	| ProcTyp:
		IF (z.typ = x.typ) OR (xform = NilTyp) THEN (* procedure variable assignment *)
			IF xform = NilTyp THEN
				MakeCon (x, PLT.linttyp, nil)
			END;
			Move (z, x)
		ELSE (* procedure assignment *)
			proc := x.node.obj;
			GenLoadProc(ldProc, x, proc.linkadr, x.node);
			IF z.mode = VarPar THEN
				loadAdr(z); z.mode := RegRel
			END;
			GenStore (store, z, x)
		END
	| Comp:
		ASSERT (z.typ.comp IN {Record, Array});
		IF x.typ.form = String THEN
			Copy(z, x)
		ELSE
			MakeCon (size, PLT.linttyp, z.typ.size);
			MoveBlock (z, x, size, PLO.Bit8)
		END
	ELSE
		HALT (BUG)
	END
END Assign;

 
	PROCEDURE IncDec* (VAR z, x: Item; increment: BOOLEAN); (* INC / DEC (z, x) *)
		VAR z0, temp: Item;
	BEGIN
		z0 := z; load (z0); temp := z0;
		IF increment THEN Add (z0, temp, x, z.typ.form)
		ELSE Sub (z0, temp, x, z.typ.form)
		END;
		Assign (z, z0)
	END IncDec;

	PROCEDURE MulDim* (VAR nofelem, len: Item); (* nofelem := nofelem * len *)
		VAR t: Item;
	BEGIN
		IF (nofelem.mode = Con) & (len.mode = Con) THEN nofelem.adr := nofelem.adr * len.adr
		ELSE
			t := nofelem; Mul (nofelem, t, len, LInt)
		END
	END MulDim;

	PROCEDURE PushLen* (VAR z: Item); (* push length z -> NEW (dynArr, dim0, dim1,... ) *)
	BEGIN
		IF z.mode # Con THEN
			IF  z.typ.form # LInt THEN Convert (z, LInt)
			ELSE load (z)
			END
		END;
		GenPush (z)
	END PushLen;
	
	
	PROCEDURE PopLen* (VAR len: Item);
	(* pop length and store it to the dynamic array -> used for NEW (dynArr, dim0, dim1, ...) *)
		VAR reg: Item;
	BEGIN
		reg.typ := PLT.linttyp; (* reg.node := NIL is done in GenPop *)
		GenPop (reg);
		GenStore (store, len, reg)
	END PopLen;


	PROCEDURE NewSys (VAR z, x: Item); (* SYSTEM.NEW (z, x) *)
	BEGIN
		IF z.mode # Reg THEN loadAdr (z) END;
		GenPush (z);
		IF x.typ.form IN {SInt, Int} THEN
			IF x.mode = Con THEN x.typ := PLT.linttyp
			ELSE Convert(x, LInt)  (* << mh 30.8.94 *)
			END
		END;
		load (x); GenPush (x); 
		GenCall (xcall, KernelRoutines[1], 8, NIL) 
	END NewSys;

	PROCEDURE NewArray* (VAR z, nofelem: Item; nofdim: LONGINT; typ: PLT.Struct; dimUsed: BOOLEAN);
	(* NEW (dynArr, dim0, dim1, ...) *)
		VAR
			cons, tdesc, t: Item;
	BEGIN
		loadAdr (z); 
		IF dimUsed THEN GenPush (z) END;
		IF (typ.form # Pointer) & (typ.comp # Record) THEN (* simple type -> use SYSTEM.NEW (...) *)
			IF nofelem.mode = Con THEN 
				(* nofelem.adr := nofelem.adr * typ.size + PtrToArrOffs + 4 + nofdim * 4 *)
				nofelem.adr := nofelem.adr * typ.size + PtrToArrOffs + 8 + 8*(nofdim DIV 2)	(* dVdW *)
			ELSE
				MakeCon (cons, PLT.linttyp, typ.size);
				t := nofelem; Mul (nofelem, t, cons, LInt);
				(* cons.adr := PtrToArrOffs + 4 + nofdim * 4; *)
				cons.adr := PtrToArrOffs + 8 + 8*(nofdim DIV 2);	(* dVdW *)
				t := nofelem; Add (nofelem, t, cons, LInt)
			END;
			t := z; NewSys (t, nofelem)
		ELSE (* BaseTyp contains pointers *)
			GenPush (z);
			IF typ.form = Pointer THEN
				MakeCon (cons, PLT.linttyp, nilval);
				GenPush (cons)
			ELSE
				GetTdAdr (typ, tdesc);
				load (tdesc);
				GenPush (tdesc)
			END;
			IF nofelem.mode # Con THEN load (nofelem) END;
			GenPush (nofelem);
			MakeCon (cons, PLT.linttyp, nofdim);
			GenPush (cons);
			GenCall (xcall, KernelRoutines[2], 16, NIL)
		END;
		IF dimUsed THEN 
			GenPop (z); z.mode := RegRel; z.offs := 0;
			load (z); z.mode := RegRel; z.typ := PLT.sysptrtyp; z.offs := PtrToArrOffs; z.inx := none
		END
	END NewArray;

	PROCEDURE NewRec* (VAR z: Item; typ: PLT.Struct); (* NEW (record), NEW (POINTER TO ARRAY n0, n1,... OF...) *)
		VAR
			tag, size: Item; 
			btyp: PLT.Struct;
			len: LONGINT;
	BEGIN
		IF typ.comp = Array THEN
			len := typ.n; btyp := typ.BaseTyp;
			WHILE btyp.comp = Array DO len := len * btyp.n; btyp := btyp.BaseTyp END;
			MakeCon (size, PLT.linttyp, len);
			IF (btyp.comp = Record) OR (btyp.form = Pointer) THEN NewArray (z, size, 1, btyp, FALSE)
			ELSE 
				size.adr := typ.size; NewSys (z, size)
			END
		ELSE (* Record *)
			loadAdr (z); GenPush (z);
			GetTdAdr (typ, tag);
			load (tag); GenPush (tag);
			GenCall(xcall, KernelRoutines[0], 8, NIL);
		END
	END NewRec;

	PROCEDURE PushDynArrLen (formalParam: PLT.Object; VAR actualParam: Item);
		(* push dynamic array length *)
		VAR atyp, ftyp: PLT.Struct; 
			len, sizeItem, arr, cons: Item;
			descOffs, descReg, size: LONGINT;
	BEGIN
		atyp := actualParam.typ; ftyp := formalParam.typ;
		descOffs := actualParam.descOffs; descReg := actualParam.descReg;
		WHILE ftyp.comp = DynArr DO
			IF (ftyp.BaseTyp = PLT.chartyp) & (atyp.BaseTyp # PLT.chartyp) & (atyp.form # String) THEN (* ARRAY OF SYSTEM.BYTE -> total size measured in bytes *)
				sizeItem.typ := PLT.linttyp; sizeItem.mnolev := actualParam.mnolev (* atyp.mno *); sizeItem.inx := none; sizeItem.node := NIL;
				IF atyp.comp = DynArr THEN
					arr.mode := RegRel; arr.typ := atyp; arr.descReg := descReg; arr.descOffs := descOffs; 
					arr.inx := none; arr.node := NIL; arr.mnolev := actualParam.mnolev; (* arr.adr, arr.offs are not used *)
					DynArrSize (sizeItem, arr, size);
					IF size # 1 THEN
						MakeCon (cons, PLT.linttyp, size);
						len := sizeItem; Mul (sizeItem, len, cons, LInt)
					END;
					ASSERT (sizeItem.mode # Con);
					load (sizeItem);
				ELSE
					MakeCon (sizeItem, PLT.linttyp, atyp.size)
				END;
				GenPush (sizeItem)
			ELSE (* push len *)
				IF atyp.comp = DynArr THEN
					len.typ := PLT.linttyp; len.inx := none; len.node := NIL; (* >> mh/nm 30.8.94 *)
					len.mnolev := actualParam.mnolev;
					IF descReg = FP THEN (* descriptor is on the stack *)
						len.mode := Var; len.offs := 0; len.adr := atyp.offset + descOffs;
						CompleteSL(len)
					ELSE (* descriptor is already loaded *)
						len.mode := RegRel; len.adr := descReg; len.offs := atyp.offset + descOffs;
					END; (* << mh/nm 30.8.94 *)
					load (len);
				ELSIF atyp.form = String THEN (* String *)
					MakeCon (len, PLT.linttyp, actualParam.offs) (* actualParam.offs = Length (String) *)
				ELSE (* Array *)
					ASSERT (atyp.comp = Array);
					MakeCon (len, PLT.linttyp, atyp.n)
				END;
				GenPush (len)
			END;
			ftyp := ftyp.BaseTyp; atyp := atyp.BaseTyp (* next dimension *)
		END
	END PushDynArrLen;

	PROCEDURE ParRecord (fp: PLT.Object; VAR ap: Item; apIsDeref: BOOLEAN); (* record parameter *) (* mh 16.2.94 *)
		VAR t, tag: Item;
	BEGIN
		IF ap.mode = VarPar THEN
			IF fp.mode = VarPar THEN (* push tag too -> tag is on the stack as a hidden parameter *)
				t.mode := Var; t.adr := ap.adr + 4; t.typ := PLT.sysptrtyp; t.node := NIL; 
				t.inx := none; t.offs := 0; t.mnolev := ap.mnolev;
				load (t); GenPush (t)
			END;
			loadAdr(ap); GenPush(ap)
		ELSE
			IF fp.mode = VarPar THEN (* push {Var, Abs} record *)
				IF apIsDeref THEN (* get type descriptor of dynamic type *)
					ASSERT((ap.mode = RegRel) & (ap.offs = 0));
					tag.mode := RegRel; tag.scale := noScale; tag.typ := PLT.sysptrtyp;
					tag.offs := -4; tag.adr := ap.adr; tag.inx := none; tag.descReg := none
				ELSE
					GetTdAdr(ap.typ, tag); (* get typedescriptor address of static type *)
				END;
				load(tag); GenPush(tag)
			END;
			loadAdr(ap); GenPush(ap)
		END
	END ParRecord;

	PROCEDURE Parameter* (VAR ap: Item; fp: PLT.Object; apIsDeref: BOOLEAN);
		VAR form, apMode: SHORTINT; temp, cons, stack, tag: Item;
			proc: PLT.Object; apTyp, fpTyp: PLT.Struct;
	BEGIN
		fpTyp := fp.typ; apTyp := ap.typ;
		IF (fp.mode = VarPar) OR (fpTyp.form IN {String,Comp}) THEN
			(* push actual parameter (ap) as Var-Parameter *)
			form := fpTyp.comp;
			IF form = DynArr THEN 
				PushDynArrLen (fp, ap);
				loadAdr (ap); GenPush (ap)
			ELSIF form = Record THEN ParRecord (fp, ap, apIsDeref) 
			ELSE
				apMode := ap.mode;
				IF apTyp.form = String THEN (* constant *) ap.node := NIL END;
				loadAdr (ap); GenPush (ap);
				IF (fpTyp = PLT.sysptrtyp) & (apTyp # PLT.sysptrtyp) THEN
					(* pass ap static typ to enable run time tests -> hack *)
					GetTdAdr (apTyp.BaseTyp, tag);
					ap.mode := RegRel; Assign (ap, tag);
				ELSIF (fpTyp = PLT.sysptrtyp) & (apTyp = PLT.sysptrtyp) & (apMode # VarPar) THEN
					(* pass nil to disable runtime tests -> hack *)
					MakeCon (cons, PLT.linttyp, nil);
					ap.mode := RegRel; Assign (ap, cons)
				END
			END
		ELSE
			ASSERT (ap.mode IN {Abs, Var, Par, VarPar, Con, Reg, RegRel, Coc, XProc, LProc});
			form := apTyp.form;
			IF (apTyp # fpTyp) & ~(ap.mode IN {XProc, LProc}) & ~(form  IN {Pointer, NilTyp, NoTyp}) THEN
				(* convert actual parameter *)
				Convert (ap, fp.typ.form); form := ap.typ.form
			END;
			IF (form IN realSet) & (ap.mode = Reg) THEN (* ap was converted *)
				IF fp.typ.form = Real THEN MakeCon (cons, PLT.linttyp, 4)
				ELSE MakeCon (cons, PLT.linttyp, 8)
				END;
				stack := Stack;
				Gen3 (sub, stack, stack, cons);
				stack.mode := RegRel; stack.offs := 0; stack.inx := none; stack.typ := fp.typ; (* PLT.lrltyp; *)
				GenStore (fstore, stack, ap)
			ELSE
				IF ap.mode IN {XProc, LProc} THEN
					proc := ap.node.obj;
					GenLoadProc(ldProc, ap, proc.linkadr, ap.node)
				ELSIF form = LReal THEN (* push higher 4 bytes -> lower bytes will be pushed later *)
					temp := ap; temp.typ := PLT.linttyp;
					IF temp.mode = VarPar THEN loadAdr(temp); temp.mode := RegRel; temp.offs := 0 END; (* << mb 15.2.94 *)
					IF temp.mode = RegRel THEN INC (temp.offs, 4)
					ELSE INC (temp.adr, 4)
					END;
					load (temp); GenPush (temp)
				ELSIF ap.mode = Coc THEN
					temp := ap; MoveCoc (ap, temp)
				END;
				IF ap.mode # Con THEN
					IF ap.typ.form IN realSet THEN ap.typ := PLT.linttyp END;
					load (ap)
				END;
				GenPush (ap)
			END
		END
	END Parameter;
	
	PROCEDURE Call* (VAR x: Item; proc: PLT.Object; node: PLL.Node); (* ejz *)
		VAR n: INTEGER; sl, tag: Item;
			param: PLT.Object; 
	BEGIN
		IF (x.mode = LProc) OR (x.mode = CProc) OR ((x.mode = XProc) & (x.mnolev = 0)) THEN (* local procedure *)
			IF x.mnolev >= 1 (* slNeeded IN proc.conval.setval *) THEN
				n := level - x.mnolev;
				sl.mode := Var; sl.typ := PLT.linttyp; sl.mnolev := level; sl.inx := none; sl.node := NIL;
				IF n = 0 THEN
					sl.mode := Reg; sl.adr := FP;
					GenPush(sl)
				ELSIF n = 1 THEN
					sl.adr := StaticLinkAdr;
					load(sl); GenPush(sl)
				ELSE
					sl.adr := StaticLinkAdr;
					load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
					WHILE n > 2 DO
						load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
						DEC (n)
					END;
					load(sl);
					GenPush(sl)
				END
			END;
			GenCall (call, proc.linkadr, proc.ival - 4, node)
		ELSIF x.mode = XProc THEN (* external procedure *)
			GenCall (xcall, x.adr, proc.ival - 4, node)
		ELSIF x.mode = TProc THEN
			IF node.left.safe THEN (* super call *)
				IF node.right.obj.typ.form = Pointer THEN GetTdAdr(node.right.obj.typ.BaseTyp.BaseTyp, tag)
				ELSE GetTdAdr (node.right.obj.typ.BaseTyp, tag)
				END;
				load(tag)
			ELSE
				(* IF node.obj.mode = VarPar (* node.left.obj.mode = VarPar *) THEN	(* << mb 21.2.94 *) *)
				IF node.right.obj.mode = VarPar THEN
					tag.mode := RegRel; tag.typ := PLT.sysptrtyp; tag.node := NIL;
					tag.adr := ESP; tag.offs := 4  (*0*)(* obj.conval.intval - 12 (* 8 *) *); tag.inx := none; 
				(* ELSE (* pointer *) *)
				ELSIF node.right.obj.mode = Par THEN
					tag.mode := RegRel; tag.typ := PLT.sysptrtyp; tag.node := NIL;
					tag.adr := ESP; tag.offs := 0 (* obj.conval.intval - 12 *); tag.inx := none;
					DeRef(tag); tag.mode := RegRel; tag.offs := -4
				ELSE HALT(99)
				END;
				DeRef(tag)
			END;
			x.adr := tag.adr; (* x.offs set by OPV.Designator *)
			x.mode := RegRel; x.typ := PLT.sysptrtyp; load (x);
			GenCall(callReg, x.adr, proc.ival - 4, node)
		ELSE (* procedure variable *)
			ASSERT (x.typ.form = ProcTyp);
			load(x);
			param := x.typ.dsc; 
			IF param = NIL THEN GenCall(callReg, x.adr, 0, node) (* no parameter *)
			ELSE GenCall(callReg, x.adr, param.adr, node)
			END
		END
	END Call;
	
	PROCEDURE PopResult* (n: PLL.Node; VAR z: Item);
	BEGIN
		IF n # NIL THEN (* result into ST(0) or EAX *)
			z.typ := n.typ; z.mode := Reg; z.adr := pc;
			IF z.typ.form IN {Byte..LInt, Set, Pointer, ProcTyp} THEN
				GenPopReg (PLL.useEAX, z.typ.form)
			ELSE (* z.typ.form IN realSet *)
				ASSERT (z.typ.form IN realSet);
				GenPopReg (PLL.useST, z.typ.form) (* top of stack contains result *)
			END
		ELSE
			GenPopReg (PLL.noHint, 0) (* no result *)
		END
	END PopResult;
	

PROCEDURE Enter* (proc: PLT.Object; dataSize: LONGINT; node: PLL.Node);
	VAR 
		par: PLT.Object;
		z, x, sizeItem, stackCorr, t0, t1, arr: Item; 
		size: LONGINT; 
		moveSize: SHORTINT;
BEGIN (* !!later due to a bug this procedure looks no longer very nice *)
	IF proc # NIL THEN
		PLL.FixupLocalProcCall (proc); (* fixup local procedure calls and assign target pc to procedure *)
		par := proc.par
	ELSE 
		NEW(proc); proc.adr := 0; proc.mode := XProc; PLL.FixupLocalProcCall(proc); par := NIL;
	END;
	Gen1 (enter, dataSize, node);
	WHILE par # NIL DO (* copy val parameter Record, Array and DynArr *)
		IF (par.mode = Var) OR (par.mode = Par) THEN
			IF par.typ.comp = DynArr THEN (* open array *)
				arr.mode := RegRel; arr.typ := par.typ; arr.descReg := FP; arr.descOffs := par.adr; 
				arr.mnolev := par.level; arr.node := NIL;
				(* arr.adr, arr.offs are not used *)
				DynArrSize (sizeItem, arr, size); (* get open array size *)
				stackCorr := sizeItem;
				IF size # 1 THEN
					MakeCon (t0, PLT.linttyp, size);
					t1 := stackCorr; Mul (stackCorr, t1, t0, LInt);
					IF size = 2 THEN 
						moveSize := PLO.Bit16; load (sizeItem)
					ELSIF size = 4 THEN 
						moveSize := PLO.Bit32; load (sizeItem)
					ELSE 
						moveSize (* size *):= PLO.Bit8; sizeItem := stackCorr
					END
				ELSE
					load (sizeItem); load (stackCorr);
					moveSize := PLO.Bit8
				END;
				IF size MOD 4 # 0 THEN (* align stack *)
					stackCorr.typ := PLT.linttyp;
					MakeCon (t0, PLT.linttyp, 3);
					t1.node := NIL;
					Gen3 (add, t1, stackCorr, t0); t1.typ := PLT.linttyp;
					t0.adr := -4;
					Gen3 (and, stackCorr, t1, t0)
				END;
				t0 := Stack; Gen3 (sub, z, t0, stackCorr); PLL.Instr [pc-1].hint := PLL.useESP;
				z.adr := ESP; z.typ := PLT.linttyp; z.node := NIL; z.mnolev := par.level;
				x.mode := VarPar; x.typ := PLT.linttyp; x.adr := par.adr; x.node :=  NIL; x.mnolev := z.mnolev;
				t0 := z; t1 := x;
				MoveBlock (t0, t1, sizeItem, moveSize); (* copy array *)
				x.mode := Var;
				Move (x, z); (* stack pointer is the new array address *)

			ELSIF par.typ.comp IN {Array, Record} THEN (* copy array, record *)
				z.mode := Var; z.typ := PLT.linttyp; z.node := NIL; z.adr := par.linkadr; z.mnolev := par.level;
				x.mode := VarPar; x.typ := PLT.linttyp; x.adr := par.adr; x.node := NIL; x.mnolev := par.level;
				MakeCon (sizeItem, PLT.linttyp, par.typ.size);
				MoveBlock (z, x, sizeItem, PLO.Bit8)
			END
		END;
		par := par.nxtobj
	END
END Enter;


	PROCEDURE Return* (VAR res: Item; procform: SHORTINT); (* RETURN res *)
		VAR t: Item; pReg: LONGINT;
	BEGIN
		IF res.mode = Coc THEN
			t := res;
			IF (t.offs = Nil) & (t.inx = Nil) THEN
				MoveCoc (res, t); PLL.Instr [res.adr].hint := PLL.useEAX
			ELSE
				MoveCoc (res, t);
				ASSERT (PLL.Instr [pc-2].op = phi);
				pReg := PLL.Instr [pc-2].src1;
				PLL.Instr [pReg].hint := PLL.useEAX
			END
		ELSE
			IF res.typ.form = NoTyp THEN (* RETURN procedure *)
				GenLoadProc(ldProc, res, res.node.obj.linkadr, res.node);
				PLL.Instr [res.adr].hint := PLL.useEAX
			ELSIF (procform # res.typ.form) & (res.typ.form # NilTyp) THEN
				ASSERT (procform # Set);
				Convert (res, procform)
			END;
			IF res.typ.form IN realSet THEN loadf (res)
			ELSE
				load (res);
				PLL.Instr [res.adr].hint := PLL.useEAX
			END
		END
	END Return;


PROCEDURE Exit* (proc: PLT.Object);
BEGIN
	IF proc # NIL THEN (* procedure *)
		Gen1 (leave, proc.intval2, NIL);
		Gen1 (ret, proc.ival - 8, NIL)
	ELSE (* from module *)
		Gen1 (leave, 0, NIL);
		Gen1 (ret, 0, NIL)
	END
END Exit;

PROCEDURE Trap* (n: LONGINT; node: PLL.Node); (* HALT (n) *)
BEGIN
	Gen1 (trap, n, node)
END Trap;

	
	PROCEDURE GenDimTrap* (VAR len: Item);
		VAR const: Item;
	BEGIN
		IF inxchk THEN
			MakeCon (const, PLT.linttyp, 0);
			load (len);
			GenFlags (cmp, len, const);
			Gen1 (tle, PLL.DimTrap , NIL)
		END
	END GenDimTrap;

	PROCEDURE Case* (VAR x: Item; low, high: LONGINT; VAR tab: LONGINT; VAR L: Label; node: PLL.Node);
	(* optimize the case where CASE expr and expr is constant! *)
		VAR c, y: Item;
	BEGIN
		MakeCon (c, PLT.linttyp, low);
		IF x.typ.form # LInt THEN
			IF x.mode = Con THEN 
				x.typ := PLT.linttyp;
				load (x)
			ELSE Convert (x, LInt)
			END
		ELSE load (x)
		END;
		IF low # 0 THEN
			Gen3 (sub, x, x, c)
		END;
		c.adr := high-low;
		GenFlags (cmp, x, c);
		L := -2-pc; Gen1 (ja, Nil, node);
		PLL.AllocCaseTab (low, high, tab);
		c.mode := Abs; c.typ := PLT.linttyp; c.adr := tab + SYSTEM.ADR(PLO.data[0]); c.inx := x.adr; c.scale := PLO.Scale4; c.node := NIL;
		GenLoad (ld, y, c);
		Gen1 (jmpReg, y.adr, node)
	END Case;
	
	PROCEDURE CaseFixup* (tab: LONGINT; elseLabel: Label; len: LONGINT); (* case *)
	BEGIN
		InitInstr (case, 0, 0, NIL);
		PLL.Instr [pc].src1 := tab; PLL.Instr [pc].src2 := elseLabel; PLL.Instr [pc].inx := len * 4;
		INC (pc)
	END CaseFixup;
	

BEGIN
	MakeCon (True, PLT.booltyp, true);
	MakeCon (False, PLT.booltyp, false);
	Stack.mode := Reg; Stack.adr := ESP; Stack.node := NIL; Stack.typ := PLT.linttyp; Stack.offs := 0; Stack.inx := none;
	formTab[Undef] := 0;
	formTab[Byte] := PLO.Bit8 DIV 8; formTab[Bool] := PLO.Bit8 DIV 8; 
	formTab[Char] := PLO.Bit8 DIV 8; formTab[SInt] := PLO.Bit8 DIV 8;
	formTab[Int] := PLO.Bit16 DIV 8;
	formTab[LInt] := PLO.Bit32; formTab[Set] := PLO.Bit32;
	formTab[Pointer] := PLO.Bit32; formTab[ProcTyp] := PLO.Bit32; 
	formTab[NilTyp] := PLO.Bit32; formTab[Comp] := PLO.Bit32;
	formTab[Real] := 3;
	formTab[LReal] := 4;
	CCtab[0,0] := EQ; CCtab [0,1] := NE; CCtab [0,2] := LT; CCtab [0,3] := LE; CCtab [0,4] := GT; CCtab [0,5] := GE;
	CCtab[1,0] := EQ; CCtab [1,1] := NE; CCtab [1,2] := BL; CCtab [1,3] := BE; CCtab [1,4] := AB; CCtab [1,5] := AE;
	InvCCtab [0] := NE; InvCCtab [1] := EQ; InvCCtab [2] := GE; InvCCtab [3] := GT; InvCCtab [4] := LE; InvCCtab [5] := LT;
	InvCCtab [6] := BE; InvCCtab [7] := BL; InvCCtab [8] := AE; InvCCtab [9] := AB; InvCCtab [10] := CC; InvCCtab [11] := CS;
	
	newRec := Kernel.NewRec; 
	newSys := Kernel.NewSys;
	newArr := Kernel.NewArr;
	KernelRoutines[0] := SYSTEM.VAL(LONGINT, newRec);
	KernelRoutines[1] := SYSTEM.VAL(LONGINT, newSys);
	KernelRoutines[2] := SYSTEM.VAL(LONGINT, newArr);

END OPLC.
