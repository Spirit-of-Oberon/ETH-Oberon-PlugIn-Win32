(* OBERON System 3, Release 2.2.

Copyright 1996, 1997 Team of the Institute of Computer Systems of ETH Zürich, ETH Center, CH-8092 Zürich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

or requested from the above mentioned address.

Under the license terms stated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Builder;	(* adapted to the windows compiler/ does not support pc location *)

(*
	29.3.94 - Check if module is missing
	19.4.04 - Added support for /d compile option
	11.5.94 - remove error gadgets from the text 
	9.6.94 - Can compile from all text editors that keep to the Oberon conventions, does not import documents any more
	17.11.94 - improved option char
	15.11.94 - modified gettext
	12.1.94 - fixed /f option compilation
	18.1.95 - improved NextError
	23.10.95 - fixed free trap
	5.1.96 - increase filename length
*)

IMPORT
	OPS := OOPS, OPM := OOPM, Compiler, Oberon, Display, Gadgets, Texts, Attributes, Objects, Icons, Modules,
	Display3, Fonts, Effects, Files, Strings;
	
CONST
	(* old Wirth compiler + DOS oberon 
	module = 61; ident = 37; semicolon = 38; import = 60; 
	*)
	(* new Wirth compiler 
	module = 63; ident = 37; semicolon = 38; import = 62;
	*)
	(* windows compiler + Macintosh compiler*)
	module = 63; ident = 38; semicolon = 39; import = 62; becomes = 34; comma = 19;
	(* *)
	
TYPE
	ErrorGadget* = POINTER TO ErrorGadgetDesc;
	ErrorGadgetDesc* = RECORD (Gadgets.FrameDesc)
		errno*: INTEGER;
		msg*: POINTER TO ARRAY 128 OF CHAR;
	END;

	(* Module hierarchy *)
	Mod* = POINTER TO ModDesc;
	Ref* = POINTER TO RefDesc;
	RefDesc* = RECORD
		mod*: Mod;
		next*: Ref;
	END;
	ModDesc* = RECORD 
		name*, fname*, opts: ARRAY 64 OF CHAR;
		ref*, layer*: INTEGER;
		impl*: Ref;
		next*: Mod;
	END;
	
	Tree* = RECORD
		maxlayer*: INTEGER;
		list*: Mod;
	END;

VAR
	compiler, options: ARRAY 64 OF CHAR;
	W: Texts.Writer;
	sym: SHORTINT; (* << win *)
	error: BOOLEAN;
	
	tt: Tree;

	errtext: Texts.Text;

(** Get the marked text *)
PROCEDURE GetText(VAR par: Display.Frame): Texts.Text;
BEGIN
	par := Oberon.MarkedFrame();
	RETURN Oberon.MarkedText()
END GetText;

(* ---------------- ErrorGadget -------------- *)

PROCEDURE ErrorGadgetAttr(F: ErrorGadget; VAR M: Objects.AttrMsg);
BEGIN
	IF M.id = Objects.get THEN
		IF M.name = "Gen" THEN M.class := Objects.String; COPY("Builder.NewErrorGadget", M.s); M.res := 0
		ELSIF M.name = "LineupHY" THEN M.class := Objects.Int; M.i := ABS(Fonts.Default.minY) + 1; M.res := 0
		ELSE Gadgets.framehandle(F, M)
		END
	ELSIF M.id = Objects.set THEN
		Gadgets.framehandle(F, M);
	ELSIF M.id = Objects.enum THEN
		Gadgets.framehandle(F, M)
	END
END ErrorGadgetAttr;

PROCEDURE RestoreErrorGadget(F: ErrorGadget; M: Display3.Mask; x, y, w, h: INTEGER);
VAR s: ARRAY 128 OF CHAR;
BEGIN
(*
	Display3.FilledRect3D(M, Display3.topC, Display3.bottomC, Display3.groupC, x, y, w, h, 1, Display.replace);
*)
	Display3.ReplConst(M, Display3.groupC, x, y, w, h, Display.replace);
	IF F.msg # NIL THEN
		Display3.CenterString(M, Display.FG, x, y, w, h, Fonts.Default, F.msg^, Display.paint)
	ELSE
		Strings.IntToStr(F.errno, s);
		Display3.CenterString(M, Display.FG, x, y, w, h, Fonts.Default, s, Display.paint)
	END;
	IF Gadgets.selected IN F.state THEN
		Display3.FillPattern(M, Display3.white, Display3.selectpat, x, y, x, y, w, h, Display.paint)
	END
END RestoreErrorGadget;

PROCEDURE CopyErrorGadget*(VAR M: Objects.CopyMsg; from, to: ErrorGadget);
BEGIN
	to.errno := from.errno;
	Gadgets.CopyFrame(M, from, to);
END CopyErrorGadget;

PROCEDURE GetErrMsg (errNr: INTEGER; VAR msg: ARRAY OF CHAR);	
VAR s: Texts.Scanner; n: INTEGER; ch: CHAR;
BEGIN Texts.OpenScanner(s, errtext, 0);
	REPEAT Texts.Scan(s) UNTIL s.eot OR (s.class = Texts.Int) & (s.i = 0);
	WHILE ~ s.eot & ((s.class # Texts.Int) OR (s.i # errNr)) DO Texts.Scan(s) END;
	IF ~s.eot THEN Texts.Read(s, ch); n := 0;
		WHILE ~s.eot & (ch # 0DX) DO msg[n] := ch; INC(n); Texts.Read(s, ch) END;
		msg[n] := 0X
	END
END GetErrMsg;

PROCEDURE FlipMsg(F: ErrorGadget);
VAR w, h, dsr: INTEGER; A: Display.ModifyMsg;
BEGIN
	IF F.msg = NIL THEN
		NEW(F.msg); GetErrMsg(F.errno, F.msg^); Display3.StringSize(F.msg^, Fonts.Default, w, h, dsr);
		INC(w, 5);
	ELSE F.msg := NIL; w := 20
	END;
	A.F := F; A.id := Display.extend; A.mode := Display.display;
	A.X := F.X; A.Y := F.Y; A.W := w; A.H := F.H;
	A.dX := 0; A.dY := 0; A.dW := A.W - F.W; A.dH := 0;
	Display.Broadcast(A);
END FlipMsg;

PROCEDURE ErrorGadgetHandler*(F: Objects.Object; VAR M: Objects.ObjMsg);
VAR x, y, w, h: INTEGER; F0: ErrorGadget; R: Display3.Mask; keysum: SET;
BEGIN
	WITH F: ErrorGadget DO
		IF M IS Display.FrameMsg THEN
			WITH M: Display.FrameMsg DO
				IF (M.F = NIL) OR (M.F = F) THEN	(* message addressed to this frame *)
					x := M.x + F.X; y := M.y + F.Y; w := F.W; h := F.H; (* calculate display coordinates *)
					IF M IS Display.DisplayMsg THEN
						WITH M: Display.DisplayMsg  DO
							IF M.device = Display.screen THEN
								IF (M.id = Display.full) OR (M.F = NIL) THEN
									Gadgets.MakeMask(F, x, y, M.dlink, R);
									RestoreErrorGadget(F, R, x, y, w, h)
								ELSIF M.id = Display.area THEN
									Gadgets.MakeMask(F, x, y, M.dlink, R);
									Display3.AdjustMask(R, x + M.u, y + h - 1 + M.v, M.w, M.h);
									RestoreErrorGadget(F, R, x, y, w, h)
								END
							END
						END
					ELSIF M IS Oberon.InputMsg THEN
						WITH M: Oberon.InputMsg DO
							IF (M.id = Oberon.track) & Gadgets.InActiveArea(F, M) & (M.keys = {1}) THEN
								Gadgets.MakeMask(F, x, y, M.dlink, R);
								Effects.TrackHighlight(R, keysum, M.X, M.Y, x, y, w, h);
								IF (keysum = {1}) & Effects.Inside(M.X, M.Y, x, y, w, h) THEN
									FlipMsg(F);
								END;
								M.res := 0
							ELSE Gadgets.framehandle(F, M)
							END
						END
					ELSE Gadgets.framehandle(F, M)
					END
				END
			END
			
		(* Object messages *)
		
		ELSIF M IS Objects.AttrMsg THEN ErrorGadgetAttr(F, M(Objects.AttrMsg))
		ELSIF M IS Objects.FileMsg THEN
			WITH M: Objects.FileMsg DO
				IF M.id = Objects.store THEN
					Files.WriteInt(M.R, F.errno);
					IF F.msg # NIL THEN Files.WriteInt(M.R, 1); Files.WriteString(M.R, F.msg^) ELSE Files.WriteInt(M.R, 0) END;
					Gadgets.framehandle(F, M)
				ELSIF M.id = Objects.load THEN
					Files.ReadInt(M.R, F.errno);
					Files.ReadInt(M.R, x);
					IF x = 1 THEN NEW(F.msg); Files.ReadString(M.R, F.msg^) END;
					Gadgets.framehandle(F, M)
				END
			END
		ELSIF M IS Objects.CopyMsg THEN
			WITH M: Objects.CopyMsg DO
				IF M.stamp = F.stamp THEN M.obj := F.dlink	(* copy msg arrives again *)
				ELSE	(* first time copy message arrives *)
					NEW(F0); F.stamp := M.stamp; F.dlink := F0; CopyErrorGadget(M, F, F0); M.obj := F0
				END
			END
		ELSE	(* unknown msg, framehandler might know it *)
			Gadgets.framehandle(F, M)
		END
	END
END ErrorGadgetHandler;

PROCEDURE NewErrorGadget*;
VAR F: ErrorGadget;
BEGIN NEW(F); F.W := 20; F.H := 14; F.errno := 255;F.handle := ErrorGadgetHandler; Objects.NewObj := F;
END NewErrorGadget;

PROCEDURE MarkErrorPos(T: Texts.Text; pos: LONGINT; err: INTEGER);
VAR obj: Objects.Object;
BEGIN
	NewErrorGadget; obj := Objects.NewObj; obj(ErrorGadget).errno := err;
	Texts.WriteObj(W, obj); Texts.Insert(T, pos, W.buf)
END MarkErrorPos;

PROCEDURE RemoveErrors(T: Texts.Text);
VAR first: LONGINT; F: Texts.Finder; o: Objects.Object;
BEGIN
	first := -1;
	LOOP
		Texts.OpenFinder(F, T, 0);
		IF F.eot THEN EXIT END;
		first := F.pos;
		Texts.FindObj(F, o);
		LOOP
			IF F.eot THEN EXIT END;
			IF (o # NIL) & (o IS ErrorGadget) THEN EXIT
			ELSE
				first := F.pos;
				Texts.FindObj(F, o);
			END;
		END;
		IF F.eot THEN EXIT END;
		IF (o # NIL) & (o IS ErrorGadget) THEN
			Texts.Delete(T, first, first+1)
		END
	END
END RemoveErrors;

PROCEDURE MarkErrors*;
VAR S: Texts.Scanner; par: Display.Frame; c, err: INTEGER; pos, beg, end, time: LONGINT; T, errtext: Texts.Text;
	C: Oberon.CaretMsg;
BEGIN
	errtext := GetText(par);
	IF errtext # NIL THEN
		Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
		IF (S.class = Texts.Char) & (S.c = "^") OR (S.line # 0) THEN
			Oberon.GetSelection(T, beg, end, time);
			IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S) END
		END;
		c := 0; beg := -1;
		WHILE (S.class = Texts.Name) & (S.s = "pos") DO
			Texts.Scan(S); pos := S.i; Texts.Scan(S); Texts.Scan(S); err := SHORT(S.i);
			IF c = 0 THEN beg := pos+1 END;
			MarkErrorPos(errtext, pos + c, err); INC(c);
			Texts.Scan(S);
		END;
		IF (beg > 0) & (par # NIL) THEN
			C.id := Oberon.set; C.F := par; C.car := par; C.text := errtext; C.pos := beg;
			Display.Broadcast(C)
		END
	END
END MarkErrors;

PROCEDURE ClearErrors*;
VAR T: Texts.Text; par: Display.Frame; 
BEGIN
	T := GetText(par);
	IF T # NIL THEN RemoveErrors(T) END
END ClearErrors;

PROCEDURE ErrorAfter(T: Texts.Text; VAR pos: LONGINT);
VAR F: Texts.Finder; o: Objects.Object; p: LONGINT;
BEGIN
	Texts.OpenFinder(F, T, pos);
	p := F.pos; Texts.FindObj(F, o);
	WHILE (o # NIL) & (~(o IS ErrorGadget) OR (p <= pos)) DO p := F.pos; Texts.FindObj(F, o) END;
	IF (o # NIL) & (o IS ErrorGadget) THEN pos := p + 1 ELSE pos := -1 END;
END ErrorAfter;

PROCEDURE NextError*;
VAR M: Oberon.CaretMsg; pos: LONGINT;
BEGIN
	M.F := NIL; M.id := Oberon.get; M.car := NIL; M.text := NIL; Display.Broadcast(M);
	IF (M.car # NIL) & (M.text # NIL) THEN
		pos := M.pos; ErrorAfter(M.text, pos);
		IF pos >= 0 THEN
			M.id := Oberon.set; M.F := M.car; M.pos := pos; Display.Broadcast(M)
		ELSE (* no more errors *)
			pos := 0; ErrorAfter(M.text, pos);
			IF pos >= 0 THEN
				M.id := Oberon.set; M.F := M.car; M.pos := pos; Display.Broadcast(M)
			ELSE Oberon.Defocus
			END
		END
	END
END NextError;

(* ---------------- hierarchy calculation -------------- *)

PROCEDURE MatchSym(s: INTEGER): BOOLEAN;
BEGIN
	IF s = sym THEN
		OPS.Get(sym); RETURN TRUE
	ELSE RETURN FALSE END;
END MatchSym;

PROCEDURE Import(VAR T: Tree; M: Mod);
VAR modname: ARRAY 64 OF CHAR; m: Mod; r: Ref;
BEGIN
	IF sym = ident THEN (* ident *)
		COPY(OPS.name, modname); OPS.Get(sym);
		IF sym = becomes THEN (* := *)
			OPS.Get(sym);
			IF sym = ident THEN
				COPY(OPS.name, modname); OPS.Get(sym);
			END;
		END;
		IF modname # "SYSTEM" THEN
			m := T.list; (* find module in list *)
			WHILE (m # NIL) & (m.name # modname) DO m := m.next END;
			IF m = NIL THEN (* module not found in list *)
				NEW(m); COPY(modname, m.name); m.next := T.list; T.list := m; (* insert in list *)
			END;	
			r := M.impl;
			WHILE (r # NIL) & (r.mod # m) DO r := r.next END;
			IF r = NIL THEN
				NEW(r); r.mod := m; r.next := M.impl; M.impl := r; INC(m.ref);
			END;
		END;
	END;
END Import;

PROCEDURE ImportList(VAR T: Tree; M: Mod);
BEGIN
	LOOP Import(T, M);
		IF sym = semicolon THEN EXIT END; (* ; *)
		IF sym # comma THEN EXIT ELSE OPS.Get(sym) END; (* , *)
	END;
END ImportList;	

PROCEDURE AddModule*(VAR T: Tree; s: ARRAY OF CHAR; opts: ARRAY OF CHAR);
VAR M, m: Mod; t: Texts.Text; R: Texts.Reader;
BEGIN
	NEW(M); COPY(s, M.fname); COPY(opts, M.opts);
	NEW(t); Texts.Open(t, s);
	IF t.len = 0 THEN Texts.WriteString(W, s); Texts.WriteString(W, " not found"); Texts.WriteLn(W);
		Texts.Append(Oberon.Log, W.buf);
	ELSE
		Texts.OpenReader(R, t, 0); OPM.Init({}, R, Oberon.Log); (* << win *)
		OPS.Init; OPS.Get(sym);
		IF MatchSym(module) THEN (* module *)
			IF sym = ident THEN (* ident *)
				COPY(OPS.name, M.name);
				OPS.Get(sym);
				IF MatchSym(semicolon) & MatchSym(import) THEN (* ; IMPORT *)
					m := T.list;
					WHILE (m # NIL) & (m.name # M.name) DO m := m.next END;
					IF m = NIL THEN (* not in there already *)
						ImportList(T, M); M.next := T.list; T.list := M;
					ELSE
						IF m.fname[0] = 0X THEN (* already in list but has no file name *)
							M := m; COPY(s, M.fname); COPY(opts, M.opts); ImportList(T, M);
						END;
					END;
					error := FALSE; RETURN
				ELSE
					m := T.list;
					WHILE (m # NIL) & (m.name # M.name) DO m := m.next END;
					IF m = NIL THEN (* not in there already *)
						M.next := T.list; T.list := M
					ELSE
						IF m.fname[0] = 0X THEN (* already in list but has no file name *)
							M := m; COPY(s, M.fname); COPY(opts, M.opts); (* ImportList(T, M); *)
						END
					END;
					error := FALSE; RETURN
					(*
					Texts.WriteString(W, s); Texts.WriteString(W, " IMPORT expected"); Texts.WriteLn(W);
					Texts.Append(Oberon.Log, W.buf);
					*)
				END;
			ELSE
				Texts.WriteString(W, s); Texts.WriteString(W, " identifier expected"); Texts.WriteLn(W);
				Texts.Append(Oberon.Log, W.buf);
			END;
		ELSE
			Texts.WriteString(W, s); Texts.WriteString(W, " MODULE expected"); Texts.WriteLn(W);
			Texts.Append(Oberon.Log, W.buf);
		END
	END;
	error := TRUE
END AddModule;

PROCEDURE Mark(VAR T: Tree; m: Mod; layer: INTEGER);
VAR r: Ref; m0: Mod;
BEGIN
	IF layer > m.layer THEN
		IF layer > T.maxlayer THEN T.maxlayer := layer END;
		m.layer := layer;
		m0 := T.list;
		WHILE m0 # NIL DO
			r := m0.impl;
			WHILE r # NIL DO
				IF r.mod = m THEN Mark(T, m0, layer+1); END;
				r := r.next;
			END;
			m0 := m0.next;
		END;
	END;
END Mark;

PROCEDURE Hierarchy*(VAR T: Tree);
VAR m, m0, clist: Mod; r: Ref;
BEGIN
	(* calculate layers *)
	T.maxlayer := 0;
	m := T.list;
	WHILE m # NIL DO
		IF m.fname[0] # 0X THEN Mark(T, m, 1) END;
		m := m.next;
	END;
	(* process *)
	clist := NIL;
	LOOP
		m := T.list; m0 := NIL;
		WHILE (m # NIL) & (m.ref # 0) DO m0 := m; m := m.next END;
		IF m = NIL THEN
			IF T.list # NIL THEN
				Texts.WriteString(W, "inconsistant import hierarchy"); Texts.WriteLn(W);
				Texts.Append(Oberon.Log, W.buf);
			ELSE
				EXIT
			END;
		ELSE (* m is a module to be compiled *)
			(* remove m *)
			IF T.list = m THEN (* first in list *) T.list := m.next;
			ELSE m0.next := m.next;
			END;
			(* put in compile list *)
			m.next := clist; clist := m;
			r := m.impl; WHILE r # NIL DO DEC(r.mod.ref); r := r.next END; (* decrement references *)
		END;
	END;
	T.list := clist;
END Hierarchy;

PROCEDURE Append(VAR list: Display.Frame; f: Display.Frame);
BEGIN
	IF list = NIL THEN
		list := f; f.slink := NIL;
	ELSE
		f.slink := list; list := f;
	END;
END Append;

PROCEDURE InsertHierarchy*;
VAR S: Attributes.Scanner; m: Mod; T: Tree; list: Display.Frame; F: Icons.Icon; x, y, layer: INTEGER; obj: Objects.Object;
	A: Objects.AttrMsg; opts, s: ARRAY 32 OF CHAR; 
BEGIN
	T.list := NIL;
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	WHILE S.class = Attributes.Name DO
		COPY(S.s, s);
		Attributes.Scan(S);
		IF (S.class = Attributes.Char) & ((S.c = "%") OR (S.c = Oberon.OptionChar)) THEN
			Attributes.Scan(S); COPY(S.s, opts); Attributes.Scan(S)
		ELSE
			opts := "";
		END;
		AddModule(T, s, opts);
	END;
	Hierarchy(T);
	IF T.list # NIL THEN
		layer := 1; x := 0; y := 0; list := NIL;
		WHILE layer <= T.maxlayer DO
			m := T.list;
			WHILE m # NIL DO
				IF (m.fname[0] # 0X) & (m.layer = layer) THEN
					obj := Gadgets.FindPublicObj("Icons.Object");
					NEW(F); Icons.MakeIcon(F, m.fname, Icons.ViewOf(obj(Gadgets.Frame))); F.X := x; F.Y := y;
					A.id := Objects.set; A.name := "Cmd"; A.class := Objects.String;
					A.s := "Desktops.OpenDoc '#Caption '"; A.res := -1;
					F.handle(F, A);
					Append(list, F); INC(x, F.W);
				END;
				m := m.next;
			END;
			INC(layer); INC(y, 60); x := 0;
		END;
		Gadgets.Integrate(list);
	END;
END InsertHierarchy;

PROCEDURE Compile*;
VAR S: Attributes.Scanner; T: Tree; m: Mod; s, opts: ARRAY 64 OF CHAR; i, j: INTEGER; S1: Texts.Scanner;
	beg, fbeg, fend, ftime: LONGINT; text, ftext: Texts.Text; par: Display.Frame; R: Texts.Reader;
	
	PROCEDURE WriteFileName(source: Texts.Text);
	VAR S1: Texts.Scanner;
	BEGIN
		Texts.OpenScanner(S1, source, 0); Texts.Scan(S1);
		WHILE ~S1.eot & ((S1.class # Texts.Name) OR (S1.s # "MODULE")) DO Texts.Scan(S1) END;
		IF (S1.class = Texts.Name) & (S1.s = "MODULE") & ~S1.eot THEN Texts.Scan(S1);
			IF S1.class = Texts.Name THEN Texts.WriteString(W, " compiling "); Texts.WriteString(W, S1.s) END
		END;
		Texts.Append(Oberon.Log, W.buf);
	END WriteFileName;
	
BEGIN
	Texts.WriteString(W, "Builder.Compile ");
	T.list := NIL; options := "";
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	IF (S.class = Attributes.Char) & ((S.c = "%") OR (S.c = Oberon.OptionChar)) THEN
		Attributes.Scan(S); COPY(S.s, options);
		Texts.WriteString(W, " %"); Texts.WriteString(W, options); 
		Attributes.Scan(S);
	END;
	Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
	IF (S.class = Attributes.Char) & (S.c = "*") THEN
		text := GetText(par);
		IF text # NIL THEN
			beg := Oberon.Log.len; RemoveErrors(text);
			Texts.OpenReader(R, text, 0);
			WriteFileName(text);
			i := 0; WHILE (options[i] # 0X) & (options[i] # "f") DO INC(i) END;
			IF options[i] = "f" THEN
				Oberon.GetSelection(ftext, fbeg, fend, ftime);
				IF ftime >= 0 THEN
					Texts.OpenScanner(S1, ftext, fbeg); Texts.Scan(S1);
					IF S1.class = Texts.Int THEN Compiler.Module(R, options, S1.i, Oberon.Log, error); RETURN END
				END;
				Texts.WriteString(W, "  pc not selected"); Texts.WriteLn(W);
				Texts.Append(Oberon.Log, W.buf);
				RETURN
			ELSE Compiler.Module(R, options, MAX(LONGINT), Oberon.Log, error);
			END;
		ELSE Texts.WriteString(W, " text not found"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
		END
	ELSE
		error := FALSE;
		WHILE ~S.eot & ~error & (S.class = Attributes.Name) DO
			COPY(S.s, s);
			Attributes.Scan(S);
			IF (S.class = Attributes.Char) & ((S.c = "%") OR (S.c = Oberon.OptionChar)) THEN
				Attributes.Scan(S); COPY(S.s, opts); Attributes.Scan(S)
			ELSE
				opts := "";
			END;
			AddModule(T, s, opts);
		END;
		IF ~error THEN
			Hierarchy(T);
			tt := T; (* fool garbage collector *)
			m := T.list;
			WHILE (m # NIL) & ~error DO
				IF m.fname[0] # 0X THEN
					s := "Compiler.Compile "; i:=0; WHILE s[i] # 0X DO INC(i) END;
					j := 0; WHILE m.fname[j] # 0X DO s[i] := m.fname[j]; INC(i); INC(j) END;
					IF (options # "") OR (m.opts # "") THEN
						s[i] := Oberon.OptionChar; INC(i);
						j := 0;
						WHILE options[j] # 0X DO s[i] := options[j]; INC(i); INC(j); END;
						j := 0;
						WHILE m.opts[j] # 0X DO s[i] := m.opts[j]; INC(i); INC(j); END;
					END;
					s[i] := " "; s[i+1] := "~"; s[i+2] := 0X;
					Gadgets.Execute(s, NIL, NIL, NIL, NIL);
					error := ~OPM.noerr;
				END;
				m := m.next;
			END;
		END
	END;
	tt.list := NIL;
END Compile;

PROCEDURE Free*;
VAR S: Attributes.Scanner; T: Tree;

	PROCEDURE F(mod: Mod);
	BEGIN
		IF mod.next # NIL THEN F(mod.next) END;
		IF (mod.fname[0] # 0X) & (mod.name[0] # 0X) THEN
			Texts.WriteString(W, mod.name); Texts.WriteString(W, " unloading");
			Modules.Free(mod.name, FALSE); 
			IF Modules.res # 0 THEN Texts.WriteString(W, " failed") END;
			Texts.WriteLn(W);
			Texts.Append(Oberon.Log, W.buf)
		END;
	END F;
	
BEGIN
	Texts.WriteString(W, "Builder.Free"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
	T.list := NIL;
	Attributes.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);
	Attributes.Scan(S);
	WHILE ~S.eot & (S.class = Attributes.Name) DO
		AddModule(T, S.s, ""); Attributes.Scan(S);
	END;
	
	Hierarchy(T);
	IF T.list # NIL THEN F(T.list) END
END Free;

BEGIN
	COPY("Compiler.Compile ", compiler); options := "";
	Texts.OpenWriter(W);
	NEW(errtext); Texts.Open(errtext, "OberonErrors.Text");
END Builder.
