(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Fonts; (** portable / source: Win32.Fonts.Mod *)	(* ejz  *)
	IMPORT SYSTEM, Kernel32, Kernel, Registry, User32, GDI32, Win32, FileDir, Files, Objects, Display, Viewers, Strings;

	(** Font module supports Oberon bitmap fonts & Windows fonts (TT, FON).
		21.9.98 new implementation *)

	CONST
		Bold = 0; Italics = 1; Medium = 2; Underline = 3; Strikeout = 4; Thin = 5; Light = 6;
		substitute* = -1; font* = 0; metric* = 1;	(** Font types. *)
		DefFontName = "Arial10.Scn.Fnt";

	TYPE 
		Char* = POINTER TO CharDesc;
		Font* = POINTER TO FontDesc;

		CharDesc* = RECORD (Objects.ObjDesc)	(** The objects in a font library. *)
			dx*, x*, y*, w*, h*: INTEGER;	(** Character width, pattern offset (x, y), pattern size (w, h). *)
			pat*: Display.Pattern	(** Character raster data. *)
		END;

		FontDesc* = RECORD (Objects.LibDesc)
			type*: SHORTINT;	(** Substitute, font, or metric. *)
			height*, minX*, maxX*, minY*, maxY*: INTEGER	(** Font height, extremal values of characters in font. *)
		END;

	VAR
		FontId*: CHAR;	(** Initial character of font files (.Fnt). *)
		Default*: Font;	(** Default system screen font (typically Syntax10.Scn.Fnt). *)
		default: FileDir.FileName;
		curUnit, curType: LONGINT;
		theChar: Char;

	PROCEDURE ParseName(VAR name, family: ARRAY OF CHAR; VAR size: LONGINT; VAR style: SET; VAR class: ARRAY OF CHAR);
		VAR i, j: LONGINT;
	BEGIN
		size := 0; style := {};
		i := Strings.Length(name)-7; j := 0;
		WHILE j < 3 DO
			class[j] := name[i]; INC(i); INC(j)
		END;
		class[j] := 0X; i := i-5;
		LOOP
			CASE CAP(name[i]) OF
				"B": INCL(style, Bold); name[i] := "b"; DEC(i)
				|"M": INCL(style, Medium); name[i] := "m"; DEC(i)
				|"L": INCL(style, Light); name[i] := "l"; DEC(i)
				|"T": INCL(style, Thin); name[i] := "t"; DEC(i)
				|"I": INCL(style, Italics); name[i] := "i"; DEC(i)
				|"U": INCL(style, Underline); name[i] := "u"; DEC(i)
				|"S": INCL(style, Strikeout); name[i] := "s"; DEC(i)
			ELSE
				EXIT
			END
		END;
		WHILE (name[i] >= "0") & (name[i] <= "9") DO
			DEC(i)
		END;
		j := i+1;
		WHILE (name[j] >= "0") & (name[j] <= "9") DO
			size := 10*size + (ORD(name[j])-ORD("0")); INC(j)
		END;
		j := i; i := 0;
		WHILE i <= j DO
			family[i] := name[i]; INC(i)
		END;
		family[i] := 0X
	END ParseName;

	PROCEDURE BuildName(VAR name: ARRAY OF CHAR; family: ARRAY OF CHAR; size: LONGINT; style: SET; class: ARRAY OF CHAR);
		VAR str: ARRAY 8 OF CHAR;
	BEGIN
		COPY(family, name);
		IF size > 0 THEN
			Strings.IntToStr(size, str);
			Strings.Append(name, str)
		END;
		IF Bold IN style THEN
			Strings.AppendCh(name, "b")
		ELSIF Medium IN style THEN
			Strings.AppendCh(name, "m")
		ELSIF Light IN style THEN
			Strings.AppendCh(name, "l")
		ELSIF Thin IN style THEN
			Strings.AppendCh(name, "t")
		END;
		IF Italics IN style THEN
			Strings.AppendCh(name, "i")
		END;
		IF Underline IN style THEN
			Strings.AppendCh(name, "u")
		END;
		IF Strikeout IN style THEN
			Strings.AppendCh(name, "s")
		END;
		Strings.AppendCh(name, ".");
		Strings.Append(name, class);
		Strings.Append(name, ".Fnt")
	END BuildName;

	PROCEDURE FontInstaller(VAR lf: GDI32.LOGFONT; font: Win32.Font);
		VAR style: SET;
	BEGIN
		style := SYSTEM.VAL(SET, font.style);
		IF Bold IN style THEN
			lf.weight := GDI32.FWBold
		ELSIF Medium IN style THEN
			lf.weight := GDI32.FWMedium
		ELSIF Light IN style THEN
			lf.weight := GDI32.FWLight
		ELSIF Thin IN style THEN
			lf.weight := GDI32.FWThin
		ELSE
			lf.weight := GDI32.FWNormal
		END;
		IF Italics IN style THEN
			lf.italic := Kernel32.True
		ELSE
			lf.italic := Kernel32.False
		END;
		IF Underline IN style THEN
			lf.underline := Kernel32.True
		ELSE
			lf.underline := Kernel32.False
		END;
		IF Strikeout IN style THEN
			lf.strikeout := Kernel32.True
		ELSE
			lf.strikeout := Kernel32.False
		END;
		lf.height := -ENTIER(0.5 + font.size*curUnit / 91.4); lf.width := 0
	END FontInstaller;

	PROCEDURE [stdcall] *WinTTFontInstaller(lpelf, lpntm, type, data: LONGINT): LONGINT;
		VAR
			font: Win32.Font; F: Font;
			lf: GDI32.ENUMLOGFONT;
			res: LONGINT;
	BEGIN
		res := 1;
		IF Kernel32.Includes(type, GDI32.TrueTypeFontType) THEN
			F := SYSTEM.VAL(Font, data); font := SYSTEM.VAL(Win32.Font, F.ind);
			SYSTEM.MOVE(lpelf, SYSTEM.ADR(lf), SIZE(GDI32.ENUMLOGFONT));
			IF FileDir.SameName(font.family, lf.facename) THEN
				FontInstaller(lf, font);
				SYSTEM.MOVE(SYSTEM.ADR(lf), lpelf, SIZE(GDI32.ENUMLOGFONT));
				font.hfont := GDI32.CreateFontIndirect(lpelf);
				IF font.hfont # Kernel32.NULL THEN
					curType := GDI32.TrueTypeFontType; res := 0
				END
			END
		END;
		RETURN res
	END WinTTFontInstaller;

	PROCEDURE [stdcall] *WinRasterFontInstaller(lplf, lptm, type, data: LONGINT): LONGINT;
		VAR
			font: Win32.Font; F: Font;
			lf: GDI32.LOGFONT;
			res: LONGINT;
	BEGIN
		res := 1;
		F := SYSTEM.VAL(Font, data); font := SYSTEM.VAL(Win32.Font, F.ind);
		SYSTEM.MOVE(lplf, SYSTEM.ADR(lf), SIZE(GDI32.LOGFONT));
		IF FileDir.SameName(font.family, lf.facename) THEN
			FontInstaller(lf, font);
			SYSTEM.MOVE(SYSTEM.ADR(lf), lplf, SIZE(GDI32.LOGFONT));
			font.hfont := GDI32.CreateFontIndirect(lplf);
			IF font.hfont # Kernel32.NULL THEN
				curType := GDI32.RasterFontType; res := 0
			END
		END;
		RETURN res
	END WinRasterFontInstaller;

	PROCEDURE DisplayDC(): LONGINT;
		VAR driver: ARRAY 8 OF CHAR;
	BEGIN
		driver := "DISPLAY";
		RETURN GDI32.CreateDC(SYSTEM.ADR(driver), Kernel32.NULL, Kernel32.NULL, Kernel32.NULL)
	END DisplayDC;

	PROCEDURE WinLoadFont(F: Font; family: ARRAY OF CHAR; size: LONGINT; style: SET; class: ARRAY OF CHAR);
		VAR
			raster: Win32.Font;
			tm: GDI32.TEXTMETRIC;
			abc: RECORD a, b, c: LONGINT END;
			ret, oldFont, hDC, i: LONGINT;
	BEGIN
		i := 0;
		WHILE family[i] # 0X DO
			IF family[i] = "_" THEN family[i] := " " END;
			INC(i)
		END;
		raster := SYSTEM.VAL(Win32.Font, F.ind); raster.oberon := FALSE;
		COPY(family, raster.family); raster.size := size; raster.style := style;
		hDC := DisplayDC(); curUnit := GDI32.GetDeviceCaps(hDC, GDI32.LOGPIXELSY); curType := -1;
		ret := GDI32.EnumFontFamilies(hDC, SYSTEM.ADR(family), WinTTFontInstaller, SYSTEM.VAL(LONGINT, F));
		IF raster.hfont = Kernel32.NULL THEN
			COPY(family, raster.file); Strings.Append(raster.file, ".FON");
			ret := GDI32.AddFontResource(SYSTEM.ADR(raster.file));
			IF ret = 1 THEN
				(*ret := User32.SendMessage(User32.HWNDBroadcast, User32.WMFontChange, 0, 0);*)
				ret := GDI32.EnumFonts(hDC, Kernel32.NULL, WinRasterFontInstaller, SYSTEM.VAL(LONGINT, F))
			END
		END;
		IF (class[0] = "M") & (class[1] = "d") THEN F.type := metric ELSE F.type := font END;
		IF raster.hfont # Kernel32.NULL THEN
			oldFont := GDI32.SelectObject(hDC, raster.hfont);
			ret := GDI32.GetTextMetrics(hDC, SYSTEM.ADR(tm));
			F.height := SHORT(tm.height-tm.extLead);
			F.minX := MAX(INTEGER); F.maxX := MIN(INTEGER);
			F.minY := -SHORT(tm.descent); F.maxY := SHORT(tm.ascent);
			i := 0;
			WHILE i < 256 DO
				IF (i >= ORD(tm.firstCh)) & (i <= ORD(tm.lastCh)) THEN
					IF curType = GDI32.TrueTypeFontType THEN
						ret := GDI32.GetCharABCWidths(hDC, i, i, SYSTEM.ADR(abc))
					ELSE
						ret := GDI32.GetCharWidth32(hDC, i, i, SYSTEM.ADR(abc.b));
						abc.a := 0; abc.c := 0
					END
				ELSE
					abc.a := 0; abc.b := 0; abc.c := 0;
				END;
				raster.metrics[i].dx := SHORT(abc.a + abc.b + abc.c);
				IF raster.metrics[i].dx < F.minX THEN
					F.minX := raster.metrics[i].dx
				END;
				IF raster.metrics[i].dx > F.maxX THEN
					F.maxX := raster.metrics[i].dx
				END;
				raster.metrics[i].x := SHORT(abc.a);
				raster.metrics[i].y := -SHORT(tm.descent);
				raster.metrics[i].p.w := SHORT(abc.b);
				raster.metrics[i].p.h := SHORT(tm.height);
				raster.metrics[i].p.bitmap := Kernel32.NULL;
				INC(i)
			END;
			raster.metrics[9].dx := raster.metrics[32].dx * 4;
			raster.metrics[9].x := 0; raster.metrics[9].p.w := 0;
			ret := GDI32.SelectObject(hDC, oldFont)
		ELSE
			F.type := -2
		END;
		ret := GDI32.DeleteDC(hDC)
	END WinLoadFont;

	PROCEDURE [stdcall] *WinOberonRasterFontInstaller(lplf, lptm, type, data: LONGINT): LONGINT;
		VAR font: Win32.Font; F: Font;
	BEGIN
		F := SYSTEM.VAL(Font, data); font := SYSTEM.VAL(Win32.Font, F.ind);
		font.hfont := GDI32.CreateFontIndirect(lplf);
		curType := GDI32.RasterFontType;
		RETURN 0
	END WinOberonRasterFontInstaller;

	PROCEDURE WinOberonName(raster: Win32.Font; family: ARRAY OF CHAR; size: LONGINT; style: SET);
		VAR class: ARRAY 4 OF CHAR;
	BEGIN
		COPY(family, raster.file); raster.file[5] := 0X; class := "FON";
		BuildName(raster.file, raster.file, size, style, class);
		raster.file[Strings.Length(raster.file)-4] := 0X
	END WinOberonName;

	PROCEDURE WinOberonLoadFont(F: Font; family: ARRAY OF CHAR; size: LONGINT; style: SET);
		VAR
			raster: Win32.Font;
			ret, hDC: LONGINT;
	BEGIN
		raster := SYSTEM.VAL(Win32.Font, F.ind); raster.oberon := TRUE;
		COPY(family, raster.family); raster.size := size; raster.style := style;
		hDC := DisplayDC(); curUnit := GDI32.GetDeviceCaps(hDC, GDI32.LOGPIXELSY); curType := -1;
		WinOberonName(raster, family, size, style);
		ret := GDI32.AddFontResource(SYSTEM.ADR(raster.file));
		IF ret = 1 THEN
			(*ret := User32.SendMessage(User32.HWNDBroadcast, User32.WMFontChange, 0, 0);*)
			ret := GDI32.EnumFonts(hDC, SYSTEM.ADR(F.name), WinOberonRasterFontInstaller, SYSTEM.VAL(LONGINT, F))
		END;
		ret := GDI32.DeleteDC(hDC)
	END WinOberonLoadFont;

	PROCEDURE Substitute(F: Font);
	BEGIN
		F.type := substitute;
		F.height := Default.height;
		F.minX := Default.minX; F.maxX := Default.maxX;
		F.minY := Default.minY; F.maxY := Default.maxY;
		F.ind := Default.ind
	END Substitute;

	PROCEDURE Load(F: Font; VAR R: Files.Rider; type: SHORTINT);
		TYPE
			RunRec = RECORD beg, end: INTEGER END;
			BoxRec = RECORD dx, x, y, w, h: INTEGER END;
		VAR
			raster: Win32.Font;
			bitmap, bitmapX, bitmapDX, bitmapW, bitmapH, RasterBase: LONGINT;
			b, n, a, k, l, m, w, h: LONGINT;
			nofBoxes: LONGINT;
			nofRuns: INTEGER;
			ch: CHAR;
			run: ARRAY 16 OF RunRec;
			box: ARRAY 256 OF BoxRec;
		PROCEDURE DummyCh(m: LONGINT);
			VAR raster: Win32.Font;
		BEGIN
			raster := SYSTEM.VAL(Win32.Font, F.ind);
			raster.metrics[m].dx := 0;
			raster.metrics[m].x := 0; raster.metrics[m].y := 0;
			raster.metrics[m].p.x := 0; raster.metrics[m].p.y := 0;
			raster.metrics[m].p.w := 0; raster.metrics[m].p.h := 0
		END DummyCh;
	BEGIN
		F.type := type;
		Files.Read(R, ch); (*family*) Files.Read(R, ch); (*variant*)
		raster := SYSTEM.VAL(Win32.Font, F.ind); raster.oberon := TRUE;
		Files.ReadInt(R, F.height);
		Files.ReadInt(R, F.minX); Files.ReadInt(R, F.maxX);
		Files.ReadInt(R, F.minY); Files.ReadInt(R, F.maxY);
		Files.ReadInt(R, nofRuns);
		nofBoxes := 0; k := 0;
		WHILE k # nofRuns DO
			Files.ReadInt(R, run[k].beg); Files.ReadInt(R, run[k].end);
			nofBoxes := nofBoxes + run[k].end - run[k].beg;
			INC(k)
		END;
		IF F.type # metric THEN
			bitmapW := 0; l := 0;
			WHILE l # nofBoxes DO
				Files.ReadInt(R, box[l].dx);
				Files.ReadInt(R, box[l].x); Files.ReadInt(R, box[l].y);
				Files.ReadInt(R, box[l].w); Files.ReadInt(R, box[l].h);
				bitmapW := bitmapW + (box[l].w + 7) DIV 8;
				INC(l)
			END;
			bitmapW := bitmapW + (-bitmapW) MOD 4; bitmapH := F.maxY - F.minY;
			SYSTEM.NEW(SYSTEM.VAL(Font, RasterBase), bitmapW * bitmapH); (* temporary *)
			bitmapX := 0; k := 0; l := 0; m := 0;
			WHILE k < nofRuns DO
				WHILE m < run[k].beg DO DummyCh(m); INC(m) END;
				WHILE m < run[k].end DO
					raster.metrics[m].dx := box[l].dx;
					raster.metrics[m].x := box[l].x;
					raster.metrics[m].y := box[l].y;
					raster.metrics[m].p.x := bitmapX;
					raster.metrics[m].p.y := 0;
					w := box[l].w;
					raster.metrics[m].p.w := SHORT(w);
					h := box[l].h; raster.metrics[m].p.h := SHORT(h);
					bitmapDX := (w + 7) DIV 8;
					n := bitmapDX * h;
					a := RasterBase + bitmapX DIV 8;
					b := 0;
					WHILE b < n DO
						Files.Read(R, ch);
						SYSTEM.PUT(a + (h - 1 - (b DIV bitmapDX)) * bitmapW + (b MOD bitmapDX), GDI32.T[ORD(ch)]);
						INC(b)
					END;
					INC(l); INC(m);
					INC(bitmapX, 8*bitmapDX)
				END;
				INC(k)
			END;
			WHILE m < 256 DO DummyCh(m); INC(m) END;
			bitmap := GDI32.CreateBitmap(8*bitmapW, bitmapH, 1, 1, RasterBase);
			ASSERT(bitmap # Kernel32.NULL);
			m := 0;
			WHILE m < 256 DO raster.metrics[m].p.bitmap := bitmap; INC(m) END
		ELSE (* metric *)
			l := 0;
			WHILE l # nofBoxes DO
				Files.ReadInt(R, box[l].dx);
				Files.ReadInt(R, box[l].x); Files.ReadInt(R, box[l].y);
				Files.ReadInt(R, box[l].w); Files.ReadInt(R, box[l].h);
				INC(l)
			END;
			k := 0; l := 0; m := 0;
			WHILE k < nofRuns DO
				WHILE m < run[k].beg DO DummyCh(m); INC(m) END;
				WHILE m < run[k].end DO
					raster.metrics[m].dx := box[l].dx;
					raster.metrics[m].x := box[l].x;
					raster.metrics[m].y := box[l].y;
					raster.metrics[m].p.x := 0;
					raster.metrics[m].p.y := 0;
					INC(l); INC(m)
				END;
				INC(k)
			END;
			WHILE m < 256 DO DummyCh(m); INC(m) END;
			m := 0;
			WHILE m < 256 DO raster.metrics[m].p.bitmap := Kernel32.NULL; INC(m) END
		END
	END Load;

	PROCEDURE *Finalize(F: PTR);
		VAR f0: Win32.Font; ret, bitmap: LONGINT;
	BEGIN
		WITH F: Font DO
			f0 := SYSTEM.VAL(Win32.Font, F.ind);
			bitmap := f0.metrics[65].p.bitmap;
			IF bitmap # Kernel32.NULL THEN
				ret := GDI32.DeleteObject(bitmap);
				f0.metrics[65].p.bitmap := Kernel32.NULL
			END;
			IF f0.hfont # Kernel32.NULL THEN
				ret := GDI32.DeleteObject(f0.hfont);
				f0.hfont := Kernel32.NULL
			END;
			IF f0.file # "" THEN
				ret := GDI32.RemoveFontResource(SYSTEM.ADR(f0.file));
				f0.file := ""
			END
		END
	END Finalize;

	PROCEDURE *Open(F: Objects.Library);
		VAR
			file, tmp: FileDir.FileName;
			family: ARRAY 64 OF CHAR;
			class: ARRAY 8 OF CHAR;
			raster: Win32.Font;
			size: LONGINT;
			style: SET;
			f: Files.File;
			R: Files.Rider;
			id: CHAR;
	BEGIN
		WITH F: Font DO
			NEW(raster); F.ind := SYSTEM.VAL(Objects.Index, raster);
			raster.hfont := Kernel32.NULL; raster.file := "";
			ParseName(F.name, family, size, style, class);
			IF family = "Default" THEN
				COPY(default, family);
				BuildName(file, default, size, style, class)
			ELSE
				BuildName(file, family, size, style, class)
			END;
			Registry.OberonPath("Fonts", tmp);
			Registry.GetKeyValue(Registry.CurrentUser, tmp, family, tmp);
			IF Registry.res = Registry.Done THEN
				COPY(tmp, family);
				BuildName(file, family, size, style, class)
			END;
			IF ((class[0] = "M") & (class[1] = "d")) OR ((class[0] = "P") & (class[1] = "r")) THEN
				Substitute(F);
				RETURN
			END;
			f := Files.Old(file);
			IF f # NIL THEN
				Files.Set(R, f, 0); Files.Read(R, id);
				IF id = FontId THEN
					WinOberonLoadFont(F, family, size, style);
					Files.Read(R, F.type);
					IF F.type = metric THEN Load(F, R, F.type)
					ELSIF F.type = font THEN Load(F, R, F.type)
					ELSE Substitute(F)
					END
				ELSE Substitute(F)
				END
			ELSE
				WinLoadFont(F, family, size, style, class);
				IF F.type = -2 THEN
					Substitute(F)
				END
			END;
			IF F.type # substitute THEN
				Kernel.RegisterObject(F, Finalize, FALSE)
			END
		END
	END Open;

	PROCEDURE *GetCharObj(L: Objects.Library; ref: INTEGER; VAR obj: Objects.Object);
		VAR
			F: Win32.Font;
			p: Display.Pattern;
			m: LONGINT;
			h1: INTEGER;
			ch: CHAR;
	BEGIN
		F := SYSTEM.VAL(Win32.Font, L.ind); ch := CHR(ref);
		IF ~F.oberon THEN ch := Strings.OberonToISO[ORD(ch)] END;
		Win32.cc.font := F; Win32.cc.ch := ch;
		m := SYSTEM.VAL(LONGINT, L.ind) + ORD(ch)*SIZE(Win32.MetricDesc);
		p := m + 8; Win32.cc.pat := p; theChar.pat := p;
		SYSTEM.GET(m, h1); theChar.dx := h1; Win32.cc.dx := h1; INC(m, 2);
		SYSTEM.GET(m, h1); theChar.x := h1; Win32.cc.x := h1; INC(m, 2);
		SYSTEM.GET(m, h1); theChar.y := h1; Win32.cc.y := h1; INC(m, 12); (* y+filler+p.x+p.y *)
		SYSTEM.GET(m, theChar.w); INC(m, 2);
		SYSTEM.GET(m, theChar.h);
		obj := theChar
	END GetCharObj;

	(** Return the character and data of ch in a font. *)
	PROCEDURE GetChar*(F: Font; ch: CHAR; VAR dx, x, y, w, h: INTEGER; VAR pat: Display.Pattern);
		VAR obj: Objects.Object;
	BEGIN
		F.GetObj(F, ORD(ch), obj);
		WITH obj: Char DO
			dx := obj.dx; x := obj.x; y := obj.y; w := obj.w; h := obj.h; pat := obj.pat
		END
	END GetChar;

	PROCEDURE *New(): Objects.Library;
		VAR F: Font;
	BEGIN
		NEW(F);
		F.Load := Open; F.GetObj := GetCharObj;
		RETURN F
	END New;

	(** Load and cache a font. *)
	PROCEDURE This*(name: ARRAY OF CHAR): Font;
		VAR L: Objects.Library;
	BEGIN
		L := Objects.ThisLibrary(name);
		IF (L # NIL) & (L IS Font) THEN RETURN L(Font) ELSE RETURN NIL END
	END This;

	PROCEDURE Init();
		VAR
			class: FileDir.FileName;
			style: SET;
			size: LONGINT;
	BEGIN
		Registry.GetKeyValue(Registry.CurrentUser, Registry.oberonSystem, "DefaultFont", default);
		IF Registry.res = Registry.Done THEN
			Default := This(default)
		ELSE
			Default := NIL
		END;
		IF Default = NIL THEN
			Default := This(DefFontName); COPY(DefFontName, default);
			Registry.SetKeyValue(Registry.CurrentUser, Registry.oberonSystem, "DefaultFont", DefFontName)
		END;
		ASSERT(Default # NIL);
		ParseName(default, default, size, style, class)
	END Init;

BEGIN
	FontId := 0DBX; NEW(theChar);
	Objects.Register("Scn.Fnt", New);
	Init()
END Fonts.

(** Remarks:

1. Screen fonts and printer fonts are stored in files with extensions .Scn.Fnt and .Prx.Fnt respectively (the x refers to x00dpi printer fonts). A full font name (like Syntax12b.Scn.Fnt) has to be specified to load a font. Should the font not be available, a substitute font is created. This has the same name but the wrong character metrics (often the Syntax10 font is used instead). A file with an .Mdx.Fnt extension is a metric font containing only metric data and no raster patterns. Each printer font has an associated metric font. A metric font is used to make measurements while printing. Sometimes the font module is clever enough to simulate the presence of a metric font by reading the metric data from a printer font (the metric fonts need not necessarily be available). If you need to find out the size of a character on paper, you should always request a metric font (it is faster to load and requires less memory than the printer fonts). Some Font modules support Truetype fonts implemented in the host operating system.

2. Fonts are extensions of Libraries. Each letter of the font is a (virtual) object indexed by ASCII code. Note that to optimize garbage collection, the same object instance is returned for each call to the GetObj library method (no matter what font or character is involved). This is realized by copying the character raster and metrics from a specially compressed representation of the font data. The GetChar procedure fetches a character from the font using this mechanism. The PutObj, GenRef and Store methods of fonts have no function.

3. The pattern (raster) of a character is only as large as required. The x, y, w, h values of a character metric specify the offset of the pattern from a virtual text baseline and the width and height of the pattern. Display.CopyPattern is used to draw the character patterns of the display. Help procedures like Display3.String hides the low-level display process and allows you to display strings at a time.

4. The default font is Syntax10.Scn.Fnt. You may influence the default font by adding a DefaultFont entry to the System section of the Registry. Oberon allows you to influence the fonts loaded by specifying remapping of font families and sizes in the Registry (check the User Guide for more details).
*)
