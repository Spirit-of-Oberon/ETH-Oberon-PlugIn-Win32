(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE OOPU; (** non-portable / source: Win32.OOPU.Mod *)	(* partial compilation, symbolfile parser tk  *)

	(* ExportLists are never freed again! *)

	IMPORT	
		SYS:=SYSTEM, Modules, Files, Oberon, OPM:=OOPM, OPS:=OOPS, OPT:=OOPT, OPV:=OOPV, Compiler, Texts;

	CONST
		(*visibility*)	internal=0; external=1;
		(*object modes*)	Var=1; Con=3; Fld=4; Typ=5; XProc=7; Anchor=14; Removed=15;
		(*structure forms*)	Pointer=13; Comp=15; Record=4;
		(*export table*)	EUEnd = 0; EURecord = 1; EUobjScope = 0; EUrecScope = 1;  EUerrScope = -1;
		(*mod types*)	MC68* = 0; PPC* = 1; Intel* = 2; Portable* = 3; Loaded* = 4; 
		(*modes*)	browse=0; check=1; checkDeep=2; showImps=3; showExps=4;

	TYPE
		ModuleName = ARRAY 32 OF CHAR;
		Module*= POINTER TO ModDesc;
		ModDesc*= RECORD
			link*: Module; 
			name*: ModuleName; 
			export*: Modules.ExportDesc;
			scope*, syms*, publics*: OPT.Object;
			res*: INTEGER; type*: SHORTINT; mark*: BOOLEAN;
		END;
		Handler* = PROCEDURE (name: ARRAY OF CHAR; scope: OPT.Object);

	VAR
		modList*, theMod*: Module; mode: INTEGER;
		res: INTEGER; show: Handler; impMod: OPS.Name; incr: BOOLEAN;
		Source: Texts.Reader; Null: Texts.Text; useName, dum: OPS.Name;
		nofmod: SHORTINT; mods: ARRAY 64 OF OPT.Module;
		
	PROCEDURE ReadString*(VAR R: Files.Rider; VAR string: ARRAY OF CHAR);
		VAR i: INTEGER; ch: CHAR;
	BEGIN i := 0;
		LOOP Files.Read(R, ch);
			IF ch = 0X THEN string[i] := 0X; RETURN
			ELSIF ch > 7FX THEN string[i] := CHR(ORD(ch)-80H); string[i+1] := 0X; RETURN
			ELSE string[i] := ch; INC(i) END
		END
	END ReadString;

	PROCEDURE ReadUnsigned (VAR R: Files.Rider; VAR u: LONGINT);
		(* read unsigned, 16 bit, little endian value *)
		VAR low, high: CHAR;
	BEGIN
		Files.Read(R, low); Files.Read(R, high);
		u := 256*LONG(ORD(high)) + ORD(low);
	END ReadUnsigned;

	(* ----- additional symbols ----- *)

	PROCEDURE InsertObj(obj: OPT.Object; VAR scope: OPT.Object);
	BEGIN
		IF scope=NIL THEN scope:=obj
		ELSIF obj.name<scope.name THEN InsertObj(obj, scope.left)
		ELSIF obj.name>scope.name THEN InsertObj(obj, scope.right)
		END; 
	END InsertObj;

	PROCEDURE OldObj(VAR name, modname: ARRAY OF CHAR; obj: OPT.Object): OPT.Object;
		VAR mod: OPT.Object;
	BEGIN
		LOOP
			IF obj=NIL THEN EXIT END;
			IF name < obj.name THEN obj:=obj.left
			ELSIF name > obj.name THEN obj:=obj.right
			ELSE obj.used:=TRUE; 
				NEW(mod); COPY(modname, mod.name); 
				mod.sibling:=obj.sibling; obj.sibling:=mod; EXIT
			END;
		END;
		RETURN obj;
	END OldObj;

	PROCEDURE OldField(VAR name, modname: ARRAY OF CHAR; typ: OPT.Struct): OPT.Object;
		VAR fld, mod: OPT.Object;
	BEGIN
		fld:=typ.link; WHILE (fld#NIL) & (fld.name#name) DO fld:=fld.link END;
		IF fld#NIL THEN fld.used:=TRUE; NEW(mod); COPY(modname, mod.name); 
			mod.sibling:=fld.sibling; fld.sibling:=mod
		END;
		RETURN fld;
	END OldField;

	PROCEDURE InsertField(name: ARRAY OF CHAR; typ: OPT.Struct);
		VAR fld: OPT.Object;
	BEGIN	NEW(fld); fld.vis:=external; fld.mode:=Fld; COPY(name, fld.name); fld.typ:=OPT.notyp; fld.link:=typ.link; typ.link:=fld;
	END InsertField;

	PROCEDURE ^ LoadSym(mod: Module);
	PROCEDURE ^ ThisMod(name: ARRAY OF CHAR): Module;


	(* ----- loading export block for portable and native modules ----- *)

	PROCEDURE BuildExpBlock(VAR M: Module; obj: OPT.Object);
		VAR nofObj, nofOref: INTEGER; typ: OPT.Struct; 
			orefs: ARRAY 1024 OF Modules.ExportPtr; 

		PROCEDURE ExportRecord(typ: OPT.Struct; VAR scope: Modules.ExportDesc);
			VAR nofFld: INTEGER; fld: OPT.Object; old: Modules.ExportPtr;
		BEGIN
			IF typ.mno=1 THEN 
				IF typ.oref#0 THEN old:=orefs[typ.oref]; 
					scope.nofExp:=old.nofExp; scope.dsc:=old.dsc; 
				ELSE 
					nofFld:=2; fld:=typ.link; WHILE fld#NIL DO
						IF fld.vis#internal THEN INC(nofFld) END;
						fld:=fld.link;
					END;
					scope.nofExp:=nofFld; 
					IF nofFld <= 0 THEN RETURN END;
					NEW(scope.dsc, nofFld); nofFld:=2;
					OPT.FPrintTyp(typ); INC(nofOref); orefs[nofOref]:=SYS.VAL(Modules.ExportPtr, SYS.ADR(scope)); typ.oref:=nofOref;
					IF (typ.BaseTyp#NIL) & (typ.mno=1) THEN ExportRecord(typ.BaseTyp, scope.dsc[0]) END;
					scope.dsc[0].fp:=typ.pbfp; scope.dsc[0].adr:=0; 
					scope.dsc[1].fp:=typ.pvfp;  
					fld:=typ.link; WHILE fld#NIL DO
						IF fld.vis#internal THEN
							scope.dsc[nofFld].fp:=fld.fp; typ:=fld.typ;
							WHILE (typ#NIL) & ((typ.form=Comp) & (typ.comp#Record) OR (typ.form=Pointer)) DO typ:=typ.BaseTyp END;
							IF (typ#NIL) & (typ.form=Comp) & (typ.comp=Record) THEN ExportRecord(typ, scope.dsc[nofFld]) END; 
							INC(nofFld);
						END;
						fld:=fld.link;
					END;	
				END
			END;
		END ExportRecord;

		PROCEDURE FPrint(obj: OPT.Object);
		BEGIN	
			IF	obj#NIL	THEN
				FPrint(obj.left); 
				IF obj.vis#internal THEN OPT.FPrintObj(obj); INC(nofObj) END; 
				FPrint(obj.right);
			END
		END FPrint;

		PROCEDURE BuildExpObj(obj: OPT.Object);
		BEGIN
			IF	obj#NIL	THEN
				BuildExpObj(obj.left);
				IF obj.vis#internal THEN 
					M.export.dsc[nofObj].fp:=obj.fp; 
					IF obj.mode=Var THEN M.export.dsc[nofObj].adr:=0
					ELSIF obj.mode=XProc THEN M.export.dsc[nofObj].adr:=0
					ELSE M.export.dsc[nofObj].adr:=0 END;
					IF (obj.mode=Typ) OR (obj.mode=Var) THEN typ:=obj.typ;
						WHILE (typ#NIL) & ((typ.form=Comp) & (typ.comp#Record) OR (typ.form=Pointer)) DO typ:=typ.BaseTyp END;
						IF (typ#NIL) & (typ.form=Comp) & (typ.comp=Record) THEN ExportRecord(typ, M.export.dsc[nofObj]) END;
					END;
					INC(nofObj);
				END;
				BuildExpObj(obj.right);
			END
		END BuildExpObj;

	BEGIN nofObj:=0; nofOref:=0; 
		FPrint(obj);
		IF nofObj > 0 THEN NEW(M.export.dsc, nofObj) END;
		M.export.nofExp:=nofObj; nofObj:=0; 
		BuildExpObj(obj);
	END BuildExpBlock;

	PROCEDURE LoadExpBlock(VAR R: Files.Rider; M: Module);
		VAR struct: ARRAY 1024 OF Modules.ExportPtr; nofStr: INTEGER;

		PROCEDURE LoadScope(VAR scope: Modules.ExportDesc; level: INTEGER; adr: LONGINT);
			VAR no, no2: INTEGER; fp, off: LONGINT; 
		BEGIN
			Files.ReadBytes(R, scope.nofExp, 2); no:=0; no2:=0; 
			IF scope.nofExp > 0 THEN NEW(scope.dsc, scope.nofExp) END;
			IF level=EUrecScope THEN INC(nofStr); struct[nofStr]:=SYS.VAL(Modules.ExportPtr, SYS.ADR(scope)) END;
			Files.ReadNum(R, fp);
			WHILE fp#EUEnd DO
				IF fp=EURecord THEN Files.ReadNum(R, off);
					IF off<0 THEN scope.dsc[no2].nofExp:=struct[-off].nofExp; 
						scope.dsc[no2].dsc:=struct[-off].dsc; 	(* old type *)
					ELSE LoadScope(scope.dsc[no2], EUrecScope, off) END;
				ELSE IF level=EUobjScope THEN Files.ReadNum(R, adr) END;
					scope.dsc[no].fp:=fp; no2:=no; INC(no)
				END;
				Files.ReadNum(R, fp)
			END
		END LoadScope;
	
	BEGIN nofStr:=0; LoadScope(M.export, EUobjScope, 0)
	END LoadExpBlock;


	(* ----- consistency checking ----- *)

	PROCEDURE CheckUseBlock(VAR R: Files.Rider; M: Module; portable: BOOLEAN);
		VAR mod: Module; name: ModuleName; modname: OPS.Name; obj0: OPT.Object; res0, i: INTEGER; decorate: BOOLEAN;

		PROCEDURE CheckScope(scope: Modules.ExportDesc; level: INTEGER; typ: OPT.Struct);
			VAR fp, link, i: LONGINT; tmpErr: BOOLEAN;  
				typ2: OPT.Struct; obj: OPT.Object;
		BEGIN	tmpErr:=(level=EUerrScope);
			i:=0;
			IF scope.dsc = NIL THEN res:=32; RETURN END;
			Files.ReadNum(R, fp); i:=-1;
			WHILE fp # EUEnd DO
				IF fp = EURecord THEN IF ~portable THEN Files.ReadNum(R, link) END;
					IF i=-1 THEN i:=0; IF decorate THEN typ2:=typ.BaseTyp END END;
					IF tmpErr THEN CheckScope(scope.dsc[i], EUerrScope, typ2)
					ELSE CheckScope(scope.dsc[i], EUrecScope, typ2);
					END;
				ELSE ReadString(R, name);
					IF level>=EUobjScope THEN tmpErr:=FALSE;
						IF level=EUobjScope THEN 
							IF ~portable THEN Files.ReadNum(R, link) END;
							IF decorate THEN
								obj:=OldObj(name, M.name, mod.syms);
								IF obj=NIL THEN NEW(obj); COPY(name, obj.name); obj.vis:=external; obj.mode:=Removed END;
								NEW(obj0); obj0.mode:=Anchor; obj0.name:=obj.name; 
								obj0.link:=obj; InsertObj(obj0, M.scope);
							END;
						ELSIF (level>EUobjScope) THEN
							IF decorate THEN
								IF name="@" THEN name:="public/private"; obj:=OldField(name, M.name, typ);
									IF obj=NIL	THEN	InsertField(name, typ)	END
								END;
								IF typ#NIL THEN obj:=OldField(name, M.name, typ) END; 
								IF obj=NIL THEN 
									NEW(obj); COPY(name, obj.name); obj.vis:=external; obj.mode:=Removed;
									NEW(obj0); obj0.mode:=Anchor; obj0.name:=obj.name;
									obj0.link:=obj; InsertObj(obj0, M.scope);
								ELSE	obj0:=obj.sibling	END;
							END;
						END;
						IF decorate & (obj#NIL) THEN typ2:=obj.typ END;
						i:=0; WHILE (i<scope.nofExp) & (scope.dsc[i].fp#fp) DO INC(i) END;
						IF i>=scope.nofExp THEN res:=32; tmpErr:=TRUE;  
							IF decorate & (obj0#NIL) THEN obj0.vis:=-1; obj0.fp:=fp   (* inconsistent *) END
						END
					END;
					IF decorate & (obj#NIL) & (obj.mode#Removed) & ((obj.mode#XProc) & (obj.mode#Con) OR (level=EUrecScope)) THEN
						WHILE (typ2#NIL) & ((typ2.form=Comp) & (typ2.comp#Record) OR (typ2.form=Pointer)) DO
							typ2:=typ2.BaseTyp
						END;
					END;
				END;
				Files.ReadNum(R, fp); 
			END;
		END CheckScope;

	BEGIN	
		IF	(M.name#impMod) & (mode IN {showImps})	THEN	RETURN	END;
		ReadString(R, modname); res0:=res;
		WHILE	(modname#"") & ((res=0) OR (mode IN {showImps}))	DO
			mod:=ThisMod(modname);
			IF	mode IN {showImps}	THEN	
				IF	incr	THEN
					OPT.Import(modname, modname, dum); 
					i:=0; WHILE (i<OPT.nofmod) & (OPT.modules[i].name#modname) DO INC(i) END;
					mod.syms:=OPT.modules[i].right; mod.publics:=OPT.modules[i].publics;
					OPV.AssignEntries(mod.publics, TRUE);
				ELSE	
					OPM.Init({}, Source, Null); OPS.Init; OPT.Init(dum, {});
					OPT.OpenScope(0, NIL); 
					OPT.Import(modname, modname, dum); 
					mod.syms:=OPT.modules[1].right; mod.publics:=OPT.modules[1].publics; 
					OPV.AssignEntries(mod.publics, TRUE);
					incr:=TRUE;
				END;
			END;
			decorate:=(mode IN {showImps}) OR (mode IN {showExps}) & (useName=modname);
			IF	(res=0) OR decorate	THEN 
				IF	decorate OR (mode IN {check, checkDeep, showExps})	THEN	CheckScope(mod.export, EUobjScope, NIL)	END;
				IF	mode IN {showImps}	THEN	show(modname, M.scope); M.syms:=NIL; M.publics:=NIL; M.scope:=NIL	END;	
				IF	res#0	THEN	res0:=res	END;
			END;
			ReadString(R, modname);
		END;
		(* IF	decorate	THEN	OPT.CloseScope	END; *)
		res:=res0;
	END CheckUseBlock;


	(* ----- decorating symbolfile ----- *)

	PROCEDURE LoadSym(mod: Module);
		VAR dname: OPS.Name;
	BEGIN	
		IF	mod.syms=NIL	THEN	
			IF	incr	THEN	OPT.Close; incr:=FALSE	END;
			OPM.Init({}, Source, Null); OPS.Init; OPT.Init(dum, {});
			OPT.OpenScope(0, NIL); COPY(mod.name, dname);
			OPT.Import(dname, dname, dum); OPT.CloseScope;
			mod.syms:=OPT.modules[1].right; mod.publics:=OPT.modules[1].publics; 
			OPV.AssignEntries(mod.publics, TRUE);
		END
	END LoadSym;


	(* ----- pseudo-loading for portable modules ----- *)

	PROCEDURE LoadPortable(VAR R: Files.Rider; VAR M: Module);
		VAR symSize, lint: LONGINT;
	BEGIN	
		Files.ReadNum(R, symSize); Files.Set(R, Files.Base(R), Files.Pos(R) + symSize); 
		Files.ReadNum(R, symSize); Files.ReadNum(R, lint); Files.ReadNum(R, lint);
		Files.Set(R, Files.Base(R), Files.Pos(R) + symSize);

		CheckUseBlock(R, M, TRUE);
		Files.Close(Files.Base(R)); 
		IF	res=0	THEN	
			LoadSym(M); OPT.modNo:=1; BuildExpBlock(M, M.syms); M.syms:=NIL; M.publics:=NIL; OPT.Close; Oberon.Collect; 
		END;
	END LoadPortable;


	(* ----- pseudo-loading for native modules ----- *)


	PROCEDURE ThisMod(name: ARRAY OF CHAR): Module;
		VAR mod: Module; F: Files.File; R: Files.Rider; found: BOOLEAN; ch0, ch1: CHAR; i: INTEGER; 
			codeSize, lint: LONGINT; int, nofEntries, conSize, nofPtrs, nofImps, nofDataLinks, nofLinks, nofCmds: INTEGER;
			iname: ModuleName;  
	BEGIN
		mod:=modList; res:=0; 
		WHILE (mod#NIL) & (name#mod.name) DO mod:=mod.link END;
		IF	mod=NIL	THEN	found:=FALSE; i:=0; ch0:=name[0];
			WHILE	(ch0#0X) & (i < 28)	DO	iname[i]:=ch0; INC(i); ch0:=name[i]	END;
			IF	i < 28	THEN	iname[i]:="."; iname[i+1]:="O"; iname[i+2]:="b"; iname[i+3]:="j"; iname[i+4]:=0X;
				F := Files.Old(iname); Files.Set(R, F, 0); found := F # NIL;
			END;
			IF	found	THEN	Files.Read(R, ch0); Files.Read(R, ch1);
				IF	ch0=0BBX	THEN	NEW(mod); theMod:=mod;
					IF	mode IN {checkDeep}	THEN	theMod.mark:=TRUE	END;
					COPY(name, mod.name);
					IF	mode IN {check, checkDeep, showImps, showExps}	THEN

						IF	ch1=55X	THEN	mod.type:=Intel;
							Files.ReadNum(R, lint); Files.Set(R, F, Files.Pos(R) + lint);	(* sym-file *)
							Files.ReadLInt(R, lint); 
							Files.ReadInt(R, nofEntries); 
							Files.ReadInt(R, nofCmds); 
							Files.ReadInt(R, nofPtrs); 
							Files.ReadInt(R, int); 
							Files.ReadInt(R, nofImps); 
							Files.ReadInt(R, nofDataLinks); 
							Files.ReadInt(R, nofLinks); 
							Files.ReadLInt(R, lint);
							Files.ReadInt(R, conSize); 
							ReadUnsigned(R, codeSize); 
							ReadString(R, name);
			
							(* Entry Block *)
							Files.Read(R, ch0); ASSERT(ch0=82X);
							Files.Set(R, F, Files.Pos(R) +  nofEntries*2); 
							
							(* Cmd Block *)
							Files.Read(R, ch0); ASSERT(ch0=83X);
							i:=0; WHILE i < nofCmds DO ReadString(R, name); Files.ReadInt(R, int); INC(i) END;

							(* Ptr Block *)
							Files.Read(R, ch0); ASSERT(ch0=84X);
							Files.Set(R, F, Files.Pos(R) +  nofPtrs*4);
							
							(* Import Block *)
							Files.Read(R, ch0); ASSERT(ch0=85X);
							i:=0; WHILE i < nofImps DO ReadString(R, name); INC(i) END;
							
							(* Data Link Block *)
							Files.Read(R, ch0); ASSERT(ch0=8DX);
							i := 0; WHILE i < nofDataLinks DO
								Files.Read(R, ch0);
								Files.ReadInt(R, int); Files.ReadInt(R, int);
								WHILE int > 0 DO ReadUnsigned(R, lint); DEC(int) END;
								INC(i)
							END;
							
							(* Link Block *)
							Files.Read(R, ch0); ASSERT(ch0=86X); 
							Files.Set(R, F, Files.Pos(R) + nofLinks*4);
							
							(* Const Block *)
							Files.Read(R, ch0); ASSERT(ch0=87X);
							Files.Set(R, F, Files.Pos(R) + conSize);
							
							(* Export Block *)
							Files.Read(R, ch0); ASSERT(ch0=88X);
							LoadExpBlock(R, mod);
							
							(* Code Block *)
							Files.Read(R, ch0); ASSERT(ch0=89X);
							Files.Set(R, F, Files.Pos(R) + codeSize);
							
							(* Use Block *)
							Files.Read(R, ch0); ASSERT(ch0=8AX);
							CheckUseBlock(R, mod, FALSE);
							
							Files.Close(F); 

						ELSIF	ch1=88X	THEN	mod.type:=Portable; LoadPortable(R, mod)
						ELSE	Files.Close(F); res:=-1; mod:=NIL	END;
					END;
					mod.link:=modList; modList:=mod; mod.res:=res;
				ELSE	res:=-1; mod:=NIL;	END
			ELSE	(* try to load from loaded modules (Bootfile) *)
				mod := NIL; res := -1;
(*
				mmod:=Modules.modList;
				WHILE	(mmod#NIL) & (mmod.name#name)	DO	mmod:=mmod.link	END;
				IF mmod#NIL THEN
					NEW(mod); theMod:=mod; COPY(name, mod.name); mod.res:=0; mod.type:=Loaded;
					IF	mode IN {checkDeep}	THEN	mod.mark:=TRUE	END;
					mod.link:=modList; modList:=mod;
					IF	mode IN {check, checkDeep, showImps, showExps}	THEN
						mod.export:=mmod.export; 
						(* lint:=mmod.imodTab;
						WHILE	lint < mmod.entryTab	DO	SYS.GET(lint, imp); import:=ThisMod(imp.name); INC(lint, 4)	END;
						*)
						lint:=mmod.imports;
						WHILE	lint < mmod.imports+4*mmod.nofImps	DO	SYS.GET(lint, imp); import:=ThisMod(imp.name); INC(lint, 4)	END;
					END;
				ELSE	mod:=NIL; res:=-1	END;
*)
			END
		END;
		RETURN mod
	END ThisMod;


	(* ----- watson and browser interface ----- *)

	PROCEDURE DecorateDef*(name: ARRAY OF CHAR): Module;
		VAR m: Module;
	BEGIN	modList:=NIL; theMod:=NIL; OPT.Close; 
		mode:=browse; m:=ThisMod(name);
		IF	m#NIL	THEN	LoadSym(m)	END;
		RETURN m
	END DecorateDef;

	PROCEDURE DecorateImp*(name: ARRAY OF CHAR; proc: Handler): Module;
		VAR m: Module;
	BEGIN	modList:=NIL; theMod:=NIL; OPT.Close;
		incr:=FALSE; COPY(name, impMod); mode:=showImps; show:=proc; m:=ThisMod(name);
		IF	incr	THEN	OPT.CloseScope	END;
		RETURN m
	END DecorateImp;

	PROCEDURE CheckMod*(name: ARRAY OF CHAR; deep: BOOLEAN): Module;
		VAR m: Module;
	BEGIN	IF	deep	THEN	mode:=checkDeep	ELSE	mode:=check	END;
		m:=ThisMod(name); 
		IF	~deep & (m#NIL)	THEN	m.mark:=TRUE	END;
		RETURN m
	END CheckMod;

	PROCEDURE DecorateExpInit*(name: ARRAY OF CHAR): Module;
		VAR m: Module;
	BEGIN	modList:=NIL; theMod:=NIL; OPT.Close;
		COPY(name, useName); incr:=FALSE; mode:=showExps; 
		m:=ThisMod(name); 
		IF	m#NIL	THEN	LoadSym(m)	END;
		nofmod:=0; WHILE nofmod<OPT.nofmod DO mods[nofmod]:=OPT.modules[nofmod]; INC(nofmod) END;
		RETURN m;
	END DecorateExpInit;

	PROCEDURE DecorateExpMod*(name: ARRAY OF CHAR);
		VAR m: Module;
	BEGIN	incr:=FALSE; mode:=showExps; m:=ThisMod(name)
	END DecorateExpMod;

	PROCEDURE DecorateExpDone*;
	BEGIN	OPT.nofmod:=nofmod; WHILE nofmod>=0 DO OPT.modules[nofmod]:=mods[nofmod]; mods[nofmod]:=NIL; DEC(nofmod) END
	END DecorateExpDone;
	

	(* ----- compiler interface ----- *)

	PROCEDURE Actualize(name: ARRAY OF CHAR; log: Texts.Text): BOOLEAN;
		VAR W: Texts.Writer; mod: Module; 
	BEGIN	Texts.OpenWriter(W); mode:=check; mod:=ThisMod(name);
		IF (mod#NIL) & (mod.res=0) THEN Texts.WriteString(W, " is up to date"); Texts.WriteLn(W); Texts.Append(log, W.buf) END;
		RETURN (mod=NIL) OR (mod.res#0);
	END Actualize;

	PROCEDURE Collect*;
	BEGIN modList:=NIL; theMod:=NIL; OPT.Close; Oberon.Collect;
	END Collect;

BEGIN	Compiler.make.Actualize:=Actualize; Compiler.make.Init:=Collect;
	NEW(Null); Texts.Open(Null, ""); Texts.OpenReader(Source, Null, 0); dum:="$$"; 
END OOPU.