(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Interchange; (** non-portable / source: Win32.Interchange.Mod *)	(*mf 11.11.94 / od Jan 95 / tk  *)

	IMPORT SYS := SYSTEM, Kernel, Modules, Files, PLT := OPLT, PLO := OPLO, PLL := OPLL, PLC := OPLC, PLV := OPLV;

	CONST
		Var = 1; Con = 4; XProc = 7; TypDynArr = 8;
		TypArray = 9; TypPointer = 10; TypRecord = 11; TypProcTyp = 12;
		
		Local=FALSE; Global=TRUE;

		(*	inxchk = 0; ovflchk = 1; ranchk = 2; typchk = 3; ptrinit = 5;	*)

		DefMaxImport = 64; DefMaxStruct = 32; DefMaxReimp = 32;

	VAR
		first: BOOLEAN; theMod: Modules.Module;
		(*	verbose: BOOLEAN;
		verboseHook*: PROCEDURE (M: Modules.Module);
		options: SET;	*)

	PROCEDURE^ Import(VAR R: Files.Rider; M: Modules.Module);

	PROCEDURE BuildSym(VAR R: Files.Rider; M: Modules.Module);
		VAR nofEntries, adr, nofRecs, s: LONGINT;
			mod: Modules.Module; obj: PLT.Object;
	BEGIN	Import(R, M);
		IF Modules.res = 0 THEN	M.nofstrc := 1; obj := NIL;
			mod := Modules.modList; WHILE mod # NIL DO mod.nofreimp := 0; mod := mod.link END;
			PLT.ReadScope(R, M, 0, obj, Global); M.publics := SYS.VAL(LONGINT, obj);			
			nofEntries := 1; adr := 0; nofRecs := 0;
			WHILE obj # NIL DO
				CASE obj.mode OF
					| Var: PLL.TypSize(obj.typ); s := obj.typ.size; PLL.AlignVar(adr, s); PLL.AllocVar(adr, obj.linkadr, s); 
						obj.linkadr := obj.linkadr + M.sb;
					| XProc: IF nofEntries >= M.nofEntries THEN
								M.publics := 0;
								Modules.ErrMsg(16 (*Modules.incompImport*), M.name);
								RETURN
							END;
							obj.linkadr := M.entries[nofEntries];
							INC(nofEntries); IF nofEntries > 127 THEN HALT(33) END;
							obj.adr := 0; PLL.ParamAdr(obj);
					| TypRecord: IF nofRecs >= M.nofTds THEN
								M.publics := 0;
								Modules.ErrMsg(16 (*Modules.incompImport*), M.name);
								RETURN
							END;
							PLL.TypSize(obj.typ); obj.typ.tdadr := M.tdescs[nofRecs]; INC(nofRecs); obj.linkadr := -1;
					| TypDynArr, TypArray, TypPointer, TypProcTyp: PLL.TypSize(obj.typ); obj.linkadr := -1;
					| Con:
				ELSE
				END;
				obj:=obj.nxtobj
			END;
		END;
	END BuildSym;

	(*append object list to module descriptor*)
	PROCEDURE Decorate*(M: Modules.Module);
	VAR ch0, ch1: CHAR; i: INTEGER; symSize: LONGINT;
		R: Files.Rider; fname: Modules.ModuleName; F: Files.File;
	BEGIN
		IF M.publics = 0 THEN
			IF M.import = NIL THEN M.nofimp := 0; NEW(M.import, DefMaxImport) END;
			IF M.struct = NIL THEN M.nofstrc := 0; NEW(M.struct, DefMaxStruct) END;
			IF M.reimp = NIL THEN M.nofreimp := 0; NEW(M.reimp, DefMaxReimp) END;
			i := 0; ch0 := M.name[0];
			WHILE ch0 # 0X DO fname[i] := ch0; INC(i); ch0 := M.name[i] END;
			fname[i] := "."; fname[i+1] := "O"; fname[i+2] := "b"; fname[i+3] := "j"; fname[i+4] := 0X;
			F := Files.Old(fname);
			IF F # NIL THEN Files.Set(R, F, 0);
				Files.Read(R, ch0);
				IF ch0 = 0BBX THEN Files.Read(R, ch1); 
					Files.ReadNum(R, symSize); BuildSym(R, M)
				ELSE Modules.ErrMsg(2 (*Modules.invalidObjFile*), M.name) END;
				Files.Close(Files.Base(R))
			ELSE Modules.ErrMsg(16 (*Modules.incompImport*), M.name) END
		END
	END Decorate;

	PROCEDURE Import(VAR R: Files.Rider; M: Modules.Module);
		VAR name: Modules.ModuleName; im: Modules.Module;  
	BEGIN
		PLT.ReadString(R, name);
		WHILE (name # "") & (Modules.res = 0) DO
			im := Modules.thisMod(name, TRUE);
			IF Modules.res = 0 THEN	Decorate(im);
				IF Modules.res = 0 THEN
					M.import[M.nofimp] := SYS.VAL(LONGINT, im);
					INC(M.nofimp); IF M.nofimp>=LEN(M.import^) THEN PLT.DoubleArr(M.import) END;
					INC(im.refcnt); PLT.ReadString(R, name)
				END
			END
		END
	END Import;

	PROCEDURE Unlink(mod: Modules.Module; all: BOOLEAN);
		VAR i: INTEGER; imp: Modules.Module;
	BEGIN	i := mod.nofimp;
		WHILE i > 0 DO	DEC(i); imp:=SYS.VAL(Modules.Module, mod.import[i]); DEC(imp.refcnt) END;
		IF all THEN i := mod.nofimp;
			WHILE i > 0 DO DEC(i); imp:=SYS.VAL(Modules.Module, mod.import[i]); Modules.Free(imp.name, TRUE) END;
			Modules.res := 0;
		END;
	END Unlink;

	PROCEDURE* Load(VAR R: Files.Rider; M: Modules.Module);
		VAR nofcmds, nofptrs: INTEGER; above, below, c, i, sfSize: LONGINT;
		body: Modules.Command; R1: Files.Rider; m1: Modules.Module; globals, obj: PLT.Object;
			
		PROCEDURE LSW (x: LONGINT): LONGINT;
		BEGIN (* least significant word (unsigned) *)
			RETURN SYS.VAL(LONGINT, SYS.VAL(SET, x) * SYS.VAL(SET, 0FFFFH))
		END LSW;
	
	BEGIN
		M.init := FALSE; nofcmds := 0;
		IF M.import = NIL THEN M.nofimp := 0; NEW(M.import, DefMaxImport) END;
		IF M.struct = NIL THEN M.nofstrc := 0; NEW(M.struct, DefMaxStruct) END;
		IF M.reimp = NIL THEN M.nofreimp := 0; NEW(M.reimp, DefMaxReimp) END;
		Kernel.DisableGC(); Files.ReadNum(R, sfSize); R1 := R;
		Files.Set(R1, Files.Base(R1), Files.Pos(R1) + sfSize); Import(R, M); 
		IF Modules.res = 0 THEN
			M.nofstrc := 1; globals := NIL; Files.ReadNum(R1, sfSize); Files.ReadNum(R1, below); Files.ReadNum(R1, above); 									
			Import(R1, M);															
			m1 := Modules.modList; WHILE m1 # NIL DO m1.nofreimp := 0; m1 := m1.link END;
			PLT.ReadScope(R, M, 0, globals, Global); R := R1;
			IF Modules.res = 0 THEN theMod:=M; PLL.Open; PLO.Open;
				M.publics:=SYS.VAL(LONGINT, globals); PLT.ReadScope(R, M, 0, globals, Local);
				M.privates:=SYS.VAL(LONGINT, globals);	
				PLC.Init({0, 3, 5});
				PLL.Traverse(SYS.VAL(PLT.Object, M.publics)); PLL.Traverse(globals);
				PLL.AllocGlobalVar(SYS.VAL(PLT.Object, M.publics), globals);	(* Calculates global Var Size : PLL.dsize *)
				M.sb := PLO.sb;
				PLL.AllocLinkTable(M.nofimp+1);
				
				PLV.Load(R, M, globals, below, above);
				IF Modules.res = 0 THEN
	
					(* code *)
					M.codeSize:=PLO.pc;
					SYS.PUT(SYS.ADR(M.code), PLO.code);
					Modules.ShrinkCodeBlock(SYS.VAL(LONGINT, M.code), M.codeSize);
					(* Kernel.ShrinkDynCharArr(SYS.VAL(LONGINT, M.code), M.codeSize); *)
					(* NEW(M.code, PLO.pc); SYS.MOVE(SYS.ADR(PLO.code[0]), SYS.ADR(M.code[0]), PLO.pc); *)
	
					(* Const *)
					M.conSize:=0;	(* SHORT(PLO.csize); *)
					SYS.PUT(SYS.ADR(M.data), PLO.data); M.dataSize:=PLO.dsize;
					Modules.ShrinkCodeBlock(SYS.VAL(LONGINT, M.data), M.dataSize);
					(* Kernel.ShrinkDynCharArr(SYS.VAL(LONGINT, M.data), M.dataSize); *)
					(* NEW(M.data, PLL.dsize + PLO.csize); 
					SYS.MOVE(SYS.ADR(PLO.data[0]), SYS.ADR(M.data[PLL.dsize]), PLO.dsize);  *)
					(* M.sb := SYS.ADR(M.data[0]); *)
	
					(* Imports *)
					M.nofimp := 0;
					(* eb, 14.12.95
					links:=M.sb+PLL.linkTable;
					SYS.MOVE(SYS.ADR(KernelSB), links, 4); INC(links, 4);
					FOR i:=0 TO (M.nofimp-1) DO
						m1:=SYS.VAL(Modules.Module, M.import[i]);  
						SYS.MOVE(SYS.ADR(m1.sb), links, 4); INC(links, 4)
					END;
					*)
					
					(* eb, 14.12.95: Für was soll das denn wieder gut sein ?
					obj:=SYS.VAL(PLT.Object, M.privates); 
					WHILE obj#NIL DO
						IF obj.mode = XProc THEN
							obj.linkadr:=M.block+4*PLL.entry[obj.adr]; obj.lim:=obj.lim*4+M.block; obj.psize:=obj.lim-obj.linkadr
						ELSIF obj.mode = LProc THEN
							obj.linkadr:=M.block+4*obj.adr; obj.lim:=obj.lim*4+M.block; obj.psize:=obj.lim-obj.linkadr
						END;	
						obj:=obj.nxtobj
					END;
					*)
					
					(* Entries *)
					M.nofEntries := PLL.nofEntries;
					IF PLL.nofEntries > 0 THEN
						NEW(M.entries, PLL.nofEntries);
						i := 0; c := SYS.ADR(M.code[0]);
						WHILE i < PLL.nofEntries DO M.entries[i] := c + LSW(PLL.entry[i]); INC(i) END
					END;
					
					(* collect commands and pointers *)
					nofptrs := 0;
					obj := SYS.VAL(PLT.Object, M.privates);
					WHILE obj # NIL DO
						IF (obj.mode = XProc) & (obj.par = NIL) & (obj.typ = PLT.notyp) THEN INC(nofcmds)
						ELSIF obj.mode = Var THEN 
							PLL.FindPtrs(obj.typ, obj.linkadr, nofptrs)
						END;
						obj := obj.nxtobj
					END;
									
					(* Commands *)
					M.nofCmds := nofcmds; c := SYS.ADR(M.code[0]);
					IF nofcmds > 0 THEN
						NEW(M.cmds, nofcmds);
						i := 0; obj := SYS.VAL(PLT.Object, M.privates);
						WHILE obj # NIL DO
							IF (obj.mode = XProc) & (obj.par = NIL) & (obj.typ = PLT.notyp) THEN
								COPY(obj.name, M.cmds[i].name);
								M.cmds[i].adr := c + LSW(PLL.entry[obj.adr MOD 10000H]);
								INC(i)
							END;
							obj := obj.nxtobj
						END
					END;
	
					(* Pointers *)
					M.nofPtrs := nofptrs;
					IF nofptrs > 0 THEN
						NEW(M.ptrTab, nofptrs);
						i := 0; WHILE i < nofptrs DO M.ptrTab[i] := PLL.ptrTab[i]; INC(i) END
					END;

					(* Type Descriptors *)
					M.nofTds := PLL.nofrecs;
					IF M.nofTds > 0 THEN
						NEW(M.tdescs, PLL.nofrecs);
						i := 0; WHILE i < PLL.nofrecs DO M.tdescs[i] := PLL.recTab[i].tdadr; INC(i) END;
					END;
					
					(* References *)
					M.refSize := PLL.refSize;
					IF PLL.refSize > 0 THEN
						NEW(M.refs, PLL.refSize);
						i := 0; WHILE i < PLL.refSize DO M.refs[i] := PLL.refs[i]; INC(i) END;
					END;
	
					(*	IF verbose & (verboseHook#NIL) THEN verboseHook(M) END;	*)
					M.init := TRUE; M.link := Modules.modList; Modules.modList := M; PLL.Close; (* M.privates := 0; *)
					body := SYS.VAL(Modules.Command, M.entries[0]);
					m1 := NIL; globals := NIL; obj := NIL;
					above := 0; below := 0; c := 0; i := 0; sfSize := 0;
					Kernel.EnableGC(); Modules.res := 0;
					IF ~first THEN Kernel.GC() ELSE first := FALSE END;
					body();
					Modules.res := 0;
					RETURN
				ELSE Unlink(M, FALSE); Files.Close(Files.Base(R)) END
			ELSE Unlink(M, FALSE); Files.Close(Files.Base(R)) END
		ELSE Unlink(M, FALSE); Files.Close(Files.Base(R)) END;
		Kernel.EnableGC()
	END Load;

(*
	PROCEDURE Start*;
	BEGIN	Modules.extended.Load := Load
	END Start;

	PROCEDURE Stop*;
	BEGIN	Modules.extended.Load := NIL
	END Stop;

	PROCEDURE Verbose*;
	BEGIN verbose := TRUE
	END Verbose;

	PROCEDURE ChecksOn*;
	BEGIN	options := {inxchk, ovflchk, ranchk, typchk, ptrinit}
	END ChecksOn;

	PROCEDURE ChecksOff*;
	BEGIN	options := {}
	END ChecksOff;
*)

BEGIN
	(*	options := {inxchk, ovflchk, ranchk, typchk, ptrinit};	*)
	first := TRUE;
	Modules.extended.Load:=Load; Modules.extended.Unlink:=Unlink
END Interchange.