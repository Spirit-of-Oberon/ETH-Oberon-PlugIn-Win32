(* OBERON System 3, Release 2.2.

Copyright 1996 Team of the Institute of Computer Systems of ETH Zürich, ETH Center, CH-8092 Zürich,
e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon System 3 license contract.
The full text can be downloaded from

	"ftp://ftp@ftp.inf.ethz.ch/pub/software/Oberon/System3/License.Text;A"

or requested from the above mentioned address.

Under the license terms stated it is in particular (a) prohibited to modify the interface of this module
in any way that disagrees with style or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Interchange;	(*mf 11.11.94 / od Jan 95 / tk  *)

	IMPORT SYS := SYSTEM, Kernel, Modules, Files, PLT := OPLT, PLO := OPLO, PLL := OPLL, PLC := OPLC, PLV := OPLV;

	TYPE
		CommandDesc = RECORD
			name: ARRAY 24 OF CHAR;
			offset: INTEGER
		END;

	CONST
		Var = 1; Par = 2; VarPar = 3; Con = 4; LProc = 6; XProc = 7; TypDynArr = 8;
		TypArray = 9; TypPointer = 10; TypRecord = 11; TypProcTyp = 12;
		Byte = 1; Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6; Real = 7; LReal = 8;
		Set = 9; String = 10; Pointer = 13; Comp = 15;
		Array = 2; DynArr = 3; Record = 4;
		
		Local=FALSE; Global=TRUE;
			
		inxchk = 0; ovflchk = 1; ranchk = 2; typchk = 3; ptrinit = 5;
		
	VAR
		verbose : BOOLEAN;
		verboseHook*: PROCEDURE (M: Modules.Module);
		options: SET;

	PROCEDURE Str(s: ARRAY OF CHAR);
		VAR i: INTEGER;
	BEGIN	i:=0; REPEAT Modules.resMsg[Modules.resMsgLen]:=s[i]; INC(i); INC(Modules.resMsgLen) UNTIL s[i-1]=0X; DEC(Modules.resMsgLen);
	END Str;

	PROCEDURE Ln;
	BEGIN	Modules.resMsg[Modules.resMsgLen]:=0DX; INC(Modules.resMsgLen); Modules.resMsg[Modules.resMsgLen]:=0X
	END Ln;
	
	PROCEDURE err(n: INTEGER; VAR name: ARRAY OF CHAR);
	BEGIN Modules.res := n; 
		IF n > 0 THEN
			IF n < 20 THEN Str("Call error: "); Str(name) END;
			IF n = 1 THEN Str(" not found")
			ELSIF n = 2 THEN Str(" not a valid object file")
			ELSIF n = 8 THEN Str(" no symbols")
			END
		END
	END err;

	PROCEDURE^ Import(VAR R: Files.Rider; M: Modules.Module);

	PROCEDURE BuildSym(VAR R: Files.Rider; M: Modules.Module);
		VAR mnolev: SHORTINT; ent: INTEGER; nofEntries, adr, nofRecs, s: LONGINT;
			mod: Modules.Module; obj: PLT.Object;
	BEGIN	Import(R, M);
		IF Modules.res = 0 THEN	M.nofstrc := 1; obj := NIL;
			mod := Modules.modList; WHILE mod # NIL DO mod.nofreimp := 0; mod := mod.link END;
			PLT.ReadScope(R, M, 0, obj, Global); M.publics := SYS.VAL(LONGINT, obj);			
			nofEntries := 1; adr := 0; nofRecs := 0;
			WHILE obj # NIL DO
				CASE obj.mode OF
					| Var: PLL.TypSize(obj.typ); s := obj.typ.size; PLL.AlignVar(adr, s); PLL.AllocVar(adr, obj.linkadr, s); 
						obj.linkadr := obj.linkadr + M.sb;
					| XProc: obj.linkadr := M.entries[nofEntries];
							INC(nofEntries); IF nofEntries > 127 THEN HALT(33) END;
							obj.adr := 0; PLL.ParamAdr(obj);
					| TypRecord: PLL.TypSize(obj.typ); obj.typ.tdadr := M.tdescs[nofRecs]; INC(nofRecs); obj.linkadr := -1;
					| TypDynArr, TypArray, TypPointer, TypProcTyp: PLL.TypSize(obj.typ); obj.linkadr := -1;
					| Con:
				ELSE
				END;
				obj:=obj.nxtobj
			END;
		END;
	END BuildSym;

	(*append object list to module descriptor*)
	PROCEDURE Decorate*(M: Modules.Module);
	VAR done: BOOLEAN; ch0, ch1: CHAR; i: INTEGER; symSize: LONGINT;
		R: Files.Rider; fname: Modules.ModuleName; F: Files.File;
	BEGIN
		IF M.publics = 0 THEN
			i := 0; ch0 := M.name[0];
			WHILE ch0 # 0X DO fname[i] := ch0; INC(i); ch0 := M.name[i] END;
			fname[i] := "."; fname[i+1] := "O"; fname[i+2] := "b"; fname[i+3] := "j"; fname[i+4] := 0X;
			F := Files.Old(fname);
			IF F # NIL THEN Files.Set(R, F, 0);
				Files.Read(R, ch0);
				IF ch0 = 0BBX THEN Files.Read(R, ch1); 
					Files.ReadNum(R, symSize); BuildSym(R, M)
				ELSE err(2, M.name) END;
				Files.Close(Files.Base(R))
			ELSE err(8, M.name) END
		END
	END Decorate;

	PROCEDURE Import(VAR R: Files.Rider; M: Modules.Module);
		VAR name: Modules.ModuleName; im: Modules.Module;  
	BEGIN
		PLT.ReadString(R, name);
		WHILE (name # "") & (Modules.res = 0) DO
			im := Modules.thisMod(name, TRUE);
			IF Modules.res = 0 THEN	Decorate(im);
				IF Modules.res = 0 THEN
					M.import[M.nofimp] := SYS.VAL(LONGINT, im);
					INC(M.nofimp); IF M.nofimp>=LEN(M.import^) THEN PLT.DoubleArr(M.import) END;
					INC(im.refcnt); PLT.ReadString(R, name)
				END
			END
		END
	END Import;

	PROCEDURE Unlink(mod: Modules.Module; all: BOOLEAN);
		VAR i: INTEGER; imp: Modules.Module;
	BEGIN	i := mod.nofimp;
		WHILE i > 0 DO	DEC(i); imp:=SYS.VAL(Modules.Module, mod.import[i]); DEC(imp.refcnt) END;
		IF all THEN i := mod.nofimp;
			WHILE i > 0 DO DEC(i); imp:=SYS.VAL(Modules.Module, mod.import[i]); Modules.Free(imp.name, TRUE) END;
			Modules.res := 0;
		END;
	END Unlink;

	PROCEDURE* Load(VAR R: Files.Rider; M: Modules.Module);
		VAR nofcmds, nofptrs: INTEGER; above, below, c, d, i, sfSize: LONGINT;
		body: PROCEDURE; R1: Files.Rider; m1: Modules.Module; globals, obj: PLT.Object;
			
		PROCEDURE LSW (x: LONGINT): LONGINT;
		BEGIN (* least significant word (unsigned) *)
			RETURN SYS.VAL(LONGINT, SYS.VAL(SET, x) * SYS.VAL(SET, 0FFFFH))
		END LSW;
	
	BEGIN
		M.init := FALSE;
		Kernel.DisableGC(); Files.ReadNum(R, sfSize); R1 := R;
		Files.Set(R1, Files.Base(R1), Files.Pos(R1) + sfSize); Import(R, M); 
		IF Modules.res = 0 THEN
			M.nofstrc := 1; globals := NIL; Files.ReadNum(R1, sfSize); Files.ReadNum(R1, below); Files.ReadNum(R1, above); 									
			Import(R1, M);															
			m1 := Modules.modList; WHILE m1 # NIL DO m1.nofreimp := 0; m1 := m1.link END;
			PLT.ReadScope(R, M, 0, globals, Global); R := R1;
			IF Modules.res = 0 THEN PLT.theMod:=M; PLL.Open; PLO.Open;
				M.publics:=SYS.VAL(LONGINT, globals); PLT.ReadScope(R, M, 0, globals, Local);
				M.privates:=SYS.VAL(LONGINT, globals);	
				PLC.Init({0, 3, 5});
				PLL.Traverse(SYS.VAL(PLT.Object, M.publics)); PLL.Traverse(globals);
				PLL.AllocGlobalVar(SYS.VAL(PLT.Object, M.publics), globals);	(* Calculates global Var Size : PLL.dsize *)
				M.sb := PLO.sb;
				PLL.AllocLinkTable(M.nofimp+1);
				
				PLV.Load(R, M, globals, below, above);
				IF Modules.res = 0 THEN
	
					(* code *)
					M.codeSize:=PLO.pc;
					SYS.PUT(SYS.ADR(M.code), PLO.code);
					Modules.ShrinkCodeBlock(SYS.VAL(LONGINT, M.code), M.codeSize);
					(* Kernel.ShrinkDynCharArr(SYS.VAL(LONGINT, M.code), M.codeSize); *)
					(* NEW(M.code, PLO.pc); SYS.MOVE(SYS.ADR(PLO.code[0]), SYS.ADR(M.code[0]), PLO.pc); *)
	
					(* Const *)
					M.conSize:=0;	(* SHORT(PLO.csize); *)
					SYS.PUT(SYS.ADR(M.data), PLO.data); M.dataSize:=PLO.dsize;
					Modules.ShrinkCodeBlock(SYS.VAL(LONGINT, M.data), M.dataSize);
					(* Kernel.ShrinkDynCharArr(SYS.VAL(LONGINT, M.data), M.dataSize); *)
					(* NEW(M.data, PLL.dsize + PLO.csize); 
					SYS.MOVE(SYS.ADR(PLO.data[0]), SYS.ADR(M.data[PLL.dsize]), PLO.dsize);  *)
					(* M.sb := SYS.ADR(M.data[0]); *)
	
					(* Imports *)
					M.nofimp := 0;
					(* eb, 14.12.95
					links:=M.sb+PLL.linkTable;
					SYS.MOVE(SYS.ADR(KernelSB), links, 4); INC(links, 4);
					FOR i:=0 TO (M.nofimp-1) DO
						m1:=SYS.VAL(Modules.Module, M.import[i]);  
						SYS.MOVE(SYS.ADR(m1.sb), links, 4); INC(links, 4)
					END;
					*)
					
					(* eb, 14.12.95: Für was soll das denn wieder gut sein ?
					obj:=SYS.VAL(PLT.Object, M.privates); 
					WHILE obj#NIL DO
						IF obj.mode = XProc THEN
							obj.linkadr:=M.block+4*PLL.entry[obj.adr]; obj.lim:=obj.lim*4+M.block; obj.psize:=obj.lim-obj.linkadr
						ELSIF obj.mode = LProc THEN
							obj.linkadr:=M.block+4*obj.adr; obj.lim:=obj.lim*4+M.block; obj.psize:=obj.lim-obj.linkadr
						END;	
						obj:=obj.nxtobj
					END;
					*)
					
					(* Entries *)
					M.nofEntries := PLL.nofEntries;
					IF PLL.nofEntries > 0 THEN
						NEW(M.entries, PLL.nofEntries);
						i := 0; c := SYS.ADR(M.code[0]);
						WHILE i < PLL.nofEntries DO M.entries[i] := c + LSW(PLL.entry[i]); INC(i) END
					END;
					
					(* collect commands and pointers *)
					nofptrs := 0;
					obj := SYS.VAL(PLT.Object, M.privates);
					WHILE obj # NIL DO
						IF (obj.mode = XProc) & (obj.par = NIL) & (obj.typ = PLT.notyp) THEN INC(nofcmds)
						ELSIF obj.mode = Var THEN 
							PLL.FindPtrs(obj.typ, obj.linkadr, nofptrs)
						END;
						obj := obj.nxtobj
					END;
									
					(* Commands *)
					M.nofCmds := nofcmds; c := SYS.ADR(M.code[0]);
					IF nofcmds > 0 THEN
						NEW(M.cmds, nofcmds);
						i := 0; obj := SYS.VAL(PLT.Object, M.privates);
						WHILE obj # NIL DO
							IF (obj.mode = XProc) & (obj.par = NIL) & (obj.typ = PLT.notyp) THEN
								COPY(obj.name, M.cmds[i].name);
								M.cmds[i].adr := c + LSW(PLL.entry[obj.adr MOD 10000H]);
								INC(i)
							END;
							obj := obj.nxtobj
						END
					END;
	
					(* Pointers *)
					M.nofPtrs := nofptrs;
					IF nofptrs > 0 THEN
						NEW(M.ptrTab, nofptrs);
						i := 0; WHILE i < nofptrs DO M.ptrTab[i] := PLL.ptrTab[i]; INC(i) END
					END;

					(* Type Descriptors *)
					M.nofTds := PLL.nofrecs;
					IF M.nofTds > 0 THEN
						NEW(M.tdescs, PLL.nofrecs);
						i := 0; WHILE i < PLL.nofrecs DO M.tdescs[i] := PLL.recTab[i].tdadr; INC(i) END;
					END;
					
					(* References *)
					M.refSize := PLL.refSize;
					IF PLL.refSize > 0 THEN
						NEW(M.refs, PLL.refSize);
						i := 0; WHILE i < PLL.refSize DO M.refs[i] := PLL.refs[i]; INC(i) END;
					END;
	
					IF verbose & (verboseHook#NIL) THEN verboseHook(M) END;
					M.init := TRUE; PLL.Close; (* M.privates := 0; *)
					SYS.PUT(SYS.ADR(body), M.entries[0]);
					m1 := NIL; globals := NIL; obj := NIL;
					above := 0; below := 0; c := 0; d := 0; i := 0; sfSize := 0;
					Kernel.EnableGC();
(*Kernel.getCodeSize(c, d);
IF (Kernel.HeapSize() - Kernel.Available() - c - d) < (256*1024) THEN*)
	Kernel.GC();
(*END;*)

					body();
					Modules.res := 0; RETURN
				ELSE Unlink(M, FALSE); Files.Close(Files.Base(R)) END
			ELSE Unlink(M, FALSE); Files.Close(Files.Base(R)) END
		ELSE Unlink(M, FALSE); Files.Close(Files.Base(R)) END;
		Kernel.EnableGC()
	END Load;

	PROCEDURE Start*;
	BEGIN	Modules.extended.Load := Load
	END Start;

	PROCEDURE Stop*;
	BEGIN	Modules.extended.Load := NIL
	END Stop;

	PROCEDURE Verbose*;
	BEGIN verbose := TRUE
	END Verbose;

	PROCEDURE ChecksOn*;
	BEGIN	options := {inxchk, ovflchk, ranchk, typchk, ptrinit}
	END ChecksOn;

	PROCEDURE ChecksOff*;
	BEGIN	options := {}
	END ChecksOff;

BEGIN
	options := {inxchk, ovflchk, ranchk, typchk, ptrinit};
	Modules.extended.Load:=Load; Modules.extended.Unlink:=Unlink
END Interchange.