(* OBERON System 3, Release 2.3.

Copyright 1999 ETH Zürich Institute for Computer Systems, 
ETH Center, CH-8092 Zürich.  e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE OPLT; (** non-portable / source: Win32.OPLT.Mod *)	(*mf 18.10.93 / od Feb 95 / tk object model 6.7.96 *)

	(* 30.6.96	Method support (mfix) *)	

	IMPORT
		SYS := SYSTEM, Files, Modules;

	TYPE
		Name*=ARRAY 32 OF CHAR;
		Object*=POINTER TO ObjDesc;
		Struct*=POINTER TO StrDesc;
		StrPtr*= POINTER TO ARRAY 256 OF CHAR;
	
		ObjDesc*=RECORD
			name*: Name; nxtobj*: Object;
			mode*, level*, vis*: SHORTINT; typ*: Struct;
			ival*: LONGINT; rval*: LONGREAL; xval*: StrPtr;	(*constants*)
			inited*: BOOLEAN; psize*, dsize*, fp*: LONGINT; par*, locals*: Object; nofpar*, fixlink*: INTEGER;
			adr*, lim*: LONGINT;	(*procedures*)
			linkadr* : LONGINT;
			intval2*: LONGINT; setval*: SET; (* for procs *)
			leaf*: BOOLEAN; 
			mod*: LONGINT;	(* Modules.Module *) 
		END;
	
		StrDesc*=RECORD
			form*, comp*, extlev*: SHORTINT; sysflag*, align*: SHORTINT;
			BaseTyp*: Struct; dsc*, strobj*: Object;
			nofdsc*, nofptr*: INTEGER; fpdone: LONGINT; mod*: Modules.Module; 
			n*, size*, tdadr*, fp*, pvfp*, pbfp*, oref*: LONGINT;
			offset* : LONGINT;
		END;

	VAR
		booltyp*, chartyp*, sinttyp*, inttyp*, linttyp*, realtyp*, lrltyp*, settyp*, stringtyp*, niltyp*, notyp*, sysptrtyp*, ptrtyp*, proctyp*: Struct;
	
	CONST
		Var=1; Par=2; VarPar=3; Con=4; Fld=5; LProc=6; XProc=7; TypDynArr=8; TypArray=9; TypPointer=10; 
		TypRecord=11; TypProcTyp=12; TypAlias=13; TProc=14;	(* mfix *)
		Bool=2; Char=3; SInt=4; Int=5; LInt=6; Real=7; LReal=8; Set=9; String=10; NilTyp=11;
		NoTyp=12; Pointer=13; ProcTyp=14; Comp=15; Basic=1; Array=2; DynArr=3; Record=4;
	
		SFtypBool=01H; SFtypChar=02H; SFtypSInt=03H; SFtypInt=04H; SFtypLInt=05H;
		SFtypReal=06H; SFtypLReal=07H; SFtypSet=08H; SFtypString=09H; SFtypNoTyp=0AH; SFtypNilTyp=0BH;
		SFtypByte=0CH; SFtypSptr=0DH; SFmod1=0EH; SFmodOther=2DH;
		SFtypDynArr=2EH; SFtypArray=2FH; SFtypPointer=30H; SFtypRecord=31H; SFtypProcTyp=32H;
		SFsysflag=33H; SFinvisible=34H; SFreadonly=35H; SFleaf=36H;
		SFconst=37H; SFvar=38H; SFlproc=39H; SFxproc=3AH; SFcproc=3BH; SFtproc=3CH; SFalias=3DH; SFtyp=3EH; SFend=3FH;
	
		internal=0; external=1; externalR=2;
	
	VAR
		predefStruct: ARRAY SFtypProcTyp+1 OF Struct;	(*predefined types*)
		strucForm: ARRAY SFtypProcTyp+1 OF SHORTINT;	(*forms of structures*)
		strucComp: ARRAY SFtypProcTyp+1 OF SHORTINT;	(*forms of structures*)
		tobjMode: ARRAY SFtypProcTyp+1 OF SHORTINT;	(*modes of type objects*)
		cobjMode: ARRAY TypAlias+1 OF SHORTINT;   (*compiler's object modes*)
		thisMod: Modules.Module; predefMod: LONGINT;
		typSize*: PROCEDURE (typ: Struct; alloc: BOOLEAN);
	
	(* Fingerprinting *)
	
	PROCEDURE ReadString*(VAR R: Files.Rider; VAR string: ARRAY OF CHAR);
		VAR i: INTEGER; ch: CHAR;
	BEGIN i := 0;
		LOOP Files.Read(R, ch);
			IF ch = 0X THEN string[i] := 0X; RETURN
			ELSIF ch < 7FX THEN string[i]:=ch; INC(i)
			ELSIF ch > 7FX THEN string[i] := CHR(ORD(ch)-80H); string[i+1] := 0X; RETURN
			ELSE (* ch = 7FX *) EXIT END
		END;
		LOOP Files.Read(R, ch);
			IF ch = 0X THEN string[i]:=0X; RETURN
			ELSE string[i]:=ch; INC(i) END
		END
	END ReadString;
	
	PROCEDURE FPrint(VAR fp: LONGINT; val: LONGINT);
	BEGIN fp:=SYS.VAL(LONGINT, SYS.VAL(SET, SYS.ROT(fp, 7)) / SYS.VAL(SET, val))
	END FPrint;

	PROCEDURE FPrintSet(VAR fp: LONGINT; set: SET);
	BEGIN FPrint(fp, SYS.VAL(LONGINT, set))
	END FPrintSet;

	PROCEDURE FPrintReal(VAR fp: LONGINT; real: REAL);
	BEGIN FPrint(fp, SYS.VAL(LONGINT, real))
	END FPrintReal;

	PROCEDURE FPrintLReal(VAR fp: LONGINT; lr: LONGREAL);
		VAR l, h: LONGINT;
	BEGIN
		SYS.GET(SYS.ADR(lr)+4, l); SYS.GET(SYS.ADR(lr), h);
		FPrint(fp, l); FPrint(fp, h);
	END FPrintLReal;
	
	PROCEDURE ^ FPrintTyp0(typ: Struct);
	PROCEDURE ^ FPrintTyp*(typ: Struct);
	
	PROCEDURE FPrintName(VAR fp: LONGINT; VAR name: ARRAY OF CHAR);
		VAR i: INTEGER; ch: CHAR; 
	BEGIN i:=0; REPEAT ch:=name[i]; FPrint(fp, ORD(ch)); INC(i) UNTIL ch=0X
	END FPrintName;
	
	PROCEDURE FPrintSign(VAR fp: LONGINT; result: Struct; par: Object);
	BEGIN 
		FPrintTyp0(result); FPrint(fp, result.fp);
		WHILE par#NIL DO
			FPrint(fp, cobjMode[par.mode]); 
			IF par.typ # NIL THEN FPrintTyp0(par.typ); FPrint(fp, par.typ.fp) END;
			par:=par.nxtobj;
		END;
	END FPrintSign;

	PROCEDURE FindField(VAR name: Name; typ: Struct; VAR res: Object);	(* mfix *)
		VAR obj: Object;
	BEGIN	res := NIL;
		WHILE (typ # NIL) & (res = NIL) DO obj := typ.dsc;
			WHILE obj # NIL DO
				IF name = obj.name THEN res := obj; obj := NIL ELSE obj := obj.nxtobj END;
			END;
			IF res = NIL THEN typ := typ.BaseTyp END
		END
	END FindField;

	PROCEDURE FPrintMeth(typ: Struct; fld: Object);
		VAR fp: LONGINT; 
	BEGIN
		WHILE fld # NIL DO
			IF (fld.mode=TProc) & (fld.vis#internal) THEN 
				fp:=0; FPrint(fp, 13 (* TProc *)); FPrintName(fp, fld.name); FPrintSign(fp, fld.typ, fld.par); fld.fp:=fp;
				FPrint(fp, fld.adr DIV 10000H); FPrint(typ.pbfp, fp); FPrint(typ.pvfp, fp);
			END;
			fld := fld.nxtobj;
		END
	END FPrintMeth;

	PROCEDURE FPrintRecord(typ: Struct);
		VAR fld: Object; fp, pbfp, pvfp: LONGINT;
	BEGIN 
		pvfp:=typ.fp; pbfp:=typ.fp;
		IF typ.BaseTyp#NIL THEN FPrint(pvfp, typ.BaseTyp.pvfp);
			FPrint(pbfp, typ.BaseTyp.pbfp)
		END;
		IF typ.size<0 THEN typSize(typ, FALSE) END; fld:=typ.dsc; 
		FPrintMeth(typ, fld); 	(* mfix *)
		WHILE (fld#NIL) & (fld.mode=Fld) DO FPrintTyp(fld.typ); 
			IF fld.vis#internal THEN 
				fp:=0; FPrint(fp, cobjMode[fld.mode]);
				FPrintName(fp, fld.name); FPrint(fp, fld.vis);
				FPrint(fp, fld.typ.fp); fld.fp:=fp;
				FPrint(pbfp, fld.typ.pbfp); FPrint(pbfp, fld.adr);
				FPrint(pvfp, fld.typ.pvfp); FPrint(pvfp, fld.adr); 
				FPrint(pvfp, fp); FPrint(pbfp, fp);
				fld:=fld.nxtobj;
			ELSE 
				FPrint(pvfp, fld.fp); fld:=fld.nxtobj;
			(*	fp:=fld.adr;	(* include size and pointeradresses *)
				WHILE (fld#NIL) & (fld.mode=Fld) & (fld.vis=internal) DO 
					IF fld.typ.form=Pointer THEN FPrint(pvfp, fld.adr) END;
					fld:=fld.nxtobj
				END;
				IF fld#NIL THEN fp:=fld.adr-fp ELSE fp:=typ.size-fp END;
				FPrint(pvfp, fp); *)
			END;
		END;
		typ.pbfp := pbfp; typ.pvfp := pvfp;	(* replace typ.pbfp with pbfp and typ.pvfp with pvfp *)
	END FPrintRecord;

	PROCEDURE FPrintTyp0(typ: Struct); (* ejz *)
		VAR fp: LONGINT; f, c: SHORTINT; btyp: Struct;
	BEGIN
		IF (typ # NIL) & (typ.fpdone#predefMod) THEN
			fp:=0; f:=typ.form; c:=typ.comp; FPrint(fp, f); FPrint(fp, c); 
			IF typ.sysflag # 0 THEN FPrint(fp, typ.sysflag) END;
			IF typ.mod#thisMod THEN FPrintName(fp, typ.mod.name); FPrintName(fp, typ.strobj.name);
			END;
			btyp:=typ.BaseTyp; typ.fp:=fp;
			IF (c=Record) & (btyp#NIL) OR (f=Pointer) THEN FPrintTyp0(btyp); FPrint(typ.fp, btyp.fp)
			ELSIF (c=DynArr) OR (c=Array) THEN FPrintTyp0(btyp); FPrint(typ.fp, btyp.fp);
				IF c=Array THEN FPrint(typ.fp, typ.n) END; typ.pbfp:=typ.fp; typ.pvfp:=typ.fp;
			ELSIF f=ProcTyp THEN FPrintSign(typ.fp, btyp, typ.dsc); typ.pbfp:=typ.fp; typ.pvfp:=typ.fp;
			END;
		END
	END FPrintTyp0;
	
	PROCEDURE FPrintTyp*(typ: Struct);	
	BEGIN 
		IF (typ # NIL) & (typ.fpdone#SYS.VAL(LONGINT, thisMod)) & (typ.fpdone#predefMod) THEN	(* not calculated for this mod *)
			FPrintTyp0(typ);
			IF typ.comp # Record THEN typ.fpdone:=SYS.VAL(LONGINT, thisMod) END;
			IF typ.BaseTyp#NIL THEN FPrintTyp(typ.BaseTyp) END;
			IF typ.comp=Record THEN FPrintRecord(typ) END;
			typ.fpdone:=SYS.VAL(LONGINT, thisMod);
		END;
	END FPrintTyp;

	PROCEDURE FPrintObj*(M: Modules.Module; obj: Object);
		VAR fp: LONGINT; f: INTEGER; 
	BEGIN 
		fp:=0; thisMod:=M;
		FPrint(fp, cobjMode[obj.mode]); FPrintName(fp, obj.name); FPrint(fp, obj.vis);
		IF obj.mode=Con THEN
			f:=obj.typ.form; FPrint(fp, f); FPrint(fp, obj.typ.comp);
			CASE f OF
			| Bool, Char, SInt, Int, LInt: FPrint(fp, obj.ival);
			| Set: FPrintSet(fp, SYS.VAL(SET, obj.ival));
			| Real: FPrintReal(fp, SYS.VAL(REAL, obj.intval2));
			| LReal: FPrintLReal(fp, obj.rval);
			| String: FPrintName(fp, obj.xval^);
			| NilTyp:
			END
		ELSIF obj.mode=Var THEN FPrintTyp(obj.typ); FPrint(fp, obj.typ.fp);
		ELSIF obj.mode=XProc THEN  FPrintSign(fp, obj.typ, obj.par); 
		ELSIF obj.mode>XProc THEN FPrintTyp(obj.typ); FPrint(fp, obj.typ.fp);
		END;
		obj.fp:=fp;
	END FPrintObj;
	
	PROCEDURE DoubleArr*(VAR x: Modules.ArrayPtr);
		VAR i: LONGINT; h: Modules.ArrayPtr;
	BEGIN
		i := LEN(x^); h := x; NEW(x, 2*i);
		ASSERT(x # NIL);
		SYS.MOVE(SYS.ADR(h[0]), SYS.ADR(x[0]), i*SIZE(LONGINT));
	END DoubleArr;

	PROCEDURE ReadScope*(VAR R: Files.Rider; M: Modules.Module; level: SHORTINT; VAR scope: Object; global: BOOLEAN);
		VAR ch: CHAR; mode: SHORTINT; idum: INTEGER; tag: LONGINT; 
			obj, odum: Object; tdum: Struct; ndum: Name; 
		
		PROCEDURE^ InStruct(VAR typ: Struct);
	
		(* Cyclic structures require post-processing *)
		PROCEDURE SetTypFlags(typ: Struct);
			
			PROCEDURE TraverseTProc(fld: Object);
				VAR redef: Object;
			BEGIN
				WHILE fld # NIL DO
					IF fld.mode = TProc THEN
						FindField(fld.name, typ.BaseTyp, redef);
						IF redef # NIL THEN fld.adr := (redef.adr DIV 10000H) * 10000H
						ELSE fld.adr:=typ.n*10000H; INC(typ.n)
						END;
					END;
					fld := fld.nxtobj
				END
			END TraverseTProc;
		
		BEGIN
			IF (typ.extlev = -1) OR (typ.n < 0) THEN 
				IF typ.BaseTyp # NIL THEN SetTypFlags(typ.BaseTyp); 
					typ.extlev := typ.BaseTyp.extlev + 1; 
					typ.n := typ.BaseTyp.n;
				ELSE typ.extlev := 0; typ.n := 0
				END;
				TraverseTProc(typ.dsc)
			END
		END SetTypFlags;

		PROCEDURE InList(mode: SHORTINT; VAR first: Object; VAR nofelem: INTEGER);	(* mfix *)
			VAR last, elem: Object; lev: SHORTINT;
		BEGIN 
			first := NIL; last := NIL; nofelem := 0; Files.ReadNum(R, tag);
			WHILE tag < SFtproc DO NEW(elem); elem.level := level; elem.mod := SYS.VAL(LONGINT, M); INC(nofelem);
				IF last = NIL THEN first := elem ELSE last.nxtobj := elem END;
				last := elem; elem.vis := external;
				IF tag = SFreadonly THEN Files.ReadNum(R, tag); elem.vis := externalR; elem.mode := mode
				ELSIF tag = SFvar THEN elem.mode := VarPar; Files.ReadNum(R, tag)
				ELSE elem.mode := mode END;
				IF tag = SFleaf THEN elem.leaf := TRUE; Files.ReadNum(R, tag) END;
				InStruct(elem.typ); ReadString(R, elem.name); 
				IF (elem.name = "") & global THEN elem.vis := internal END;
				Files.ReadNum(R, tag)
			END;
			IF	tag=SFtproc	THEN	(* skip methods *)
				Files.ReadNum(R, tag);
				WHILE	tag#SFend	DO	NEW(elem); elem.level:=0; elem.mod:=SYS.VAL(LONGINT, M);
					IF	last=NIL	THEN	first:=elem	ELSE	last.nxtobj:=elem	END;
					last:=elem; elem.vis:=external; elem.mode:=TProc; 
					InStruct(elem.typ); ReadString(R, elem.name); 
					IF elem.name = "" THEN elem.vis:=internal; ReadString(R, elem.name) END;
					lev:=level; level:=1; InList(Par, elem.par, elem.nofpar); level:=lev;
					Files.ReadNum(R, tag)
				END;
			END
		END InList;

		PROCEDURE InStruct(VAR typ: Struct); (* ejz *)
			VAR typname: ARRAY 32 OF CHAR; vis: SHORTINT; i: INTEGER; typtag, typadr: LONGINT;
				mod : Modules.Module; strobj, tobj: Object; btyp: Struct;
		BEGIN
			IF tag <= 0 THEN ASSERT(tag>-LEN(M.struct^)); typ := SYS.VAL(Struct, M.struct[-tag])
			ELSIF tag <= SFtypSptr THEN typ := predefStruct[tag]
			ELSIF tag <= SFmodOther THEN
				IF tag = SFmodOther THEN Files.ReadNum(R, tag) ELSE tag := tag  -SFmod1 END;
				mod := SYS.VAL(Modules.Module, M.import[tag]);
				ReadString(R, typname);
				IF typname[0] # 0X THEN btyp := SYS.VAL(Struct, mod.struct[1]);
					i := 1; WHILE (i < mod.nofstrc) & (btyp.strobj.name # typname) DO INC(i); btyp := SYS.VAL(Struct, mod.struct[i]) 
					END;
					IF i < mod.nofstrc THEN
						IF i<mod.nofstrc THEN typ:=SYS.VAL(Struct, mod.struct[i]) ELSE  typ:=niltyp END;
						INC(mod.nofreimp);
						IF mod.nofreimp>=LEN(mod.reimp^) THEN DoubleArr(mod.reimp) END;
						mod.reimp[mod.nofreimp] := SYS.VAL(LONGINT, typ)
					ELSE typ := niltyp
					END
				ELSE Files.ReadNum(R, typadr); ASSERT(typadr<LEN(mod.reimp^)); typ := SYS.VAL(Struct, mod.reimp[typadr]);
				END
			ELSE
				NEW(typ); typ.mod := M; M.struct[M.nofstrc] := SYS.VAL(LONGINT, typ); INC(M.nofstrc);
				vis := internal;
				IF M.nofstrc>=LEN(M.struct^) THEN DoubleArr(M.struct) END;
				IF tag = SFinvisible THEN Files.ReadNum(R, tag) ELSIF global THEN vis := external END;
				IF tag = SFsysflag THEN Files.ReadNum(R, tag); typ.sysflag := SHORT(SHORT(tag)); Files.ReadNum(R, tag) END;
				typ.form := strucForm[tag]; typ.comp := strucComp[tag]; typ.size := -1; typtag := tag; Files.ReadNum(R, tag);
				typ.extlev := -1; InStruct(btyp); typ.BaseTyp := btyp;
				IF	(typ.form=Pointer) & (typ.BaseTyp=NIL) THEN typ:=ptrtyp; DEC(M.nofstrc); RETURN END;
				NEW(tobj); tobj.mod := SYS.VAL(LONGINT, M); tobj.mode := tobjMode[typtag]; tobj.nxtobj := scope; scope := tobj; tobj.typ := typ; 
				ReadString(R, tobj.name); typ.strobj := tobj; tobj.linkadr := -1;
				IF tobj.name # "" THEN tobj.vis := vis; NEW(strobj); strobj.mode := tobjMode[typtag]; COPY(tobj.name, strobj.name);
					strobj.typ := typ; typ.strobj := strobj; strobj.vis := vis;
				ELSE tobj.vis := internal END;
				CASE typtag OF
					| SFtypDynArr: IF btyp.comp=DynArr THEN typ.n:=btyp.n+1 END
					| SFtypArray: Files.ReadNum(R, typ.n)
					| SFtypPointer:
					| SFtypRecord: InList(Fld, typ.dsc, typ.nofdsc)	(* mfix *)
					| SFtypProcTyp: InList(Par, typ.dsc, typ.nofdsc)
				END
			END
		END InStruct;
	
		PROCEDURE InObj; (* ejz *)
			VAR o: Object; sysflag: CHAR;
		BEGIN NEW(o); o.mod := SYS.VAL(LONGINT, M); o.mode := mode; o.level := level; o.nxtobj := scope; scope := o;
			IF (tag = SFsysflag) & (mode = XProc) THEN
				Files.Read(R, sysflag); Files.ReadNum(R, tag)
			END;
			IF tag = SFreadonly THEN Files.ReadNum(R, tag); o.vis:=externalR	
			ELSIF global THEN o.vis := external	
			ELSE o.vis := internal END;
			IF tag = SFleaf THEN o.leaf := TRUE; Files.ReadNum(R, tag) END;
			InStruct(o.typ); ReadString(R, o.name); obj := o;
		END InObj;
	
		PROCEDURE InConst;
			VAR len: INTEGER; r: REAL;
		BEGIN
			CASE tag OF
			| SFtypBool: Files.ReadNum(R, obj.ival)
			| SFtypChar, SFtypSInt..SFtypLInt: Files.ReadNum(R, obj.ival)
			| SFtypSet: Files.ReadNum(R, obj.ival)
			| SFtypReal: Files.ReadReal(R, r); obj.intval2 := SYS.VAL(LONGINT, r)
			| SFtypLReal: Files.ReadLReal(R, obj.rval)
			| SFtypString: NEW(obj.xval); ReadString(R, obj.xval^); len := 0; WHILE obj.xval[len] # 0X DO INC(len) END;
				 obj.intval2 := len + 1
			| SFtypNilTyp:
			END
		END InConst;

	BEGIN Files.ReadNum(R, tag);
		IF tag = SFconst THEN mode:=Con; Files.ReadNum(R, tag);
			WHILE tag < SFvar DO InObj; InConst; Files.ReadNum(R, tag) END
		END;
		IF tag = SFvar THEN mode:=Var; Files.ReadNum(R, tag);
			WHILE tag < SFlproc DO InObj; Files.ReadNum(R, tag) END
		END;
		IF tag = SFlproc THEN mode:=LProc; Files.ReadNum(R, tag);
			WHILE tag < SFxproc DO InObj; INC(level); InList(Par, obj.par, obj.nofpar); DEC(level); Files.ReadNum(R, tag) END
		END;
		IF tag = SFxproc THEN mode:=XProc; Files.ReadNum(R, tag);
			WHILE tag < SFcproc DO InObj; INC(level); InList(Par, obj.par, obj.nofpar); DEC(level); Files.ReadNum(R, tag) END
		END;
		IF tag = SFcproc THEN Files.ReadNum(R, tag);
			WHILE tag < SFalias DO InStruct(tdum); ReadString(R, ndum); InList(Par, odum, idum); Files.Read(R, ch); Files.Set(R, Files.Base(R), Files.Pos(R) + ORD(ch)); Files.ReadNum(R, tag) END
		END;
		IF tag = SFalias THEN Files.ReadNum(R, tag);
			WHILE tag < SFtyp DO InObj; obj.mode:=TypAlias; Files.ReadNum(R, tag) END
		END;
		IF tag = SFtyp THEN Files.ReadNum(R, tag);
			WHILE tag < SFend DO InStruct(tdum); Files.ReadNum(R, tag) END
		END;
		odum := scope;
		WHILE odum # NIL DO
			IF odum.mode = TypRecord THEN SetTypFlags(odum.typ) END;
			odum := odum.nxtobj
		END
	END ReadScope;

	PROCEDURE EnterTyp(form, tref: SHORTINT; size: LONGINT; VAR typ: Struct; name: ARRAY OF CHAR);
		VAR obj: Object;
	BEGIN NEW(typ); typ.mod := NIL; typ.form := form; typ.comp := Basic; typ.size := size; predefStruct[tref] := typ; 
		typ.fpdone := predefMod; typ.pvfp := size; typ.pbfp := form; typ.fp := form;
		NEW(obj); obj.typ := typ; COPY(name, obj.name); typ.strobj := obj
	END EnterTyp;

BEGIN
	predefMod:=-1;
	EnterTyp(Bool, SFtypBool, 1, booltyp, "BOOLEAN"); EnterTyp(Char, SFtypChar, 1, chartyp, "CHAR");
	EnterTyp(SInt, SFtypSInt, 1, sinttyp, "SHORTINT"); EnterTyp(Int, SFtypInt, 2, inttyp, "INTEGER"); 
	EnterTyp(LInt, SFtypLInt, 4, linttyp, "LONGINT"); EnterTyp(Real, SFtypReal, 4, realtyp, "REAL"); 
	EnterTyp(LReal, SFtypLReal, 8, lrltyp, "LONGREAL"); EnterTyp(Set, SFtypSet, 4, settyp, "SET"); 
	EnterTyp(String, SFtypString, 0, stringtyp, "STRING"); EnterTyp(NilTyp, SFtypNilTyp, 4, niltyp, "NIL"); 
	EnterTyp(NoTyp, SFtypNoTyp, 0, notyp, "NOTYP"); 	
	EnterTyp(Pointer, SFtypPointer, 4, ptrtyp, "PTR"); EnterTyp(Pointer, SFtypSptr, 4, sysptrtyp, "POINTER"); 
	EnterTyp(ProcTyp, SFtypProcTyp, 4, proctyp, "PROC");
	predefStruct[SFtypByte]:=chartyp; 
	strucForm[SFtypPointer]:=Pointer; strucForm[SFtypRecord]:=Comp; strucForm[SFtypProcTyp]:=ProcTyp;
	strucForm[SFtypDynArr]:=Comp; strucForm[SFtypArray]:=Comp;
	strucComp[SFtypPointer]:=Basic; strucComp[SFtypRecord]:=Record; strucComp[SFtypProcTyp]:=Basic;
	strucComp[SFtypDynArr]:=DynArr; strucComp[SFtypArray]:=Array;
	tobjMode[SFtypPointer]:=TypPointer; tobjMode[SFtypRecord]:=TypRecord; tobjMode[SFtypProcTyp]:=TypProcTyp;
	tobjMode[SFtypDynArr]:=TypDynArr; tobjMode[SFtypArray]:=TypArray;
	cobjMode[Var]:=1; cobjMode[Par]:=1; cobjMode[VarPar]:=2; cobjMode[Con]:=3; cobjMode[Fld]:=4;
	cobjMode[XProc]:=7; cobjMode[TypDynArr]:=5; cobjMode[TypArray]:=5; cobjMode[TypPointer]:=5;
	cobjMode[TypRecord]:=5; cobjMode[TypProcTyp]:=5; cobjMode[TypAlias]:=5;
END OPLT.